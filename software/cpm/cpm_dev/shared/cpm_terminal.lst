   1:				; *******************************************************
   2:				; * Terminal Control Routines for CP/M Applications     *
   3:				; * Version: V1.0                                       *
   4:				; * Merlin Skinner, 22/3/2021                           *
   5:				; *******************************************************
   6:				;
   7:				; These routines provide more complex control over the terminal than is offered
   8:				; by the simple generic character read / write used by the monitor and CP/M.
   9:				;
  10:				; The ZARC bios translates console input and output sequences to provide a
  11:				; simple interface to CP/M applications while using a widely available ANSI /
  12:				; VT-100 terminal or emulator externally. Unrecognised sequences are sent
  13:				; without modification, so more advanced features may be accessed in this way.
  14:				; See ZARC CP/M Usersâ€™ Guide for more information.
  15:				
  16:				; There is useful information about VT102 behaviour at:
  17:				; https://www.vt100.net/docs/vt102-ug/chapter5.html#S5.5.2.4
  18:				;
  19:				; Routines preserve all registers not required as operands or return
  20:				; values except AF unless otherwise stated below.
  21:				;
  22:				;
  23:				                title Terminal
  24:				;
  25:     -	0001'         	cpm_terminal    equ 1                   ; Flag module for includes
  26:     -	0001'         	DEBUG           equ 1                   ; Define to enable debug messages
  27:				;
  28:				;
  29:				;
  30:				; ************
  31:				; * Includes *
  32:				; ************
  33:				;
  34:				;
  35:				                include "macros.i"
**** /home/merlin/Technical/ZARC_Z80_Box/git/software/includes//macros.i ****
   1:				; ***********************************
   2:				; * ZARC Macro Definitions          *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 30/7/2020         *
   5:				; ***********************************
   6:				;
   7:				;
   8:				;
   9:				; **********
  10:				; * Macros *
  11:				; **********
  12:				;
  13:				;
  14:				; Initialise enumeration.
  15:				; The absolute segment is used so the offsets are not marked as relocatable. This
  16:				; avoids "Not relocatable" errors.
  17:				ENUM_START      macro
  18:				                .aseg
  19:				enum_counter    set 0
  20:				                endm
  21:				;
  22:				; Invoke for each item.
  23:				ENUM            macro x
  24:				x               equ enum_counter
  25:				enum_counter    set enum_counter + 1
  26:				                endm
  27:				;
  28:				ENUM_END        macro x
  29:				x               set enum_counter    ; Set label to count of items
  30:				                .cseg
  31:				                endm
  32:				;
  33:				;
  34:				; Initialise a structure. This is used to generate offsets for data structures.
  35:				; The absolute segment is used so the offsets are not marked as relocatable. This
  36:				; avoids "Not relocatable" errors.
  37:				STRUCT          macro
  38:				                .aseg
  39:				str_offset      set 0
  40:				                endm
  41:				;
  42:				; Add a byte entry.
  43:				STR_BYTE        macro x
  44:				x               equ str_offset
  45:				str_offset      set str_offset + 1
  46:				                endm
  47:				;
  48:				; Add a word (16-bit) entry.
  49:				STR_WORD        macro x
  50:				x               equ str_offset
  51:				str_offset      set str_offset + 2
  52:				                endm
  53:				;
  54:				; Add a 3 byte (24-bit) entry.
  55:				STR_24BIT       macro x
  56:				x               equ str_offset
  57:				str_offset      set str_offset + 3
  58:				                endm
  59:				;
  60:				; Add a long (32-bit) entry.
  61:				STR_LONG        macro x
  62:				x               equ str_offset
  63:				str_offset      set str_offset + 4
  64:				                endm
  65:				;
  66:				; Add an arbitrary length entry.
  67:				STR_BLOCK       macro x, size   ; <name>, <size>
  68:				x               equ str_offset
  69:				str_offset      set str_offset + size
  70:				                endm
  71:				;
  72:				; End of structure (used to set size)
  73:				STR_END         macro x
  74:				x               equ str_offset
  75:				                .cseg
  76:				                endm
  77:				;
  78:				;
  79:				; Calculate offsets into jump tables.
  80:				; The absolute segment is used so the offsets are not marked as relocatable. This
  81:				; avoids "Not relocatable" errors.
  82:				JPTBL_START     macro x
  83:				                .aseg
  84:				jptbl_addr      set x               ; Set start address
  85:				                endm
  86:				;
  87:				; Invoke for each item.
  88:				JPTBL_ENTRY     macro x
  89:				x               equ jptbl_addr
  90:				jptbl_addr      set jptbl_addr + 3
  91:				                endm
  92:				;
  93:				; Invoke for a data block in the jump table
  94:				JPTBL_BLOCK     macro x, size   ; <name>, <size>
  95:				x               equ jptbl_addr
  96:				jptbl_addr      set jptbl_addr + size
  97:				                endm
  98:				;
  99:				JPTBL_END       macro x
 100:				x               set jptbl_addr      ; Set label to next address
 101:				                .cseg
 102:				                endm
 103:				;
 104:				;
 105:				; Define bits and masks. This is inspired by the Commodore Amiga BITDEF mechanism.
 106:				; Given:
 107:				; BITDEF I2C_CSR_STOP, 2
 108:				; Yields:
 109:				; I2C_CSR_STOP_BIT  EQU 2       ; Bit number
 110:				; I2C_CSR_STOP_MASK EQU 1<<2    ; Bit mask
 111:				BITDEF          macro n, b      ; <Name>, <bit>
 112:				n`_BIT          equ b
 113:				n`_MASK         equ 1 << b
 114:				                endm
 115:				;
 116:				;
 117:				; Force alignment. This asserts an appropriate number of zero bytes to achieve
 118:				; the required alignment. Note that these macros cannot work for relocatable
 119:				; files.
 120:				; 16-bit
 121:				ALIGN_WORD      macro
 122:				                if $ and 1
 123:				                    byte 0
 124:				                endif
 125:				                endm
 126:				;
 127:				; 32-bit
 128:				ALIGN_LONG      macro
 129:				                ALIGN_WORD
 130:				                if $ and 2
 131:				                    byte 0, 0
 132:				                endif
 133:				                endm
 134:				
**** cpm_terminal.z80 ****
  36:				                include "z80.i"
**** /home/merlin/Technical/ZARC_Z80_Box/git/software/includes//z80.i ****
   1:				; ***********************************
   2:				; * ZARC Z80 Definitions            *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 28/5/2020         *
   5:				; ***********************************
   6:				;
   7:				; Definitions related to the Z80 itself.
   8:				;
   9:				; Z80 Vectors
  10:     -	0000'         	Z80_RST00_VEC   equ 0x0000      ; RST instruction vectors
  11:     -	0008'         	Z80_RST08_VEC   equ 0x0008
  12:     -	0010'         	Z80_RST10_VEC   equ 0x0010
  13:     -	0018'         	Z80_RST18_VEC   equ 0x0018
  14:     -	0020'         	Z80_RST20_VEC   equ 0x0020
  15:     -	0028'         	Z80_RST28_VEC   equ 0x0028
  16:     -	0030'         	Z80_RST30_VEC   equ 0x0030
  17:     -	0038'         	Z80_RST38_VEC   equ 0x0038
  18:     -	0066'         	Z80_NMI_VEC     equ 0x0066      ; NMI vectors
  19:				
**** cpm_terminal.z80 ****
  37:				                include "terminal.i"    ; Terminal constants
**** /home/merlin/Technical/ZARC_Z80_Box/git/software/includes//terminal.i ****
   1:				; ***********************************
   2:				; * ZARC Terminal Definitions       *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 16/5/2020         *
   5:				; ***********************************
   6:				;
   7:				; Definitions associated with terminals connected to an RS-232 port.
   8:				;
   9:     -	0005'         	ASCII_ENQ           equ 0x05        ; Enquiry
  10:     -	0008'         	ASCII_BS            equ 0x08        ; Backspace
  11:     -	0009'         	ASCII_HT            equ 0x09
  12:     -	000A'         	ASCII_LF            equ 0x0a        ; Line feed
  13:     -	000B'         	ASCII_VT            equ 0x0b        ; Upline (ADM-3A)
  14:     -	000C'         	ASCII_FF            equ 0x0c        ; Forward space (ADM-3A)
  15:     -	000D'         	ASCII_CR            equ 0x0d        ; Carriage return
  16:     -	0016'         	ASCII_SYN           equ 0x16        ; Synchronous idle
  17:     -	001A'         	ASCII_SUB           equ 0x1a        ; Clear screen (ADM-3A)
  18:     -	001B'         	ASCII_ESC           equ 0x1b        ; Escape
  19:     -	001E'         	ASCII_RS            equ 0x1e        ; Home cursor (ADM-3A)
  20:     -	007F'         	ASCII_DEL           equ 0x7f        ; Delete
  21:				;
  22:				; ZARC CP/M terminal input key codes. Some are copied from Amstrad PCW and
  23:				; Spectrum +3, others are unique to ZARC. Delete seems very common.
  24:     -	001F'         	ZKEY_CSR_UP         equ 0x1f        ; Cursor up
  25:     -	001E'         	ZKEY_CSR_DOWN       equ 0x1e        ; Cursor down
  26:     -	0006'         	ZKEY_CSR_RIGHT      equ 0x06        ; Cursor right
  27:     -	0001'         	ZKEY_CSR_LEFT       equ 0x01        ; Cursor left
  28:     -	0002'         	ZKEY_HOME           equ 0x02
  29:     -	0016'         	ZKEY_INSERT         equ 0x16
  30:     -	007F'         	ZKEY_DELETE         equ 0x7f
  31:     -	0004'         	ZKEY_END            equ 0x04
  32:     -	001D'         	ZKEY_PAGE_UP        equ 0x1d
  33:     -	001C'         	ZKEY_PAGE_DOWN      equ 0x1c
  34:				
**** cpm_terminal.z80 ****
  38:				                include "cpm.i"
**** /home/merlin/Technical/ZARC_Z80_Box/git/software/includes//cpm.i ****
   1:				; *******************************************************
   2:				; * ZARC Monitor CP/M Definitions                       *
   3:				; * Written by: Merlin Skinner                          *
   4:				; * Date Started: 26/5/2020                             *
   5:				; *******************************************************
   6:				;
   7:				; Definitions related CP/M running under the monitor programme.
   8:				;
   9:				; Note that ld80 only considers the first six characters of labels significant.
  10:				;
  11:				; The following conditionals are intended to allow the same include file to be
  12:				; used in the defining module and elsewhere as required. Some includes are used
  13:				; for other applications than the monitor, such as the CP/M BIOS. In these cases,
  14:				; the extern and public statements are not desirable.
  15:				;
  16:     -	0000'         	            ifdef monitor           ; Meaningful for monitor build only
  28:				            endif
  29:				;
  30:				;
  31:				;
  32:				; ****************
  33:				; * Memory Usage *
  34:				; ****************
  35:				;
  36:				;
  37:				; Note: memory banks are allocated by the monitor's initialisation code.
  38:     -	0004'         	MMAP_CPM_PAGES      equ 4               ; Number of 16 kB pages
  39:				;
  40:				; The MS byte of INT_VEC_TABLE comes from the Z80 I register, and the LS byte
  41:				; from the FPGA. The 0xe0 offset is chosen to allow the table to reside at the
  42:				; top of memory (0xffe0 to 0xffff).
  43:     -	FFE0'         	INT_VEC_TABLE   equ 0xffe0              ; Interrupt mode 2 vector table
  44:				;
  45:				; Copied from CP/M manual appendix A.
  46:				; MSIZE             equ 64              ; CP/M version memory size in kilobytes
  47:				;
  48:				; "BIAS" is the address offset from 0x3400 for memory systems other than 16 K.
  49:				;BIAS               equ (MSIZE-20) * 1024
  50:     -	A200'         	CPM_BIAS            equ 0xa200          ; For CompuPro64K_CPM
  51:     -	D600'         	CCP_START           equ 0x3400 + CPM_BIAS   ; Base of CCP
  52:     -	DE06'         	BDOS_START          equ CCP_START + 0x0806  ; Base of BDOS
  53:     -	EC00'         	BIOS_START          equ CCP_START + 0x1600  ; Base of BIOS
  54:     -	002C'         	BIOS_CPM_START_SEC  equ 44              ; First CP/M sector of BIOS
  55:     -	1000'         	BIOS_MAX_SIZE       equ 4096            ; 2 KB allocation for BIOS stored on MMC (ZARC)
  56:     -	0100'         	TPA_START           equ 0x0100          ; Transient Programme Area
  57:				;
  58:				; Page zero.
  59:     -	0003'         	IOBYTE              equ 0x0003          ; Intel I/O byte
  60:     -	0004'         	CDISK               equ 0x0004          ; Current disk (0="A") & user no. (in high nibble)
  61:     -	005C'         	FCB1                equ 0x005c          ; Default FCB 1
  62:     -	006C'         	FCB2                equ 0x006c          ; Default FCB 2 (overwritten if FCB 1 is opened)
  63:				; Default 128-byte disk buffer, also filled with the command line when a transient
  64:				; is loaded under the CCP.
  65:     -	0080'         	DEF_BUFFER          equ 0x80
  66:     -	0080'         	DEF_BUFFER_SIZE     equ 0x80
  67:				;
  68:				; IOBYTE bit definitions.
  69:     -	0003'         	IOB_CON_MASK        equ 0x03
  70:     -	000C'         	IOB_RDR_MASK        equ 0x0c
  71:     -	0030'         	IOB_PUN_MASK        equ 0x30
  72:     -	00C0'         	IOB_LST_MASK        equ 0xc0
  73:				;
  74:				; BIOS option bits.
  75:     -	        	BITDEF BIOS_OPT_DEBUG, 0                ; Enable BIOS debugging messages
  76:     -	        	BITDEF BIOS_OPT_NOINTS, 1               ; Disables interrupts (use basic I/O mode)
  77:     -	        	BITDEF BIOS_OPT_RAWCON, 2               ; Disables ADM-3A to VT-100 translation
  78:				;
  79:				;
  80:				;
  81:				; ***************
  82:				; * Disk System *
  83:				; ***************
  84:				;
  85:				;
  86:     -	0080'         	CPM_SECTOR_SIZE     equ 128             ; CP/M disk sector size
  87:     -	0010'         	NUM_DISKS           equ 16              ; Number of disk drives
  88:     -	0010'         	NUM_DISKS_MAX       equ 16              ; Maximum number of disk drives
  89:     -	0000'         	CPM_SYS_SIZE        equ 1024 * 1024     ; System area size (bytes)
  90:     -	0000'         	CPM_DISK_SIZE       equ 1024 * 1024     ; Disk size (bytes)
  91:     -	0008'         	FILENAME_SIZE       equ 8               ; Filename size
  92:     -	0003'         	FILEEXT_SIZE        equ 3               ; File extension size
  93:     -	001A'         	FILE_EOF            equ 0x1a            ; End of file (^Z)
  94:     -	000F'         	MAX_USER            equ 15              ; Maximum user number
  95:				;
  96:     -	0001'         	BDOS_READ_SEQ_EOF   equ 1               ; Sequential read EOF error code
  97:				;
  98:				; Disk Parameter Header (DPH) structure.
  99:     -	        	                STRUCT
 100:     -	        	                STR_WORD DPH_XLT        ; Address of sector translation table
 101:     -	        	                STR_WORD DPH_SCRATCH0   ; BDOS scratch area
 102:     -	        	                STR_WORD DPH_SCRATCH1
 103:     -	        	                STR_WORD DPH_SCRATCH2
 104:     -	        	                STR_WORD DPH_DIRBF      ; BDOS directory scratch area
 105:     -	        	                STR_WORD DPH_DPB        ; Pointer to DPB
 106:     -	        	                STR_WORD DPH_CSV        ; Pointer to the directory checksum vector
 107:     -	        	                STR_WORD DPH_ALV        ; Pointer to the allocation vector
 108:     -	        	                STR_END DPH_SIZE
 109:				;
 110:				;
 111:				; Disk Parameter Block (DPB) structure.
 112:     -	        	                STRUCT
 113:     -	        	                STR_WORD DPB_SPT        ; Number of 128-byte records per track
 114:     -	        	                STR_BYTE DPB_BSH        ; Block shift. 3 => 1k, 4 => 2k, 5 => 4k....
 115:     -	        	                STR_BYTE DPB_BLM        ; Block mask. 7 => 1k, 0Fh => 2k, 1Fh => 4k...
 116:     -	        	                STR_BYTE DPB_EXM        ; Extent mask
 117:     -	        	                STR_WORD DPB_DSM        ; Maximum block number
 118:     -	        	                STR_WORD DPB_DRM        ; Maximum directory entry number
 119:     -	        	                STR_BYTE DPB_AL0        ; Directory allocation bitmap
 120:     -	        	                STR_BYTE DPB_AL1
 121:     -	        	                STR_WORD DPB_CKS        ; Checksum vector size, 0 for a fixed disc
 122:     -	        	                STR_WORD DPB_OFF        ; Offset, number of reserved tracks
 123:     -	        	                STR_END DPB_SIZE
 124:				;
 125:				;
 126:				; Directory entry structure.
 127:     -	        	                STRUCT
 128:     -	        	                STR_BYTE DIRE_USER      ; User number. 0xe5 if entry unused
 129:     -	        	                STR_BLOCK DIRE_NAME, FILENAME_SIZE  ; Filename
 130:     -	        	                STR_BLOCK DIRE_TYP, FILEEXT_SIZE    ; File type
 131:     -	        	                STR_BYTE DIRE_EX        ; Extent counter, low byte (0-31)
 132:     -	        	                STR_BYTE DIRE_S1        ; Reserved, set to 0
 133:     -	        	                STR_BYTE DIRE_S2        ; Extent counter, high byte
 134:     -	        	                STR_BYTE DIRE_RC        ; Record count (low byte)
 135:     -	        	                STR_BLOCK DIRE_ALLOC, 16 ; Associated block numbers
 136:     -	        	                STR_END DIRE_SIZE
 137:				;
 138:				;
 139:				; File Control Block (FCB) structure.
 140:     -	        	                STRUCT
 141:     -	        	                STR_BYTE FCB_DRIVE      ; Drive. 0 for default, 1-16 for A-P
 142:     -	        	                STR_BLOCK FCB_NAME, FILENAME_SIZE   ; Filename in ASCII upper-case
 143:     -	        	                STR_BLOCK FCB_TYP, FILEEXT_SIZE     ; File type
 144:     -	        	                STR_BYTE FCB_EX         ; Current extent (*)
 145:     -	        	                STR_BYTE FCB_S1         ; Reserved (*)
 146:     -	        	                STR_BYTE FCB_S2         ; Reserved (*)
 147:     -	        	                STR_BYTE FCB_RC         ; Reserved (*)
 148:     -	        	                STR_BLOCK FCB_ALLOC, 16 ; Associated block numbers
 149:     -	        	                STR_BYTE FCB_CR         ; Current record within extent
 150:     -	        	                STR_BLOCK FCB_RECORD, 3 ; Record number (low byte first)
 151:     -	        	                STR_END FCB_SIZE
 152:				;
 153:				; * - Set this to 0 when opening a file and then leave it to CP/M. You can rewind
 154:				; a file by setting EX, RC, S2 and CR to 0.
 155:				;
 156:				;
 157:				;
 158:				; **************
 159:				; * BIOS Calls *
 160:				; **************
 161:				;
 162:				;
 163:				; Calculate offsets into jump tables. Entries here must match the jump table in
 164:				; the BIOS. The base address of the BIOS must be added to these addresses. A call
 165:				; routine might look like:
 166:				;
 167:				; Call BIOS, allowing for its unknown base address.
 168:				; Call with:
 169:				; BC - operand (depends on BIOS function called)
 170:				; DE - operand (depends on BIOS function called)
 171:				; HL - offset for the routine (e.g. BIOS_CONIN)
 172:				; call_bios       push de
 173:				;                 ex de, hl
 174:				;                 ld hl, (1)              ; Find WBOOT (warm boot) address
 175:				;                 add hl, de              ; Add offset
 176:				;                 pop de
 177:				;                 jp (hl)                 ; Jump to BIOS then return to caller
 178:				;
 179:				; The above method is a bit clumsy, but then application code shouldn't normally
 180:				; call the BIOS directly.
 181:				;
 182:     -	        	    JPTBL_START 0                   ; Generate offsets as BIOS_START isn't always known
 183:				;
 184:				; From monitor.z80
 185:				; Note - cold start routine omitted to align with use of address at (1) to find BIOS.
 186:     -	        	    JPTBL_ENTRY BIOS_WBOOT          ; Warm boot - reload command processor
 187:     -	        	    JPTBL_ENTRY BIOS_CONST          ; Console status
 188:     -	        	    JPTBL_ENTRY BIOS_CONIN          ; Console input
 189:     -	        	    JPTBL_ENTRY BIOS_CONOUT         ; Console output
 190:     -	        	    JPTBL_ENTRY BIOS_PLIST          ; Printer output
 191:     -	        	    JPTBL_ENTRY BIOS_PUNCH          ; Paper tape punch output
 192:     -	        	    JPTBL_ENTRY BIOS_READER         ; Paper tape reader input
 193:     -	        	    JPTBL_ENTRY BIOS_HOME           ; Move disc head to track 0
 194:     -	        	    JPTBL_ENTRY BIOS_SELDSK         ; Select disc drive
 195:     -	        	    JPTBL_ENTRY BIOS_SETTRK         ; Set track number
 196:     -	        	    JPTBL_ENTRY BIOS_SETSEC         ; Set sector number
 197:     -	        	    JPTBL_ENTRY BIOS_SETDMA         ; Set DMA address
 198:     -	        	    JPTBL_ENTRY BIOS_READ           ; Read a sector
 199:     -	        	    JPTBL_ENTRY BIOS_WRITE          ; Write a sector
 200:				; CP/M 2 functions.
 201:     -	        	    JPTBL_ENTRY BIOS_LISTST         ; Status of list device
 202:     -	        	    JPTBL_ENTRY BIOS_SECTRAN        ; Sector translation for skewing
 203:				; CP/M 3 functions (not supported yet). From https://www.seasip.info/Cpm/bios.html
 204:     -	        	    JPTBL_ENTRY BIOS_CONOST         ; Status of console output
 205:     -	        	    JPTBL_ENTRY BIOS_AUXIST         ; Status of auxiliary input
 206:     -	        	    JPTBL_ENTRY BIOS_AUXOST         ; Status of auxiliary output
 207:     -	        	    JPTBL_ENTRY BIOS_DEVTBL         ; Address of devices table
 208:     -	        	    JPTBL_ENTRY BIOS_DEVINI         ; Initialise a device
 209:     -	        	    JPTBL_ENTRY BIOS_DRVTBL         ; Address of discs table
 210:     -	        	    JPTBL_ENTRY BIOS_MULTIO         ; Read/write multiple sectors
 211:     -	        	    JPTBL_ENTRY BIOS_FLUSH          ; Flush host buffers
 212:     -	        	    JPTBL_ENTRY BIOS_MOVE           ; Move a block of memory
 213:     -	        	    JPTBL_ENTRY BIOS_TIME           ; Real time clock
 214:     -	        	    JPTBL_ENTRY BIOS_SELMEM         ; Select memory bank
 215:     -	        	    JPTBL_ENTRY BIOS_SETBNK         ; Select bank for DMA operation
 216:     -	        	    JPTBL_ENTRY BIOS_XMOVE          ; Preload banks for MOVE
 217:     -	        	    JPTBL_ENTRY BIOS_USERF          ; System-depedent functions
 218:     -	        	    JPTBL_ENTRY BIOS_RESERV1        ; Reserved
 219:     -	        	    JPTBL_ENTRY BIOS_RESERV2        ; Reserved
 220:				; ZARC-specific items.
 221:     -	        	    JPTBL_BLOCK BIOS_ID, 3          ; BIOS ID ("ZRC")
 222:     -	        	    JPTBL_BLOCK BIOS_VER, 3         ; Version (see below)
 223:     -	        	    JPTBL_ENTRY BIOS_STARTUP        ; CP/M startup entry point
 224:     -	        	    JPTBL_ENTRY BIOS_MON_CALL       ; Call monitor function
 225:     -	        	    JPTBL_ENTRY BIOS_SUPER          ; Set supervisor state
 226:     -	        	    JPTBL_ENTRY BIOS_INT_DISABLE    ; Disable interrupts and keep count
 227:     -	        	    JPTBL_ENTRY BIOS_INT_ENABLE     ; Enable interrupts if safe
 228:     -	        	    JPTBL_ENTRY BIOS_TIRD           ; Read time and date
 229:     -	        	    JPTBL_ENTRY BIOS_SET_TIMER      ; Set timer
 230:     -	        	    JPTBL_ENTRY BIOS_GET_TIMER      ; Get timer
 231:				;
 232:     -	        	    JPTBL_END BIOS_JPTBL_NEXT
 233:				;
 234:				; BIOS_VER is <reserved (zero)>, <major version>, <minor version>. The reserved
 235:				; byte may flag capabilities at some point.
 236:				;
 237:				;
 238:				;
 239:				; **************
 240:				; * BDOS Calls *
 241:				; **************
 242:				;
 243:				;
 244:				; From http://www.gaby.de/cpm/manuals/archive/cpm22htm/ch5.htm#Section_5.2
 245:				; In general, the function number is passed in register C with the information
 246:				; address in the double byte pair DE. Single byte values are returned in register
 247:				; A, with double byte values returned in HL. A zero value is returned when the
 248:				; function number is out of range. For reasons of compatibility, register A = L
 249:				; and register B = H upon return in all cases. Example call:
 250:				;   ld c, BDOS_CONIN    ; Read next character
 251:				;   call BDOS           ; Return character in A
 252:				;
 253:     -	0005'         	BDOS        equ 5               ; BDOS entry point
 254:				;
 255:     -	0000'         	BDOS_SYS_RST        equ 0       ; System Reset
 256:     -	0001'         	BDOS_CON_IN         equ 1       ; Console Input
 257:     -	0002'         	BDOS_CON_OUT        equ 2       ; Console Output
 258:     -	0003'         	BDOS_RDR_IN         equ 3       ; Reader Input
 259:     -	0004'         	BDOS_PUN_OUT        equ 4       ; Punch Output
 260:     -	0005'         	BDOS_LST_OUT        equ 5       ; List Output
 261:     -	0006'         	BDOS_DIRECT_CON_IO  equ 6       ; Direct Console I/O
 262:     -	0007'         	BDOS_GET_IO_BYTE    equ 7       ; Get I/O Byte
 263:     -	0008'         	BDOS_SET_IO_BYTE    equ 8       ; Set I/O Byte
 264:     -	0009'         	BDOS_PRINT_STRING   equ 9       ; Print String
 265:     -	000A'         	BDOS_READ_CON_BUFF  equ 10      ; Read Console Buffer
 266:     -	000B'         	BDOS_GET_CON_STAT   equ 11      ; Get Console Status
 267:     -	000C'         	BDOS_VERSION        equ 12      ; Return Version Number
 268:     -	000D'         	BDOS_RESET_DISK_SYS equ 13      ; Reset Disk System
 269:     -	000E'         	BDOS_SEL_DISK       equ 14      ; Select Disk
 270:     -	000F'         	BDOS_OPEN_FILE      equ 15      ; Open File
 271:     -	0010'         	BDOS_CLOSE_FILE     equ 16      ; Close File
 272:     -	0011'         	BDOS_SEARCH_FIRST   equ 17      ; Search for First
 273:     -	0012'         	BDOS_SEARCH_NEXT    equ 18      ; Search for Next
 274:     -	0013'         	BDOS_DELETE_FILE    equ 19      ; Delete File
 275:     -	0014'         	BDOS_READ_SEQ       equ 20      ; Read Sequential
 276:     -	0015'         	BDOS_WRITE_SEQ      equ 21      ; Write Sequential
 277:     -	0016'         	BDOS_MAKE_FILE      equ 22      ; Make File
 278:     -	0017'         	BDOS_RENAME_FILE    equ 23      ; Rename File
 279:     -	0018'         	BDOS_GET_LOGIN_VEC  equ 24      ; Return Login Vector
 280:     -	0019'         	BDOS_GET_CURR_DISK  equ 25      ; Return Current Disk
 281:     -	001A'         	BDOS_SET_DMA_ADDR   equ 26      ; Set DMA Address
 282:     -	001B'         	BDOS_GET_ALLOC_ADDR equ 27      ; Get Addr (Alloc)
 283:     -	001C'         	BDOS_WRITE_PROT     equ 28      ; Write Protect Disk
 284:     -	001D'         	BDOS_GET_RO_VEC     equ 29      ; Get R/O Vector
 285:     -	001E'         	BDOS_SET_FILE_ATTR  equ 30      ; Set File Attributes
 286:     -	001F'         	BDOS_GET_DPB        equ 31      ; Get Addr (Disk Parms)
 287:     -	0020'         	BDOS_GET_SET_USER   equ 32      ; Set/Get User Code
 288:     -	0021'         	BDOS_READ_RANDOM    equ 33      ; Read Random
 289:     -	0022'         	BDOS_WRITE_RANDOM   equ 34      ; Write Random
 290:     -	0023'         	BDOS_GET_FILE_SIZE  equ 35      ; Compute File Size
 291:     -	0024'         	BDOS_SET_RANDOM_REC equ 36      ; Set Random Record
 292:     -	0025'         	BDOS_RESET_DRIVES   equ 37      ; Selectively reset disc drives
 293:     -	0028'         	BDOS_WRITE_RAN_ZFILL equ 40     ; Write Random with Zero Fill
 294:				
 295:				; Functions 28 and 32 should be avoided in application programs to maintain upward
 296:				; compatibility with CP/M.
 297:				;
 298:				
**** cpm_terminal.z80 ****
  39:				                include "cpm_utility.i" ; CP/M utilities
**** /home/merlin/Technical/ZARC_Z80_Box/git/software/includes//cpm_utility.i ****
   1:				; *******************************************************
   2:				; * Utility Routines for CP/M Applications              *
   3:				; * Version: V1.0                                       *
   4:				; * Merlin Skinner, 16/12/2021                          *
   5:				; *******************************************************
   6:				;
   7:				; Note that ld80 only considers the first six characters of labels significant.
   8:				;
   9:     -	0001'         	            ifndef CPMU         ; Inhibit for this module
  10:				; CP/M specific.
  11:				                extern cbdos    ; Call BDOS with some registers saved
  12:				                extern cbios    ; Call BIOS with some registers saved
  13:				                extern panic    ; Fatal application error
  14:				                extern zrcdet   ; Detect ZARC
  15:				                extern z80det   ; Detect Z80 (instead of 8080 / 8085)
  16:				;
  17:				; Derived from the monitor's utility.z80.
  18:				                extern conwch   ; Write character to console
  19:				                extern conrch   ; Read character from the console
  20:				                extern const    ; Fetch console input status
  21:				                extern cwnwln   ; Write new line characters to console
  22:				                extern conwms   ; Print "$" terminated string to the console
  23:				                extern conwmn   ; Print message <n> in a list
  24:				                extern skpspc   ; Step hl past spaces
  25:				                extern toupca   ; Convert character in A to upper case
  26:				                extern toloca   ; Convert character in A to lower case
  27:				                extern cwvich   ; Print only visible 7-bit characters
  28:				                extern cwpspc   ; Print a space
  29:				                extern mtwdli   ; Match word in a string against list of options
  30:				                extern cwphnb   ; Print least-significant nibble in A in hexadecimal
  31:				                extern cwphby   ; Print A in hexadecimal
  32:				                extern cwphwd   ; Print HL in hexadecimal
  33:				                extern cwpdwd   ; Print HL in decimal. Leading zeros are suppressed
  34:				                extern cwpdby   ; Print A in decimal. Leading zeros are suppressed
  35:				                extern cwpdwd   ; Print HL in decimal. Leading zeros are suppressed
  36:				                extern cwpdlo   ; Print DEHL in decimal. Leading zeros are suppressed
  37:				                extern rdhxwd   ; Read a 16-bit hexadecimal number from a string
  38:				                extern rdduwd   ; Read a 16-bit unsigned decimal number from a string
  39:				                extern rddulo   ; Read a 32-bit unsigned decimal number from a string
  40:				;
  41:				            endif
  42:				;
  43:				;
  44:				; mtwdli (match word in a string against list of options) option bits. Each bit
  45:				; has the described effect if set.
  46:     -	        	BITDEF MTWDLI_ABBREV, 0                 ; Enable "." abbreviation
  47:     -	        	BITDEF MTWDLI_ICASE, 1                  ; Ignore case when matching
  48:     -	        	BITDEF MTWDLI_TERM, 7                   ; Terminator found (internal use only)
  49:				
**** cpm_terminal.z80 ****
  40:				                include "cpm_terminal.i"; Terminal constants
**** /home/merlin/Technical/ZARC_Z80_Box/git/software/includes//cpm_terminal.i ****
   1:				; *******************************************************
   2:				; * Terminal Control Routines for CP/M Applications     *
   3:				; * Version: V1.0                                       *
   4:				; * Merlin Skinner, 16/12/2021                          *
   5:				; *******************************************************
   6:				;
   7:				; These routines provide more complex control over the terminal than is offered
   8:				; by the simple generic character read / write used by the monitor and CP/M.
   9:				;
  10:				; Note that ld80 only considers the first six characters of labels significant.
  11:				;
  12:				; The following conditionals are intended to allow the same include file to be
  13:				; used in the defining module and elsewhere as required. Some includes are used
  14:				; for other applications than the monitor, such as the CP/M BIOS. In these cases,
  15:				; the extern and public statements are not desirable.
  16:				;
  17:     -	0000'         	            ifndef cpm_terminal ; Inhibit for this module
  26:				            endif
  27:				;
  28:				;
  29:     -	0018'         	VT100_ROWS          equ 24
  30:     -	0050'         	VT100_COLS          equ 80
  31:				;
  32:				;
  33:				; The concap (determine terminal capabilities) routine returns a byte
  34:				; indicating various capabilities of the attached terminal. The bits are
  35:				; defined here.
  36:     -	        	BITDEF CONCAP_ZARC, 0           ; ZARC BIOS present
  37:     -	        	BITDEF CONCAP_ANSI, 1           ; ANSI control codes, e.g. VT100
  38:     -	        	BITDEF CONCAP_UNICODE, 2        ; Terminal is capable of Unicode characters
  39:				;
  40:				; Note that Minicom by default emulates a VT102, and is capable of Unicode. If
  41:				; this terminal is detected, both CONCAP_VT100 and CONCAP_UNICODE are set.
  42:				;
  43:				;
  44:				; ANSI graphical rendition (SGR) codes. From https://en.wikipedia.org/wiki/ANSI_escape_code
  45:     -	0000'         	ANSI_SGR_NORMAL     equ 0           ; All attributes off
  46:     -	0001'         	ANSI_SGR_BOLD       equ 1           ; Bold or increased intensity
  47:     -	0002'         	ANSI_SGR_FAINT      equ 2           ; Faint, decreased intensity, or dim
  48:     -	0004'         	ANSI_SGR_ULINE      equ 4           ; Underline
  49:     -	0005'         	ANSI_SGR_SBLINK     equ 5           ; Slow blink
  50:     -	0006'         	ANSI_SGR_RBLINK     equ 6           ; Rapid blink
  51:     -	0007'         	ANSI_SGR_REV        equ 7           ; Reverse video or invert
  52:     -	0009'         	ANSI_SGR_STRIKE     equ 9           ; Characters legible but marked as if for deletion
  53:     -	000A'         	ANSI_SGR_PRI_FONT   equ 10          ; Primary (default) font
  54:     -	000B'         	ANSI_SGR_FONT_1     equ 11          ; Alternative fonts
  55:     -	000C'         	ANSI_SGR_FONT_2     equ 12
  56:     -	000D'         	ANSI_SGR_FONT_3     equ 13
  57:     -	000E'         	ANSI_SGR_FONT_4     equ 14
  58:     -	000F'         	ANSI_SGR_FONT_5     equ 15
  59:     -	0010'         	ANSI_SGR_FONT_6     equ 16
  60:     -	0011'         	ANSI_SGR_FONT_7     equ 17
  61:     -	0012'         	ANSI_SGR_FONT_8     equ 18
  62:     -	0013'         	ANSI_SGR_FONT_9     equ 19
  63:     -	0014'         	ANSI_SGR_GOTHIC     equ 20          ; Fraktur (Gothic) (not widely supported)
  64:     -	0015'         	ANSI_SGR_DULINE     equ 21          ; Doubly underlined *or* not bold
  65:     -	0016'         	ANSI_SGR_NORM_INTEN equ 22          ; Normal intensity
  66:     -	0017'         	ANSI_SGR_ITAL_OFF   equ 23          ; Neither italic, nor blackletter
  67:     -	0018'         	ANSI_SGR_ULINE_OFF  equ 24          ; Underline off
  68:     -	0019'         	ANSI_SGR_BLINK_OFF  equ 25          ; Blinking off
  69:     -	001B'         	ANSI_SGR_REV_OFF    equ 27          ; Reverse image off
  70:     -	001C'         	ANSI_SGR_HIDE_OFF   equ 28          ; Reveal (not concealed)
  71:     -	001D'         	ANSI_SGR_STRIKE_OFF equ 29
  72:				
**** cpm_terminal.z80 ****
  41:				;
  42:				;
  43:				;
  44:				; *************
  45:				; * Externals *
  46:				; *************
  47:				;
  48:				;
  49:				; Variables
  50:				; None.
  51:				;
  52:				; Functions.
  53:				                public concap   ; Console capabilities (CONCAP_xxx)
  54:				                public ccinit   ; Determine terminal capabilities
  55:				                public cldcur   ; Load cursor position
  56:				                public conuln   ; Set underline
  57:				                public conrev   ; Set reverse video
  58:				                public csrvis   ; Show or hide cursor
  59:				                public ccls     ; Clear screen
  60:				                public cscrup   ; Scroll screen up
  61:				;
  62:				;
  63:				;
  64:				; *************
  65:				; * Constants *
  66:				; *************
  67:				;
  68:				;
  69:     -	0050'         	CAT_RESP_BUF_LEN    equ 80          ; Terminal response buffer length
  70:				;
  71:				;
  72:				;
  73:				; ********
  74:				; * Code *
  75:				; ********
  76:				;
  77:				;
  78:				                cseg                    ; Code segment
  79:				;
  80:				; Determine terminal capabilities and set concap appropriately. CONCAP_xxx
  81:				; define the bits in concap. Certain codes are sent to the terminal, and any
  82:				; responses examined. If no reasonable responses are received, the terminal is
  83:				; assumed to have no special capabilities.
  84:    0+11	0000' C5      	ccinit          push bc
  85:   11+11	0001' D5      	                push de
  86:   22+11	0002' E5      	                push hl
  87:				;
  88:   33+10	0003' 212D02  	                ld hl, cc_start_msg     ; "Determining terminal capabilities:"
  89:   43+17	0006' CD0000  	                call conwms             ; Print $-terminated string to console
  90:				;
  91:   60+4	0009' AF      	                xor a
  92:   64+13	000A' 325100  	                ld (concap), a          ; No capabilities initially
  93:				;
  94:				; Are we running on a ZARC system?
  95:   77+17	000D' CD0000  	                call zrcdet             ; Detect ZARC
  96:   94+7+5	0010' 380B    	                jr c, cc_zdet_done      ; Jump if not found
  97:  101+10	0012' 215100  	                ld hl, concap
  98:  111+15	0015' CBC6    	                set CONCAP_ZARC_BIT, (hl)
  99:  126+10	0017' 215002  	                ld hl, cc_zarc_msg      ; " ZARC"
 100:  136+17	001A' CD0000  	                call conwms             ; Print $-terminated string to console
 101:				;
 102:				; Read and discard any data in the console input buffer.
 103:  153+17	001D' CDAC00  	cc_zdet_done    call cat_get_resp       ; Read response
 104:  170+7+5	0020' 3875    	                jr c, cc_exit           ; Exit if buffer overflowed
 105:				;
 106:  177+7	0022' 3E05    	                ld a, ASCII_ENQ         ; Send "ENQ"
 107:  184+17	0024' CD0000  	                call conwch             ; Write character to console
 108:  201+17	0027' CDAC00  	                call cat_get_resp       ; Read response
 109:  218+7+5	002A' 386B    	                jr c, cc_exit           ; Exit if buffer overflowed
 110:				;
 111:				; Compare the response against the expected options.
 112:  225+10	002C' 210000  	                ld hl, cat_resp
 113:  235+10	002F' 11A402  	                ld de, enq_resp_list
 114:  245+4	0032' AF      	                xor a                   ; Disable options (MTWDLI_xxx)
 115:  249+17	0033' CD0000  	                call mtwdli             ; Match against list of options
 116:  266+13	0036' 325000  	                ld (cc_enq_match), a    ; Save option number or zero if no match
 117:				;
 118:				; Report any unrecognised responses to aid debugging, especially for new
 119:				; terminal types.
 120:  279+4	0039' A7      	                and a
 121:  283+7+5	003A' 2009    	                jr nz, cc_enq_done
 122:  290+10	003C' 216502  	                ld hl, cc_unr_enq_msg   ; "Unrecognised ENQ response: "
 123:  300+17	003F' CD0000  	                call conwms             ; Print $-terminated string to console
 124:  317+17	0042' CD9E00  	                call cat_disp_resp      ; Display buffer
 125:				;
 126:				; Try requesting the ANSI device attributes.
 127:  334+10	0045' 21A002  	cc_enq_done     ld hl, cc_da_req_msg    ; 0x1b, "[c$"
 128:  344+17	0048' CD0000  	                call conwms             ; Print $-terminated string to console
 129:  361+17	004B' CDAC00  	                call cat_get_resp       ; Read response
 130:  378+7+5	004E' 3847    	                jr c, cc_exit           ; Exit if buffer overflowed
 131:				;
 132:				; The response from ANSI terminals is summarised nicely at:
 133:				; https://stackoverflow.com/questions/18379477/how-to-interpret-response-from-vt-100-vt-102-da-request
 134:				; For our purposes, anything of the form CSI ? ... c is an ANSI terminal.
 135:				; Further examination of the options could be performed for specific
 136:				; applications.
 137:  385+10	0050' 210000  	                ld hl, cat_resp
 138:  395+7	0053' 7E      	                ld a, (hl)
 139:  402+7	0054' FE1B    	                cp 0x1b
 140:  409+7+5	0056' 2024    	                jr nz, cc_da_not_ansi   ; Not Esc
 141:  416+6	0058' 23      	                inc hl
 142:  422+7	0059' 7E      	                ld a, (hl)
 143:  429+7	005A' FE5B    	                cp "["
 144:  436+7+5	005C' 201E    	                jr nz, cc_da_not_ansi   ; Not "["
 145:  443+6	005E' 23      	                inc hl
 146:  449+7	005F' 7E      	                ld a, (hl)
 147:  456+7	0060' FE3F    	                cp "?"
 148:  463+7+5	0062' 2018    	                jr nz, cc_da_not_ansi   ; Not "?"
 149:				; The last character should be a "c". First find the terminator.
 150:  470+6	0064' 23      	cc_da_term_lp   inc hl
 151:  476+7	0065' 7E      	                ld a, (hl)
 152:  483+4	0066' A7      	                and a
 153:  487+7+5	0067' 20FB    	                jr nz, cc_da_term_lp
 154:  494+6	0069' 2B      	                dec hl
 155:  500+7	006A' 7E      	                ld a, (hl)
 156:  507+7	006B' FE63    	                cp "c"
 157:  514+7+5	006D' 200D    	                jr nz, cc_da_not_ansi   ; Not "c"
 158:				;
 159:				; We have identified an ANSI terminal, so set the appropriate flag.
 160:  521+10	006F' 215100  	                ld hl, concap
 161:  531+15	0072' CBCE    	                set CONCAP_ANSI_BIT, (hl)
 162:  546+10	0074' 215602  	                ld hl, cc_ansi_msg      ; " ANSI "
 163:  556+17	0077' CD0000  	                call conwms             ; Print $-terminated string to console
 164:  573+12	007A' 1809    	                jr cc_da_done
 165:				;
 166:				; Report any unrecognised responses to aid debugging, especially for new
 167:				; terminal types.
 168:  585+10	007C' 218302  	cc_da_not_ansi  ld hl, cc_unr_da_msg    ; "Unrecognised DA response: "
 169:  595+17	007F' CD0000  	                call conwms             ; Print $-terminated string to console
 170:  612+17	0082' CD9E00  	                call cat_disp_resp      ; Display buffer
 171:				;
 172:				; Examine the ENQ response.
 173:  629+13	0085' 3A5000  	cc_da_done      ld a, (cc_enq_match)
 174:  642+7	0088' FE01    	                cp 1
 175:  649+7+5	008A' 200B    	                jr nz, cc_not_minicom
 176:				; Minicom terminal emulator found. This supports Unicode.
 177:  656+10	008C' 215100  	                ld hl, concap
 178:  666+15	008F' CBD6    	                set CONCAP_UNICODE_BIT, (hl)
 179:  681+10	0091' 215C02  	                ld hl, cc_unicode_msg   ; " Unicode "
 180:  691+17	0094' CD0000  	                call conwms             ; Print $-terminated string to console
 181:				;
 182:				; Insert code for other attributes here.
 183:     -	0097'         	cc_not_minicom
 184:				;
 185:  708+17	0097' CD0000  	cc_exit         call cwnwln             ; Write new line characters to console
 186:  725+10	009A' E1      	                pop hl
 187:  735+10	009B' D1      	                pop de
 188:  745+10	009C' C1      	                pop bc
 189:  755+10	009D' C9      	                ret
 190:				;
 191:				;
 192:				; Display the contents of the buffer. Unprintable characters are displayed in
 193:				; hex. No registers are saved.
 194:  765+10	009E' 210000  	cat_disp_resp   ld hl, cat_resp         ; Buffer start
 195:  775+7	00A1' 7E      	cdr_loop        ld a, (hl)
 196:  782+4	00A2' A7      	                and a
 197:  786+5+6	00A3' C8      	                ret z
 198:  791+7	00A4' 0E00    	                ld c, 0                 ; Print unprintables in hex
 199:  798+17	00A6' CD0000  	                call cwvich             ; Print only visible 7-bit characters
 200:  815+6	00A9' 23      	                inc hl
 201:  821+12	00AA' 18F5    	                jr cdr_loop
 202:				;
 203:				;
 204:				; Read any response into the buffer. A null terminator is added. No registers
 205:				; are saved. Timing is very approximate, as there is no way of using hardware
 206:				; timing in CP/M without using extensions. Returns with:
 207:				; carry flag - set if buffer overflows
 208:  833+10	00AC' 210000  	cat_get_resp    ld hl, cat_resp         ; Buffer start
 209:  843+7	00AF' 1E00    	                ld e, 0                 ; Number of characters received
 210:  850+10	00B1' 010020  	cgr_wait_char   ld bc, 0x2000           ; Timer
 211:  860+17	00B4' CD0000  	cgr_wait        call const              ; Fetch console input status
 212:				; A - 0 if no character is ready, 0FFh if one is.
 213:  877+4	00B7' A7      	                and a
 214:  881+7+5	00B8' 2009    	                jr nz, cgr_read
 215:				; No character has arrived.
 216:  888+6	00BA' 0B      	                dec bc
 217:  894+4	00BB' 78      	                ld a, b
 218:  898+4	00BC' B1      	                or c
 219:  902+7+5	00BD' 20F5    	                jr nz, cgr_wait         ; Keep waiting unless timed out
 220:				; Timed out. Add the terminator and exit.
 221:  909+4	00BF' AF      	                xor a
 222:  913+7	00C0' 77      	                ld (hl), a
 223:  920+4	00C1' A7      	                and a                   ; Flag success
 224:  924+10	00C2' C9      	                ret
 225:				;
 226:				; A character awaits. Ensure there is sufficient space in the buffer, allowing
 227:				; for the terminator.
 228:  934+4	00C3' 1C      	cgr_read        inc e
 229:  938+4	00C4' 7B      	                ld a, e
 230:  942+7	00C5' FE50    	                cp CAT_RESP_BUF_LEN
 231:  949+7+5	00C7' 3007    	                jr nc, gcr_overflow     ; Error if no room in buffer
 232:  956+17	00C9' CD0000  	                call conrch             ; Read character from the console
 233:  973+7	00CC' 77      	                ld (hl), a
 234:  980+6	00CD' 23      	                inc hl
 235:  986+12	00CE' 18E1    	                jr cgr_wait_char        ; Wait for another character
 236:				;
 237:				; The response is longer than the buffer.
 238:  998+4	00D0' 37      	gcr_overflow    scf                     ; Flag error
 239: 1002+10	00D1' C9      	                ret
 240:				;
 241:				;
 242:				; Load cursor position. ZARC systems and ANSI terminals are supported.
 243:				; Call with:
 244:				; H - row
 245:				; L - column
 246:				; Returns with:
 247:				; Carry set if the operation could not be performed.
 248:				; (0, 0) is the top left-hand corner.
 249: 1012+11	00D2' E5      	cldcur          push hl
 250:				;
 251: 1023+10	00D3' 215100  	                ld hl, concap           ; Terminal capabilities
 252: 1033+12	00D6' CB46    	                bit CONCAP_ZARC_BIT, (hl)
 253: 1045+7+5	00D8' 2007    	                jr nz, cldc_zarc        ; Jump if on ZARC
 254: 1052+12	00DA' CB4E    	                bit CONCAP_ANSI_BIT, (hl)
 255: 1064+7+5	00DC' 201C    	                jr nz, cldc_ansi        ; Jump if ANSI
 256:				;
 257:				; Not supported.
 258: 1071+10	00DE' E1      	                pop hl
 259: 1081+4	00DF' 37      	                scf                     ; Flag error
 260: 1085+10	00E0' C9      	                ret
 261:				;
 262:				; The ZARC sequence for load cursor Esc Y <y> <x>
 263: 1095+7	00E1' 3E1B    	cldc_zarc       ld a, ASCII_ESC
 264: 1102+17	00E3' CD0000  	                call conwch             ; Write character to console
 265: 1119+7	00E6' 3E59    	                ld a, "Y"
 266: 1126+17	00E8' CD0000  	                call conwch             ; Write character to console
 267: 1143+10	00EB' E1      	                pop hl
 268: 1153+4	00EC' 7C      	                ld a, h                 ; Y (row)
 269: 1157+7	00ED' C620    	                add a, 0x20             ; Add offset
 270: 1164+17	00EF' CD0000  	                call conwch             ; Write character to console
 271: 1181+4	00F2' 7D      	                ld a, l                 ; X (column)
 272: 1185+7	00F3' C620    	                add a, 0x20             ; Add offset
 273: 1192+17	00F5' CD0000  	                call conwch             ; Write character to console
 274: 1209+12	00F8' 1818    	                jr cldc_exit
 275:				;
 276:				; The ANSI sequence for load cursor is CSI n ; m H  where row is n and column
 277:				; is m. (1, 1) is the top left-hand corner. This would actually work on ZARC
 278:				; as well as the sequence would not be translated.
 279: 1221+17	00FA' CDFB01  	cldc_ansi       call ansi_csi           ; Send ANSI CSI sequence
 280: 1238+10	00FD' E1      	                pop hl
 281: 1248+4	00FE' 7C      	                ld a, h
 282: 1252+4	00FF' 3C      	                inc a                   ; Change origin to 1
 283: 1256+17	0100' CD0000  	                call cwpdby             ; Print A in decimal
 284: 1273+7	0103' 3E3B    	                ld a, ";"
 285: 1280+17	0105' CD0000  	                call conwch             ; Write character to console
 286: 1297+4	0108' 7D      	                ld a, l
 287: 1301+4	0109' 3C      	                inc a                   ; Change origin to 1
 288: 1305+17	010A' CD0000  	                call cwpdby             ; Print A in decimal
 289: 1322+7	010D' 3E48    	                ld a, "H"
 290: 1329+17	010F' CD0000  	                call conwch             ; Write character to console
 291:				;
 292: 1346+4	0112' A7      	cldc_exit       and a                   ; Flag success
 293: 1350+10	0113' C9      	                ret
 294:				;
 295:				;
 296:				; Set underline. Call with:
 297:				; A - zero for off, non-zero for on.
 298:				; Returns with:
 299:				; Carry set if the operation could not be performed.
 300: 1360+11	0114' E5      	conuln          push hl
 301:				;
 302: 1371+10	0115' 215100  	                ld hl, concap           ; Terminal capabilities
 303: 1381+12	0118' CB46    	                bit CONCAP_ZARC_BIT, (hl)
 304: 1393+7+5	011A' 2007    	                jr nz, culn_zarc        ; Jump if on ZARC
 305: 1400+12	011C' CB4E    	                bit CONCAP_ANSI_BIT, (hl)
 306: 1412+7+5	011E' 2018    	                jr nz, culn_ansi        ; Jump if ANSI
 307:				;
 308:				; Not supported.
 309: 1419+10	0120' E1      	                pop hl
 310: 1429+4	0121' 37      	                scf                     ; Flag error
 311: 1433+10	0122' C9      	                ret
 312:				;
 313:				; Send ZARC sequence.
 314: 1443+11	0123' F5      	culn_zarc       push af
 315: 1454+7	0124' 3E1B    	                ld a, ASCII_ESC
 316: 1461+17	0126' CD0000  	                call conwch             ; Write character to console
 317: 1478+10	0129' F1      	                pop af
 318: 1488+7	012A' 2E75    	                ld l, "u"               ; Assume underline off
 319: 1495+4	012C' A7      	                and a
 320: 1499+7+5	012D' 2802    	                jr z, culn_zcmd
 321: 1506+7	012F' 2E72    	                ld l, "r"               ; Underline on
 322: 1513+4	0131' 7D      	culn_zcmd       ld a, l
 323: 1517+17	0132' CD0000  	                call conwch             ; Write character to console
 324:				;
 325: 1534+10	0135' E1      	culn_exit       pop hl
 326: 1544+4	0136' A7      	                and a                   ; Flag success
 327: 1548+10	0137' C9      	                ret
 328:				;
 329:				; Send ANSI sequence.
 330: 1558+10	0138' 210502  	culn_ansi       ld hl, culn_off_seq     ; Assume underline off
 331: 1568+4	013B' A7      	                and a
 332: 1572+7+5	013C' 2803    	                jr z, culn_send_seq
 333: 1579+10	013E' 210B02  	                ld hl, culn_on_seq      ; Underline on
 334: 1589+17	0141' CD0000  	culn_send_seq   call conwms             ; Print $-terminated string to console
 335: 1606+12	0144' 18EF    	                jr culn_exit
 336:				;
 337:				;
 338:				; Set reverse video. Call with:
 339:				; A - zero for off, non-zero for on.
 340:				; Returns with:
 341:				; Carry set if the operation could not be performed.
 342: 1618+11	0146' E5      	conrev          push hl
 343:				;
 344: 1629+10	0147' 215100  	                ld hl, concap           ; Terminal capabilities
 345: 1639+12	014A' CB46    	                bit CONCAP_ZARC_BIT, (hl)
 346: 1651+7+5	014C' 2007    	                jr nz, crev_zarc        ; Jump if on ZARC
 347: 1658+12	014E' CB4E    	                bit CONCAP_ANSI_BIT, (hl)
 348: 1670+7+5	0150' 2018    	                jr nz, crev_ansi        ; Jump if ANSI
 349:				;
 350:				; Not supported.
 351: 1677+10	0152' E1      	                pop hl
 352: 1687+4	0153' 37      	                scf                     ; Flag error
 353: 1691+10	0154' C9      	                ret
 354:				;
 355:				; Send ZARC sequence.
 356: 1701+11	0155' F5      	crev_zarc       push af
 357: 1712+7	0156' 3E1B    	                ld a, ASCII_ESC
 358: 1719+17	0158' CD0000  	                call conwch             ; Write character to console
 359: 1736+10	015B' F1      	                pop af
 360: 1746+7	015C' 2E71    	                ld l, "q"               ; Assume reverse off
 361: 1753+4	015E' A7      	                and a
 362: 1757+7+5	015F' 2802    	                jr z, crev_zcmd
 363: 1764+7	0161' 2E70    	                ld l, "p"               ; Reverse on
 364: 1771+4	0163' 7D      	crev_zcmd       ld a, l
 365: 1775+17	0164' CD0000  	                call conwch             ; Write character to console
 366:				;
 367: 1792+10	0167' E1      	crev_exit       pop hl
 368: 1802+4	0168' A7      	                and a                   ; Flag success
 369: 1806+10	0169' C9      	                ret
 370:				;
 371:				; Send ANSI sequence.
 372: 1816+10	016A' 211002  	crev_ansi       ld hl, crev_off_seq     ; Assume reverse off
 373: 1826+4	016D' A7      	                and a
 374: 1830+7+5	016E' 2803    	                jr z, crev_send_seq
 375: 1837+10	0170' 211602  	                ld hl, crev_on_seq      ; Reverse on
 376: 1847+17	0173' CD0000  	crev_send_seq   call conwms             ; Print $-terminated string to console
 377: 1864+12	0176' 18EF    	                jr crev_exit
 378:				;
 379:				;
 380:				; Show or hide the cursor. This assumes an ANSI terminal. Other terminal
 381:				; types could be added if required.
 382:				; Call with:
 383:				; A - zero to hide cursor, any other value enables it.
 384:				; Returns with:
 385:				; Carry set if the operation could not be performed.
 386: 1876+11	0178' E5      	csrvis          push hl
 387:				;
 388: 1887+10	0179' 215100  	                ld hl, concap           ; Terminal capabilities
 389: 1897+12	017C' CB4E    	                bit CONCAP_ANSI_BIT, (hl)
 390: 1909+7+5	017E' 2003    	                jr nz, curv_ansi        ; Jump if ANSI
 391:				;
 392:				; Not supported.
 393: 1916+10	0180' E1      	                pop hl
 394: 1926+4	0181' 37      	                scf                     ; Flag error
 395: 1930+10	0182' C9      	                ret
 396:				;
 397:				; Send appropriate ANSI sequence as follows:
 398:				; CSI ? 25 h     Shows the cursor
 399:				; CSI ? 25 l     Hides the cursor
 400: 1940+11	0183' F5      	curv_ansi       push af
 401: 1951+10	0184' 211B02  	                ld hl, curv_seq_msg     ; 0x1b, "[?25"
 402: 1961+17	0187' CD0000  	                call conwms             ; Print $-terminated string to console
 403: 1978+7	018A' 2E68    	                ld l, "h"               ; Show command
 404: 1985+10	018C' F1      	                pop af
 405: 1995+4	018D' A7      	                and a
 406: 1999+7+5	018E' 2002    	                jr nz, curv_tx_cmd      ; Jump to show cursor
 407: 2006+7	0190' 2E6C    	                ld l, "l"               ; Hide command
 408: 2013+4	0192' 7D      	curv_tx_cmd     ld a, l
 409: 2017+17	0193' CD0000  	                call conwch             ; Write character to console
 410:				;
 411: 2034+10	0196' E1      	curv_exit       pop hl
 412: 2044+4	0197' A7      	                and a                   ; Flag success
 413: 2048+10	0198' C9      	                ret
 414:				;
 415:				;
 416:				; Clear the screen. This assumes an ANSI terminal. Other terminal types could
 417:				; be added if required. Returns with:
 418:				; Carry set if the operation could not be performed.
 419: 2058+11	0199' E5      	ccls            push hl
 420:				;
 421: 2069+10	019A' 215100  	                ld hl, concap           ; Terminal capabilities
 422: 2079+12	019D' CB46    	                bit CONCAP_ZARC_BIT, (hl)
 423: 2091+7+5	019F' 2007    	                jr nz, ccls_zarc        ; Jump if on ZARC
 424: 2098+12	01A1' CB4E    	                bit CONCAP_ANSI_BIT, (hl)
 425: 2110+7+5	01A3' 200C    	                jr nz, ccls_ansi        ; Jump if ANSI
 426:				;
 427:				; Not supported.
 428: 2117+10	01A5' E1      	                pop hl
 429: 2127+4	01A6' 37      	                scf                     ; Flag error
 430: 2131+10	01A7' C9      	                ret
 431:				;
 432:				; Send ZARC sequence.
 433: 2141+10	01A8' 212102  	ccls_zarc       ld hl, ccls_zseq_msg
 434: 2151+17	01AB' CD0000  	                call conwms             ; Print $-terminated string to console
 435:				;
 436: 2168+10	01AE' E1      	ccls_exit       pop hl
 437: 2178+4	01AF' A7      	                and a                   ; Flag success
 438: 2182+10	01B0' C9      	                ret
 439:				;
 440:				; Send ANSI sequence.
 441: 2192+10	01B1' 212602  	ccls_ansi       ld hl, ccls_aseq_msg
 442: 2202+17	01B4' CD0000  	                call conwms             ; Print $-terminated string to console
 443: 2219+12	01B7' 18F5    	                jr ccls_exit
 444:				;
 445:				;
 446:				; Scroll screen up. The cursor position on exit is indeterminate. This assumes
 447:				; an ANSI terminal. Other terminal types could be added if required. Call with:
 448:				; H - first display row number (0 to ...)
 449:				; L - last display row number (0 to ...)
 450:				; If HL is 0xffff, the entire display is scrolled.
 451:				; Returns with:
 452:				; Carry set if the operation could not be performed.
 453: 2231+11	01B9' E5      	cscrup          push hl
 454:				;
 455: 2242+10	01BA' 215100  	                ld hl, concap           ; Terminal capabilities
 456: 2252+12	01BD' CB4E    	                bit CONCAP_ANSI_BIT, (hl)
 457:				; For the time being, we can only cope with ANSI-capable terminals.
 458: 2264+7+5	01BF' 2003    	                jr nz, scrup_ansi
 459:				;
 460:				; Not supported.
 461: 2271+10	01C1' E1      	                pop hl
 462: 2281+4	01C2' 37      	                scf                     ; Flag error
 463: 2285+10	01C3' C9      	                ret
 464:				;
 465: 2295+17	01C4' CDFB01  	scrup_ansi      call ansi_csi           ; Send ANSI CSI sequence
 466:				;
 467: 2312+10	01C7' E1      	                pop hl
 468: 2322+4	01C8' 7C      	                ld a, h
 469: 2326+4	01C9' A5      	                and l
 470: 2330+4	01CA' 3C      	                inc a
 471:				; Result will be zero if HL was 0xffff.
 472: 2334+7+5	01CB' 280F    	                jr z, scrup_rgn_done    ; Jump if entire display requested
 473:				;
 474:				; Send first and last line numbers.
 475: 2341+4	01CD' 7C      	                ld a, h
 476: 2345+4	01CE' 3C      	                inc a                   ; Make origin 1
 477: 2349+17	01CF' CD0000  	                call cwpdby             ; Print A in decimal
 478: 2366+7	01D2' 3E3B    	                ld a, ";"
 479: 2373+17	01D4' CD0000  	                call conwch             ; Write character to console
 480: 2390+4	01D7' 7D      	                ld a, l
 481: 2394+4	01D8' 3C      	                inc a                   ; Make origin 1
 482: 2398+17	01D9' CD0000  	                call cwpdby             ; Print A in decimal
 483:				;
 484: 2415+7	01DC' 3E72    	scrup_rgn_done  ld a, "r"
 485: 2422+17	01DE' CD0000  	                call conwch             ; Write character to console
 486:				;
 487:				; Now do the scroll. The "scroll up" ("S") sequence is not recognised, at least
 488:				; by Minicom. We can work around this by moving the cursor to the bottom of the
 489:				; scroll region and sending a CR / LF sequence.
 490:				;                call ansi_csi           ; Send ANSI CSI sequence
 491:				;                ld a, "S"
 492:				;                call conwch             ; Write character to console
 493:				; Set bottom row to 24 if not specified. This is the number of rows for a
 494:				; VT100.
 495: 2439+4	01E1' 7D      	                ld a, l
 496: 2443+7	01E2' FEFF    	                cp 0xff
 497: 2450+7+5	01E4' 2002    	                jr nz, scrup_have_bot   ; Jump if bottom row specified
 498: 2457+7	01E6' 2E17    	                ld l, VT100_ROWS - 1
 499: 2464+4	01E8' 65      	scrup_have_bot  ld h, l                 ; Row
 500: 2468+7	01E9' 2E00    	                ld l, 0                 ; Column
 501: 2475+17	01EB' CDD200  	                call cldcur             ; Load cursor position
 502:				; Write a newline to trigger the scroll. A single newline would probably be
 503:				; sufficient.
 504: 2492+17	01EE' CD0000  	                call cwnwln             ; Write new line characters to console
 505:				;
 506:				; Set scroll region back to maximum. This will move the cursor to the top
 507:				; left-hand corner of the screen. Part of the reason for doing this is to
 508:				; minimise the probability of an unexpected exit leaving the display with a
 509:				; reduced scrolling region set.
 510: 2509+17	01F1' CDFB01  	                call ansi_csi           ; Send ANSI CSI sequence
 511: 2526+7	01F4' 3E72    	                ld a, "r"
 512: 2533+17	01F6' CD0000  	                call conwch             ; Write character to console
 513:				;
 514: 2550+4	01F9' A7      	                and a                   ; Flag success
 515: 2554+10	01FA' C9      	                ret
 516:				;
 517:				;
 518:				;
 519:				; ***************
 520:				; * Subroutines *
 521:				; ***************
 522:				;
 523:				;
 524:				; Send ANSI CSI sequence.
 525: 2564+7	01FB' 3E1B    	ansi_csi        ld a, ASCII_ESC
 526: 2571+17	01FD' CD0000  	                call conwch             ; Write character to console
 527: 2588+7	0200' 3E5B    	                ld a, "["
 528: 2595+10	0202' C30000  	                jp conwch               ; Write character to console
 529:				;
 530:				;
 531:				;
 532:				; *************
 533:				; * Constants *
 534:				; *************
 535:				;
 536:				;
 537:     -	0205' 1B5B3234	culn_off_seq    byte 0x1b, "[24m$"      ; Underline off
	              6D24
 538:     -	020B' 1B5B346D	culn_on_seq     byte 0x1b, "[4m$"       ; Underline on
	              24
 539:     -	0210' 1B5B3237	crev_off_seq    byte 0x1b, "[27m$"      ; Reverse off
	              6D24
 540:     -	0216' 1B5B376D	crev_on_seq     byte 0x1b, "[7m$"       ; Reverse on
	              24
 541:     -	021B' 1B5B3F32	curv_seq_msg    byte 0x1b, "[?25$"      ; Cursor visibility
	              3524
 542:     -	0221' 1B481B4A	ccls_zseq_msg   byte 0x1b, "H", 0x1b, "J$"      ; ZARC clear screen
	              24
 543:     -	0226' 1B5B481B	ccls_aseq_msg   byte 0x1b, "[H", 0x1b, "[J$"    ; ANSI clear screen
	              5B4A24
 544:     -	022D' 44657465	cc_start_msg    byte "Determining terminal capabilities:$"
	              726D696E
	              696E6720
	              7465726D
	              696E616C
	              20636170
	              6162696C
	              69746965
	              733A24
 545:     -	0250' 205A4152	cc_zarc_msg     byte " ZARC$"
	              4324
 546:     -	0256' 20414E53	cc_ansi_msg     byte " ANSI$"
	              4924
 547:     -	025C' 20556E69	cc_unicode_msg  byte " Unicode$"
	              636F6465
	              24
 548:     -	0265' 0D0A556E	cc_unr_enq_msg  byte 0x0d, 0x0a, "Unrecognised ENQ response: $"
	              7265636F
	              676E6973
	              65642045
	              4E512072
	              6573706F
	              6E73653A
	              2024
 549:     -	0283' 0D0A556E	cc_unr_da_msg   byte 0x0d, 0x0a, "Unrecognised DA response: $"
	              7265636F
	              676E6973
	              65642044
	              41207265
	              73706F6E
	              73653A20
	              24
 550:     -	02A0' 1B5B6324	cc_da_req_msg   byte 0x1b, "[c$"        ; Request device attributes
 551:				; List of responses to ENQ.
 552:     -	02A4' 4D696E69	enq_resp_list   byte "Minicom2.8"       ; List of responses to ENQ
	              636F6D32
	              2E38
 553:     -	02AE' 00      	                byte 0
 554:				;
 555:				;
 556:				;
 557:				; *************
 558:				; * Variables *
 559:				; *************
 560:				;
 561:				; Note: linker "-c" option is used, so no data is initialised here.
 562:				                dseg                ; Data segment
 563:				;
 564:     -	0000"         	cat_resp        defs CAT_RESP_BUF_LEN               ; Terminal response
 565:     -	0050"         	cc_enq_match    defs 1              ; ENQ response match number
 566:     -	0051"         	concap          defs 1              ; Terminal capabilities
 567:				;
 568:     -	0052"         	                end



Statistics:

     4	passes
     0	jr promotions
   323	symbols
   687	bytes

    97	macro calls
  1546	macro bytes
     0	invented symbols



Symbol Table:

ANSI_SGR_BLINK_OFF=19        25
ANSI_SGR_BOLD  =01        1
ANSI_SGR_DULINE=15        21
ANSI_SGR_FAINT =02        2
ANSI_SGR_FONT_1=0B        11
ANSI_SGR_FONT_2=0C        12
ANSI_SGR_FONT_3=0D        13
ANSI_SGR_FONT_4=0E        14
ANSI_SGR_FONT_5=0F        15
ANSI_SGR_FONT_6=10        16
ANSI_SGR_FONT_7=11        17
ANSI_SGR_FONT_8=12        18
ANSI_SGR_FONT_9=13        19
ANSI_SGR_GOTHIC=14        20
ANSI_SGR_HIDE_OFF=1C        28
ANSI_SGR_ITAL_OFF=17        23
ANSI_SGR_NORMAL=00        0
ANSI_SGR_NORM_INTEN=16        22
ANSI_SGR_PRI_FONT=0A        10
ANSI_SGR_RBLINK=06        6
ANSI_SGR_REV   =07        7
ANSI_SGR_REV_OFF=1B        27
ANSI_SGR_SBLINK=05        5
ANSI_SGR_STRIKE=09        9
ANSI_SGR_STRIKE_OFF=1D        29
ANSI_SGR_ULINE =04        4
ANSI_SGR_ULINE_OFF=18        24
ASCII_BS       =08        8
ASCII_CR       =0D        13
ASCII_DEL      =7F        127
ASCII_ENQ      =05        5
ASCII_ESC      =1B        27
ASCII_FF       =0C        12
ASCII_HT       =09        9
ASCII_LF       =0A        10
ASCII_RS       =1E        30
ASCII_SUB      =1A        26
ASCII_SYN      =16        22
ASCII_VT       =0B        11
BDOS           =05        5
BDOS_CLOSE_FILE=10        16
BDOS_CON_IN    =01        1
BDOS_CON_OUT   =02        2
BDOS_DELETE_FILE=13        19
BDOS_DIRECT_CON_IO=06        6
BDOS_GET_ALLOC_ADDR=1B        27
BDOS_GET_CON_STAT=0B        11
BDOS_GET_CURR_DISK=19        25
BDOS_GET_DPB   =1F        31
BDOS_GET_FILE_SIZE=23        35
BDOS_GET_IO_BYTE=07        7
BDOS_GET_LOGIN_VEC=18        24
BDOS_GET_RO_VEC=1D        29
BDOS_GET_SET_USER=20        32
BDOS_LST_OUT   =05        5
BDOS_MAKE_FILE =16        22
BDOS_OPEN_FILE =0F        15
BDOS_PRINT_STRING=09        9
BDOS_PUN_OUT   =04        4
BDOS_RDR_IN    =03        3
BDOS_READ_CON_BUFF=0A        10
BDOS_READ_RANDOM=21        33
BDOS_READ_SEQ  =14        20
BDOS_READ_SEQ_EOF=01        1
BDOS_RENAME_FILE=17        23
BDOS_RESET_DISK_SYS=0D        13
BDOS_RESET_DRIVES=25        37
BDOS_SEARCH_FIRST=11        17
BDOS_SEARCH_NEXT=12        18
BDOS_SEL_DISK  =0E        14
BDOS_SET_DMA_ADDR=1A        26
BDOS_SET_FILE_ATTR=1E        30
BDOS_SET_IO_BYTE=08        8
BDOS_SET_RANDOM_REC=24        36
BDOS_START     =DE06      56838
BDOS_SYS_RST   =00        0
BDOS_VERSION   =0C        12
BDOS_WRITE_PROT=1C        28
BDOS_WRITE_RANDOM=22        34
BDOS_WRITE_RAN_ZFILL=28        40
BDOS_WRITE_SEQ =15        21
BIOS_AUXIST    =33        51
BIOS_AUXOST    =36        54
BIOS_CONIN     =06        6
BIOS_CONOST    =30        48
BIOS_CONOUT    =09        9
BIOS_CONST     =03        3
BIOS_CPM_START_SEC=2C        44
BIOS_DEVINI    =3C        60
BIOS_DEVTBL    =39        57
BIOS_DRVTBL    =3F        63
BIOS_FLUSH     =45        69
BIOS_GET_TIMER =7B        123
BIOS_HOME      =15        21
BIOS_ID        =60        96
BIOS_INT_DISABLE=6F        111
BIOS_INT_ENABLE=72        114
BIOS_JPTBL_NEXT=7E        126
BIOS_LISTST    =2A        42
BIOS_MAX_SIZE  =1000      4096
BIOS_MON_CALL  =69        105
BIOS_MOVE      =48        72
BIOS_MULTIO    =42        66
BIOS_OPT_DEBUG_BIT=00        0
BIOS_OPT_DEBUG_MASK=01        1
BIOS_OPT_NOINTS_BIT=01        1
BIOS_OPT_NOINTS_MASK=02        2
BIOS_OPT_RAWCON_BIT=02        2
BIOS_OPT_RAWCON_MASK=04        4
BIOS_PLIST     =0C        12
BIOS_PUNCH     =0F        15
BIOS_READ      =24        36
BIOS_READER    =12        18
BIOS_RESERV1   =5A        90
BIOS_RESERV2   =5D        93
BIOS_SECTRAN   =2D        45
BIOS_SELDSK    =18        24
BIOS_SELMEM    =4E        78
BIOS_SETBNK    =51        81
BIOS_SETDMA    =21        33
BIOS_SETSEC    =1E        30
BIOS_SETTRK    =1B        27
BIOS_SET_TIMER =78        120
BIOS_START     =EC00      60416
BIOS_STARTUP   =66        102
BIOS_SUPER     =6C        108
BIOS_TIME      =4B        75
BIOS_TIRD      =75        117
BIOS_USERF     =57        87
BIOS_VER       =63        99
BIOS_WBOOT     =00        0
BIOS_WRITE     =27        39
BIOS_XMOVE     =54        84
CAT_RESP_BUF_LEN=50        80
CCP_START      =D600      54784
CDISK          =04        4
CONCAP_ANSI_BIT=01        1
CONCAP_ANSI_MASK=02        2
CONCAP_UNICODE_BIT=02        2
CONCAP_UNICODE_MASK=04        4
CONCAP_ZARC_BIT=00        0
CONCAP_ZARC_MASK=01        1
CPM_BIAS       =A200      41472
CPM_DISK_SIZE  =00100000  1048576
CPM_SECTOR_SIZE=80        128
CPM_SYS_SIZE   =00100000  1048576
DEBUG          =01        1
DEF_BUFFER     =80        128
DEF_BUFFER_SIZE=80        128
DIRE_ALLOC     =10        16
DIRE_EX        =0C        12
DIRE_NAME      =01        1
DIRE_RC        =0F        15
DIRE_S1        =0D        13
DIRE_S2        =0E        14
DIRE_SIZE      =20        32
DIRE_TYP       =09        9
DIRE_USER      =00        0
DPB_AL0        =09        9
DPB_AL1        =0A        10
DPB_BLM        =03        3
DPB_BSH        =02        2
DPB_CKS        =0B        11
DPB_DRM        =07        7
DPB_DSM        =05        5
DPB_EXM        =04        4
DPB_OFF        =0D        13
DPB_SIZE       =0F        15
DPB_SPT        =00        0
DPH_ALV        =0E        14
DPH_CSV        =0C        12
DPH_DIRBF      =08        8
DPH_DPB        =0A        10
DPH_SCRATCH0   =02        2
DPH_SCRATCH1   =04        4
DPH_SCRATCH2   =06        6
DPH_SIZE       =10        16
DPH_XLT        =00        0
FCB1           =5C        92
FCB2           =6C        108
FCB_ALLOC      =10        16
FCB_CR         =20        32
FCB_DRIVE      =00        0
FCB_EX         =0C        12
FCB_NAME       =01        1
FCB_RC         =0F        15
FCB_RECORD     =21        33
FCB_S1         =0D        13
FCB_S2         =0E        14
FCB_SIZE       =24        36
FCB_TYP        =09        9
FILEEXT_SIZE   =03        3
FILENAME_SIZE  =08        8
FILE_EOF       =1A        26
INT_VEC_TABLE  =FFE0      65504
IOBYTE         =03        3
IOB_CON_MASK   =03        3
IOB_LST_MASK   =C0        192
IOB_PUN_MASK   =30        48
IOB_RDR_MASK   =0C        12
MAX_USER       =0F        15
MMAP_CPM_PAGES =04        4
MTWDLI_ABBREV_BIT=00        0
MTWDLI_ABBREV_MASK=01        1
MTWDLI_ICASE_BIT=01        1
MTWDLI_ICASE_MASK=02        2
MTWDLI_TERM_BIT=07        7
MTWDLI_TERM_MASK=80        128
NUM_DISKS      =10        16
NUM_DISKS_MAX  =10        16
TPA_START      = 100      256
VT100_COLS     =50        80
VT100_ROWS     =18        24
Z80_NMI_VEC    =66        102
Z80_RST00_VEC  =00        0
Z80_RST08_VEC  =08        8
Z80_RST10_VEC  =10        16
Z80_RST18_VEC  =18        24
Z80_RST20_VEC  =20        32
Z80_RST28_VEC  =28        40
Z80_RST30_VEC  =30        48
Z80_RST38_VEC  =38        56
ZKEY_CSR_DOWN  =1E        30
ZKEY_CSR_LEFT  =01        1
ZKEY_CSR_RIGHT =06        6
ZKEY_CSR_UP    =1F        31
ZKEY_DELETE    =7F        127
ZKEY_END       =04        4
ZKEY_HOME      =02        2
ZKEY_INSERT    =16        22
ZKEY_PAGE_DOWN =1C        28
ZKEY_PAGE_UP   =1D        29
ansi_csi         1FB'     507
cat_disp_resp   9E'       158
cat_get_resp    AC'       172
cat_resp        00"       0
cbdos           00        0 (extern)
cbios           00        0 (extern)
cc_ansi_msg      256'     598
cc_da_done      85'       133
cc_da_not_ansi  7C'       124
cc_da_req_msg    2A0'     672
cc_da_term_lp   64'       100
cc_enq_done     45'       69
cc_enq_match    50"       80
cc_exit         97'       151
cc_not_minicom  97'       151
cc_start_msg     22D'     557
cc_unicode_msg   25C'     604
cc_unr_da_msg    283'     643
cc_unr_enq_msg   265'     613
cc_zarc_msg      250'     592
cc_zdet_done    1D'       29
ccinit          00'       0 (public)
ccls             199'     409 (public)
ccls_ansi        1B1'     433
ccls_aseq_msg    226'     550
ccls_exit        1AE'     430
ccls_zarc        1A8'     424
ccls_zseq_msg    221'     545
cdr_loop        A1'       161
cgr_read        C3'       195
cgr_wait        B4'       180
cgr_wait_char   B1'       177
cldc_ansi       FA'       250
cldc_exit        112'     274
cldc_zarc       E1'       225
cldcur          D2'       210 (public)
concap          51"       81 (public)
conrch          00        0 (extern)
conrev           146'     326 (public)
const           00        0 (extern)
conuln           114'     276 (public)
conwch          00        0 (extern)
conwmn          00        0 (extern)
conwms          00        0 (extern)
cpm_terminal   =01        1
crev_ansi        16A'     362
crev_exit        167'     359
crev_off_seq     210'     528
crev_on_seq      216'     534
crev_send_seq    173'     371
crev_zarc        155'     341
crev_zcmd        163'     355
cscrup           1B9'     441 (public)
csrvis           178'     376 (public)
culn_ansi        138'     312
culn_exit        135'     309
culn_off_seq     205'     517
culn_on_seq      20B'     523
culn_send_seq    141'     321
culn_zarc        123'     291
culn_zcmd        131'     305
curv_ansi        183'     387
curv_exit        196'     406
curv_seq_msg     21B'     539
curv_tx_cmd      192'     402
cwnwln          00        0 (extern)
cwpdby          00        0 (extern)
cwpdlo          00        0 (extern)
cwpdwd          00        0 (extern)
cwphby          00        0 (extern)
cwphnb          00        0 (extern)
cwphwd          00        0 (extern)
cwpspc          00        0 (extern)
cwvich          00        0 (extern)
enq_resp_list    2A4'     676
gcr_overflow    D0'       208
jptbl_addr     =7E        126
mtwdli          00        0 (extern)
panic           00        0 (extern)
rddulo          00        0 (extern)
rdduwd          00        0 (extern)
rdhxwd          00        0 (extern)
scrup_ansi       1C4'     452
scrup_have_bot   1E8'     488
scrup_rgn_done   1DC'     476
skpspc          00        0 (extern)
str_offset     =24        36
toloca          00        0 (extern)
toupca          00        0 (extern)
z80det          00        0 (extern)
zrcdet          00        0 (extern)
