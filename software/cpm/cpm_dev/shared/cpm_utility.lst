   1:				; *******************************************************
   2:				; * Utility Routines for CP/M Applications              *
   3:				; * Version: V1.0                                       *
   4:				; * Merlin Skinner, 22/3/2021                           *
   5:				; *******************************************************
   6:				;
   7:				; Support routines for use with CP/M applications. Character I/O is performed
   8:				; using BIOS routines (rather than the BDOS) as this avoids unwanted echoing of
   9:				; input, for example. BDOS features such as tab expansion are not that useful
  10:				; as they are easily confused by ANSI control codes, for example.
  11:				;
  12:				; Routines preserve all registers not required as operands or return
  13:				; values except AF unless otherwise stated below.
  14:				;
  15:				;
  16:				                title Utilites
  17:				;
  18:     -	0001'         	CPMU            equ 1                   ; Flag module for includes
  19:				;
  20:				;
  21:				;
  22:				; ************
  23:				; * Includes *
  24:				; ************
  25:				;
  26:				;
  27:				                include "macros.i"
**** /home/merlin/Technical/ZARC_Z80_Box/git/software/includes//macros.i ****
   1:				; ***********************************
   2:				; * ZARC Macro Definitions          *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 30/7/2020         *
   5:				; ***********************************
   6:				;
   7:				;
   8:				;
   9:				; **********
  10:				; * Macros *
  11:				; **********
  12:				;
  13:				;
  14:				; Initialise enumeration.
  15:				; The absolute segment is used so the offsets are not marked as relocatable. This
  16:				; avoids "Not relocatable" errors.
  17:				ENUM_START      macro
  18:				                .aseg
  19:				enum_counter    set 0
  20:				                endm
  21:				;
  22:				; Invoke for each item.
  23:				ENUM            macro x
  24:				x               equ enum_counter
  25:				enum_counter    set enum_counter + 1
  26:				                endm
  27:				;
  28:				ENUM_END        macro x
  29:				x               set enum_counter    ; Set label to count of items
  30:				                .cseg
  31:				                endm
  32:				;
  33:				;
  34:				; Initialise a structure. This is used to generate offsets for data structures.
  35:				; The absolute segment is used so the offsets are not marked as relocatable. This
  36:				; avoids "Not relocatable" errors.
  37:				STRUCT          macro
  38:				                .aseg
  39:				str_offset      set 0
  40:				                endm
  41:				;
  42:				; Add a byte entry.
  43:				STR_BYTE        macro x
  44:				x               equ str_offset
  45:				str_offset      set str_offset + 1
  46:				                endm
  47:				;
  48:				; Add a word (16-bit) entry.
  49:				STR_WORD        macro x
  50:				x               equ str_offset
  51:				str_offset      set str_offset + 2
  52:				                endm
  53:				;
  54:				; Add a 3 byte (24-bit) entry.
  55:				STR_24BIT       macro x
  56:				x               equ str_offset
  57:				str_offset      set str_offset + 3
  58:				                endm
  59:				;
  60:				; Add a long (32-bit) entry.
  61:				STR_LONG        macro x
  62:				x               equ str_offset
  63:				str_offset      set str_offset + 4
  64:				                endm
  65:				;
  66:				; Add an arbitrary length entry.
  67:				STR_BLOCK       macro x, size   ; <name>, <size>
  68:				x               equ str_offset
  69:				str_offset      set str_offset + size
  70:				                endm
  71:				;
  72:				; End of structure (used to set size)
  73:				STR_END         macro x
  74:				x               equ str_offset
  75:				                .cseg
  76:				                endm
  77:				;
  78:				;
  79:				; Calculate offsets into jump tables.
  80:				; The absolute segment is used so the offsets are not marked as relocatable. This
  81:				; avoids "Not relocatable" errors.
  82:				JPTBL_START     macro x
  83:				                .aseg
  84:				jptbl_addr      set x               ; Set start address
  85:				                endm
  86:				;
  87:				; Invoke for each item.
  88:				JPTBL_ENTRY     macro x
  89:				x               equ jptbl_addr
  90:				jptbl_addr      set jptbl_addr + 3
  91:				                endm
  92:				;
  93:				; Invoke for a data block in the jump table
  94:				JPTBL_BLOCK     macro x, size   ; <name>, <size>
  95:				x               equ jptbl_addr
  96:				jptbl_addr      set jptbl_addr + size
  97:				                endm
  98:				;
  99:				JPTBL_END       macro x
 100:				x               set jptbl_addr      ; Set label to next address
 101:				                .cseg
 102:				                endm
 103:				;
 104:				;
 105:				; Define bits and masks. This is inspired by the Commodore Amiga BITDEF mechanism.
 106:				; Given:
 107:				; BITDEF I2C_CSR_STOP, 2
 108:				; Yields:
 109:				; I2C_CSR_STOP_BIT  EQU 2       ; Bit number
 110:				; I2C_CSR_STOP_MASK EQU 1<<2    ; Bit mask
 111:				BITDEF          macro n, b      ; <Name>, <bit>
 112:				n`_BIT          equ b
 113:				n`_MASK         equ 1 << b
 114:				                endm
 115:				;
 116:				;
 117:				; Force alignment. This asserts an appropriate number of zero bytes to achieve
 118:				; the required alignment. Note that these macros cannot work for relocatable
 119:				; files.
 120:				; 16-bit
 121:				ALIGN_WORD      macro
 122:				                if $ and 1
 123:				                    byte 0
 124:				                endif
 125:				                endm
 126:				;
 127:				; 32-bit
 128:				ALIGN_LONG      macro
 129:				                ALIGN_WORD
 130:				                if $ and 2
 131:				                    byte 0, 0
 132:				                endif
 133:				                endm
 134:				
**** cpm_utility.z80 ****
  28:				                include "z80.i"
**** /home/merlin/Technical/ZARC_Z80_Box/git/software/includes//z80.i ****
   1:				; ***********************************
   2:				; * ZARC Z80 Definitions            *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 28/5/2020         *
   5:				; ***********************************
   6:				;
   7:				; Definitions related to the Z80 itself.
   8:				;
   9:				; Z80 Vectors
  10:     -	0000'         	Z80_RST00_VEC   equ 0x0000      ; RST instruction vectors
  11:     -	0008'         	Z80_RST08_VEC   equ 0x0008
  12:     -	0010'         	Z80_RST10_VEC   equ 0x0010
  13:     -	0018'         	Z80_RST18_VEC   equ 0x0018
  14:     -	0020'         	Z80_RST20_VEC   equ 0x0020
  15:     -	0028'         	Z80_RST28_VEC   equ 0x0028
  16:     -	0030'         	Z80_RST30_VEC   equ 0x0030
  17:     -	0038'         	Z80_RST38_VEC   equ 0x0038
  18:     -	0066'         	Z80_NMI_VEC     equ 0x0066      ; NMI vectors
  19:				
**** cpm_utility.z80 ****
  29:				                include "terminal.i"    ; Terminal constants
**** /home/merlin/Technical/ZARC_Z80_Box/git/software/includes//terminal.i ****
   1:				; ***********************************
   2:				; * ZARC Terminal Definitions       *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 16/5/2020         *
   5:				; ***********************************
   6:				;
   7:				; Definitions associated with terminals connected to an RS-232 port.
   8:				;
   9:     -	0005'         	ASCII_ENQ           equ 0x05        ; Enquiry
  10:     -	0008'         	ASCII_BS            equ 0x08        ; Backspace
  11:     -	0009'         	ASCII_HT            equ 0x09
  12:     -	000A'         	ASCII_LF            equ 0x0a        ; Line feed
  13:     -	000B'         	ASCII_VT            equ 0x0b        ; Upline (ADM-3A)
  14:     -	000C'         	ASCII_FF            equ 0x0c        ; Forward space (ADM-3A)
  15:     -	000D'         	ASCII_CR            equ 0x0d        ; Carriage return
  16:     -	0016'         	ASCII_SYN           equ 0x16        ; Synchronous idle
  17:     -	001A'         	ASCII_SUB           equ 0x1a        ; Clear screen (ADM-3A)
  18:     -	001B'         	ASCII_ESC           equ 0x1b        ; Escape
  19:     -	001E'         	ASCII_RS            equ 0x1e        ; Home cursor (ADM-3A)
  20:     -	007F'         	ASCII_DEL           equ 0x7f        ; Delete
  21:				;
  22:				; ZARC CP/M terminal input key codes. Some are copied from Amstrad PCW and
  23:				; Spectrum +3, others are unique to ZARC. Delete seems very common.
  24:     -	001F'         	ZKEY_CSR_UP         equ 0x1f        ; Cursor up
  25:     -	001E'         	ZKEY_CSR_DOWN       equ 0x1e        ; Cursor down
  26:     -	0006'         	ZKEY_CSR_RIGHT      equ 0x06        ; Cursor right
  27:     -	0001'         	ZKEY_CSR_LEFT       equ 0x01        ; Cursor left
  28:     -	0002'         	ZKEY_HOME           equ 0x02
  29:     -	0016'         	ZKEY_INSERT         equ 0x16
  30:     -	007F'         	ZKEY_DELETE         equ 0x7f
  31:     -	0004'         	ZKEY_END            equ 0x04
  32:     -	001D'         	ZKEY_PAGE_UP        equ 0x1d
  33:     -	001C'         	ZKEY_PAGE_DOWN      equ 0x1c
  34:				
**** cpm_utility.z80 ****
  30:				                include "cpm.i"
**** /home/merlin/Technical/ZARC_Z80_Box/git/software/includes//cpm.i ****
   1:				; *******************************************************
   2:				; * ZARC Monitor CP/M Definitions                       *
   3:				; * Written by: Merlin Skinner                          *
   4:				; * Date Started: 26/5/2020                             *
   5:				; *******************************************************
   6:				;
   7:				; Definitions related CP/M running under the monitor programme.
   8:				;
   9:				; Note that ld80 only considers the first six characters of labels significant.
  10:				;
  11:				; The following conditionals are intended to allow the same include file to be
  12:				; used in the defining module and elsewhere as required. Some includes are used
  13:				; for other applications than the monitor, such as the CP/M BIOS. In these cases,
  14:				; the extern and public statements are not desirable.
  15:				;
  16:     -	0000'         	            ifdef monitor           ; Meaningful for monitor build only
  28:				            endif
  29:				;
  30:				;
  31:				;
  32:				; ****************
  33:				; * Memory Usage *
  34:				; ****************
  35:				;
  36:				;
  37:				; Note: memory banks are allocated by the monitor's initialisation code.
  38:     -	0004'         	MMAP_CPM_PAGES      equ 4               ; Number of 16 kB pages
  39:				;
  40:				; The MS byte of INT_VEC_TABLE comes from the Z80 I register, and the LS byte
  41:				; from the FPGA. The 0xe0 offset is chosen to allow the table to reside at the
  42:				; top of memory (0xffe0 to 0xffff).
  43:     -	FFE0'         	INT_VEC_TABLE   equ 0xffe0              ; Interrupt mode 2 vector table
  44:				;
  45:				; Copied from CP/M manual appendix A.
  46:				; MSIZE             equ 64              ; CP/M version memory size in kilobytes
  47:				;
  48:				; "BIAS" is the address offset from 0x3400 for memory systems other than 16 K.
  49:				;BIAS               equ (MSIZE-20) * 1024
  50:     -	A200'         	CPM_BIAS            equ 0xa200          ; For CompuPro64K_CPM
  51:     -	D600'         	CCP_START           equ 0x3400 + CPM_BIAS   ; Base of CCP
  52:     -	DE06'         	BDOS_START          equ CCP_START + 0x0806  ; Base of BDOS
  53:     -	EC00'         	BIOS_START          equ CCP_START + 0x1600  ; Base of BIOS
  54:     -	002C'         	BIOS_CPM_START_SEC  equ 44              ; First CP/M sector of BIOS
  55:     -	1000'         	BIOS_MAX_SIZE       equ 4096            ; 2 KB allocation for BIOS stored on MMC (ZARC)
  56:     -	0100'         	TPA_START           equ 0x0100          ; Transient Programme Area
  57:				;
  58:				; Page zero.
  59:     -	0003'         	IOBYTE              equ 0x0003          ; Intel I/O byte
  60:     -	0004'         	CDISK               equ 0x0004          ; Current disk (0="A") & user no. (in high nibble)
  61:     -	005C'         	FCB1                equ 0x005c          ; Default FCB 1
  62:     -	006C'         	FCB2                equ 0x006c          ; Default FCB 2 (overwritten if FCB 1 is opened)
  63:				; Default 128-byte disk buffer, also filled with the command line when a transient
  64:				; is loaded under the CCP.
  65:     -	0080'         	DEF_BUFFER          equ 0x80
  66:     -	0080'         	DEF_BUFFER_SIZE     equ 0x80
  67:				;
  68:				; IOBYTE bit definitions.
  69:     -	0003'         	IOB_CON_MASK        equ 0x03
  70:     -	000C'         	IOB_RDR_MASK        equ 0x0c
  71:     -	0030'         	IOB_PUN_MASK        equ 0x30
  72:     -	00C0'         	IOB_LST_MASK        equ 0xc0
  73:				;
  74:				; BIOS option bits.
  75:     -	        	BITDEF BIOS_OPT_DEBUG, 0                ; Enable BIOS debugging messages
  76:     -	        	BITDEF BIOS_OPT_NOINTS, 1               ; Disables interrupts (use basic I/O mode)
  77:     -	        	BITDEF BIOS_OPT_RAWCON, 2               ; Disables ADM-3A to VT-100 translation
  78:				;
  79:				;
  80:				;
  81:				; ***************
  82:				; * Disk System *
  83:				; ***************
  84:				;
  85:				;
  86:     -	0080'         	CPM_SECTOR_SIZE     equ 128             ; CP/M disk sector size
  87:     -	0010'         	NUM_DISKS           equ 16              ; Number of disk drives
  88:     -	0010'         	NUM_DISKS_MAX       equ 16              ; Maximum number of disk drives
  89:     -	0000'         	CPM_SYS_SIZE        equ 1024 * 1024     ; System area size (bytes)
  90:     -	0000'         	CPM_DISK_SIZE       equ 1024 * 1024     ; Disk size (bytes)
  91:     -	0008'         	FILENAME_SIZE       equ 8               ; Filename size
  92:     -	0003'         	FILEEXT_SIZE        equ 3               ; File extension size
  93:     -	001A'         	FILE_EOF            equ 0x1a            ; End of file (^Z)
  94:     -	000F'         	MAX_USER            equ 15              ; Maximum user number
  95:				;
  96:     -	0001'         	BDOS_READ_SEQ_EOF   equ 1               ; Sequential read EOF error code
  97:				;
  98:				; Disk Parameter Header (DPH) structure.
  99:     -	        	                STRUCT
 100:     -	        	                STR_WORD DPH_XLT        ; Address of sector translation table
 101:     -	        	                STR_WORD DPH_SCRATCH0   ; BDOS scratch area
 102:     -	        	                STR_WORD DPH_SCRATCH1
 103:     -	        	                STR_WORD DPH_SCRATCH2
 104:     -	        	                STR_WORD DPH_DIRBF      ; BDOS directory scratch area
 105:     -	        	                STR_WORD DPH_DPB        ; Pointer to DPB
 106:     -	        	                STR_WORD DPH_CSV        ; Pointer to the directory checksum vector
 107:     -	        	                STR_WORD DPH_ALV        ; Pointer to the allocation vector
 108:     -	        	                STR_END DPH_SIZE
 109:				;
 110:				;
 111:				; Disk Parameter Block (DPB) structure.
 112:     -	        	                STRUCT
 113:     -	        	                STR_WORD DPB_SPT        ; Number of 128-byte records per track
 114:     -	        	                STR_BYTE DPB_BSH        ; Block shift. 3 => 1k, 4 => 2k, 5 => 4k....
 115:     -	        	                STR_BYTE DPB_BLM        ; Block mask. 7 => 1k, 0Fh => 2k, 1Fh => 4k...
 116:     -	        	                STR_BYTE DPB_EXM        ; Extent mask
 117:     -	        	                STR_WORD DPB_DSM        ; Maximum block number
 118:     -	        	                STR_WORD DPB_DRM        ; Maximum directory entry number
 119:     -	        	                STR_BYTE DPB_AL0        ; Directory allocation bitmap
 120:     -	        	                STR_BYTE DPB_AL1
 121:     -	        	                STR_WORD DPB_CKS        ; Checksum vector size, 0 for a fixed disc
 122:     -	        	                STR_WORD DPB_OFF        ; Offset, number of reserved tracks
 123:     -	        	                STR_END DPB_SIZE
 124:				;
 125:				;
 126:				; Directory entry structure.
 127:     -	        	                STRUCT
 128:     -	        	                STR_BYTE DIRE_USER      ; User number. 0xe5 if entry unused
 129:     -	        	                STR_BLOCK DIRE_NAME, FILENAME_SIZE  ; Filename
 130:     -	        	                STR_BLOCK DIRE_TYP, FILEEXT_SIZE    ; File type
 131:     -	        	                STR_BYTE DIRE_EX        ; Extent counter, low byte (0-31)
 132:     -	        	                STR_BYTE DIRE_S1        ; Reserved, set to 0
 133:     -	        	                STR_BYTE DIRE_S2        ; Extent counter, high byte
 134:     -	        	                STR_BYTE DIRE_RC        ; Record count (low byte)
 135:     -	        	                STR_BLOCK DIRE_ALLOC, 16 ; Associated block numbers
 136:     -	        	                STR_END DIRE_SIZE
 137:				;
 138:				;
 139:				; File Control Block (FCB) structure.
 140:     -	        	                STRUCT
 141:     -	        	                STR_BYTE FCB_DRIVE      ; Drive. 0 for default, 1-16 for A-P
 142:     -	        	                STR_BLOCK FCB_NAME, FILENAME_SIZE   ; Filename in ASCII upper-case
 143:     -	        	                STR_BLOCK FCB_TYP, FILEEXT_SIZE     ; File type
 144:     -	        	                STR_BYTE FCB_EX         ; Current extent (*)
 145:     -	        	                STR_BYTE FCB_S1         ; Reserved (*)
 146:     -	        	                STR_BYTE FCB_S2         ; Reserved (*)
 147:     -	        	                STR_BYTE FCB_RC         ; Reserved (*)
 148:     -	        	                STR_BLOCK FCB_ALLOC, 16 ; Associated block numbers
 149:     -	        	                STR_BYTE FCB_CR         ; Current record within extent
 150:     -	        	                STR_BLOCK FCB_RECORD, 3 ; Record number (low byte first)
 151:     -	        	                STR_END FCB_SIZE
 152:				;
 153:				; * - Set this to 0 when opening a file and then leave it to CP/M. You can rewind
 154:				; a file by setting EX, RC, S2 and CR to 0.
 155:				;
 156:				;
 157:				;
 158:				; **************
 159:				; * BIOS Calls *
 160:				; **************
 161:				;
 162:				;
 163:				; Calculate offsets into jump tables. Entries here must match the jump table in
 164:				; the BIOS. The base address of the BIOS must be added to these addresses. A call
 165:				; routine might look like:
 166:				;
 167:				; Call BIOS, allowing for its unknown base address.
 168:				; Call with:
 169:				; BC - operand (depends on BIOS function called)
 170:				; DE - operand (depends on BIOS function called)
 171:				; HL - offset for the routine (e.g. BIOS_CONIN)
 172:				; call_bios       push de
 173:				;                 ex de, hl
 174:				;                 ld hl, (1)              ; Find WBOOT (warm boot) address
 175:				;                 add hl, de              ; Add offset
 176:				;                 pop de
 177:				;                 jp (hl)                 ; Jump to BIOS then return to caller
 178:				;
 179:				; The above method is a bit clumsy, but then application code shouldn't normally
 180:				; call the BIOS directly.
 181:				;
 182:     -	        	    JPTBL_START 0                   ; Generate offsets as BIOS_START isn't always known
 183:				;
 184:				; From monitor.z80
 185:				; Note - cold start routine omitted to align with use of address at (1) to find BIOS.
 186:     -	        	    JPTBL_ENTRY BIOS_WBOOT          ; Warm boot - reload command processor
 187:     -	        	    JPTBL_ENTRY BIOS_CONST          ; Console status
 188:     -	        	    JPTBL_ENTRY BIOS_CONIN          ; Console input
 189:     -	        	    JPTBL_ENTRY BIOS_CONOUT         ; Console output
 190:     -	        	    JPTBL_ENTRY BIOS_PLIST          ; Printer output
 191:     -	        	    JPTBL_ENTRY BIOS_PUNCH          ; Paper tape punch output
 192:     -	        	    JPTBL_ENTRY BIOS_READER         ; Paper tape reader input
 193:     -	        	    JPTBL_ENTRY BIOS_HOME           ; Move disc head to track 0
 194:     -	        	    JPTBL_ENTRY BIOS_SELDSK         ; Select disc drive
 195:     -	        	    JPTBL_ENTRY BIOS_SETTRK         ; Set track number
 196:     -	        	    JPTBL_ENTRY BIOS_SETSEC         ; Set sector number
 197:     -	        	    JPTBL_ENTRY BIOS_SETDMA         ; Set DMA address
 198:     -	        	    JPTBL_ENTRY BIOS_READ           ; Read a sector
 199:     -	        	    JPTBL_ENTRY BIOS_WRITE          ; Write a sector
 200:				; CP/M 2 functions.
 201:     -	        	    JPTBL_ENTRY BIOS_LISTST         ; Status of list device
 202:     -	        	    JPTBL_ENTRY BIOS_SECTRAN        ; Sector translation for skewing
 203:				; CP/M 3 functions (not supported yet). From https://www.seasip.info/Cpm/bios.html
 204:     -	        	    JPTBL_ENTRY BIOS_CONOST         ; Status of console output
 205:     -	        	    JPTBL_ENTRY BIOS_AUXIST         ; Status of auxiliary input
 206:     -	        	    JPTBL_ENTRY BIOS_AUXOST         ; Status of auxiliary output
 207:     -	        	    JPTBL_ENTRY BIOS_DEVTBL         ; Address of devices table
 208:     -	        	    JPTBL_ENTRY BIOS_DEVINI         ; Initialise a device
 209:     -	        	    JPTBL_ENTRY BIOS_DRVTBL         ; Address of discs table
 210:     -	        	    JPTBL_ENTRY BIOS_MULTIO         ; Read/write multiple sectors
 211:     -	        	    JPTBL_ENTRY BIOS_FLUSH          ; Flush host buffers
 212:     -	        	    JPTBL_ENTRY BIOS_MOVE           ; Move a block of memory
 213:     -	        	    JPTBL_ENTRY BIOS_TIME           ; Real time clock
 214:     -	        	    JPTBL_ENTRY BIOS_SELMEM         ; Select memory bank
 215:     -	        	    JPTBL_ENTRY BIOS_SETBNK         ; Select bank for DMA operation
 216:     -	        	    JPTBL_ENTRY BIOS_XMOVE          ; Preload banks for MOVE
 217:     -	        	    JPTBL_ENTRY BIOS_USERF          ; System-depedent functions
 218:     -	        	    JPTBL_ENTRY BIOS_RESERV1        ; Reserved
 219:     -	        	    JPTBL_ENTRY BIOS_RESERV2        ; Reserved
 220:				; ZARC-specific items.
 221:     -	        	    JPTBL_BLOCK BIOS_ID, 3          ; BIOS ID ("ZRC")
 222:     -	        	    JPTBL_BLOCK BIOS_VER, 3         ; Version (see below)
 223:     -	        	    JPTBL_ENTRY BIOS_STARTUP        ; CP/M startup entry point
 224:     -	        	    JPTBL_ENTRY BIOS_MON_CALL       ; Call monitor function
 225:     -	        	    JPTBL_ENTRY BIOS_SUPER          ; Set supervisor state
 226:     -	        	    JPTBL_ENTRY BIOS_INT_DISABLE    ; Disable interrupts and keep count
 227:     -	        	    JPTBL_ENTRY BIOS_INT_ENABLE     ; Enable interrupts if safe
 228:     -	        	    JPTBL_ENTRY BIOS_TIRD           ; Read time and date
 229:     -	        	    JPTBL_ENTRY BIOS_SET_TIMER      ; Set timer
 230:     -	        	    JPTBL_ENTRY BIOS_GET_TIMER      ; Get timer
 231:				;
 232:     -	        	    JPTBL_END BIOS_JPTBL_NEXT
 233:				;
 234:				; BIOS_VER is <reserved (zero)>, <major version>, <minor version>. The reserved
 235:				; byte may flag capabilities at some point.
 236:				;
 237:				;
 238:				;
 239:				; **************
 240:				; * BDOS Calls *
 241:				; **************
 242:				;
 243:				;
 244:				; From http://www.gaby.de/cpm/manuals/archive/cpm22htm/ch5.htm#Section_5.2
 245:				; In general, the function number is passed in register C with the information
 246:				; address in the double byte pair DE. Single byte values are returned in register
 247:				; A, with double byte values returned in HL. A zero value is returned when the
 248:				; function number is out of range. For reasons of compatibility, register A = L
 249:				; and register B = H upon return in all cases. Example call:
 250:				;   ld c, BDOS_CONIN    ; Read next character
 251:				;   call BDOS           ; Return character in A
 252:				;
 253:     -	0005'         	BDOS        equ 5               ; BDOS entry point
 254:				;
 255:     -	0000'         	BDOS_SYS_RST        equ 0       ; System Reset
 256:     -	0001'         	BDOS_CON_IN         equ 1       ; Console Input
 257:     -	0002'         	BDOS_CON_OUT        equ 2       ; Console Output
 258:     -	0003'         	BDOS_RDR_IN         equ 3       ; Reader Input
 259:     -	0004'         	BDOS_PUN_OUT        equ 4       ; Punch Output
 260:     -	0005'         	BDOS_LST_OUT        equ 5       ; List Output
 261:     -	0006'         	BDOS_DIRECT_CON_IO  equ 6       ; Direct Console I/O
 262:     -	0007'         	BDOS_GET_IO_BYTE    equ 7       ; Get I/O Byte
 263:     -	0008'         	BDOS_SET_IO_BYTE    equ 8       ; Set I/O Byte
 264:     -	0009'         	BDOS_PRINT_STRING   equ 9       ; Print String
 265:     -	000A'         	BDOS_READ_CON_BUFF  equ 10      ; Read Console Buffer
 266:     -	000B'         	BDOS_GET_CON_STAT   equ 11      ; Get Console Status
 267:     -	000C'         	BDOS_VERSION        equ 12      ; Return Version Number
 268:     -	000D'         	BDOS_RESET_DISK_SYS equ 13      ; Reset Disk System
 269:     -	000E'         	BDOS_SEL_DISK       equ 14      ; Select Disk
 270:     -	000F'         	BDOS_OPEN_FILE      equ 15      ; Open File
 271:     -	0010'         	BDOS_CLOSE_FILE     equ 16      ; Close File
 272:     -	0011'         	BDOS_SEARCH_FIRST   equ 17      ; Search for First
 273:     -	0012'         	BDOS_SEARCH_NEXT    equ 18      ; Search for Next
 274:     -	0013'         	BDOS_DELETE_FILE    equ 19      ; Delete File
 275:     -	0014'         	BDOS_READ_SEQ       equ 20      ; Read Sequential
 276:     -	0015'         	BDOS_WRITE_SEQ      equ 21      ; Write Sequential
 277:     -	0016'         	BDOS_MAKE_FILE      equ 22      ; Make File
 278:     -	0017'         	BDOS_RENAME_FILE    equ 23      ; Rename File
 279:     -	0018'         	BDOS_GET_LOGIN_VEC  equ 24      ; Return Login Vector
 280:     -	0019'         	BDOS_GET_CURR_DISK  equ 25      ; Return Current Disk
 281:     -	001A'         	BDOS_SET_DMA_ADDR   equ 26      ; Set DMA Address
 282:     -	001B'         	BDOS_GET_ALLOC_ADDR equ 27      ; Get Addr (Alloc)
 283:     -	001C'         	BDOS_WRITE_PROT     equ 28      ; Write Protect Disk
 284:     -	001D'         	BDOS_GET_RO_VEC     equ 29      ; Get R/O Vector
 285:     -	001E'         	BDOS_SET_FILE_ATTR  equ 30      ; Set File Attributes
 286:     -	001F'         	BDOS_GET_DPB        equ 31      ; Get Addr (Disk Parms)
 287:     -	0020'         	BDOS_GET_SET_USER   equ 32      ; Set/Get User Code
 288:     -	0021'         	BDOS_READ_RANDOM    equ 33      ; Read Random
 289:     -	0022'         	BDOS_WRITE_RANDOM   equ 34      ; Write Random
 290:     -	0023'         	BDOS_GET_FILE_SIZE  equ 35      ; Compute File Size
 291:     -	0024'         	BDOS_SET_RANDOM_REC equ 36      ; Set Random Record
 292:     -	0025'         	BDOS_RESET_DRIVES   equ 37      ; Selectively reset disc drives
 293:     -	0028'         	BDOS_WRITE_RAN_ZFILL equ 40     ; Write Random with Zero Fill
 294:				
 295:				; Functions 28 and 32 should be avoided in application programs to maintain upward
 296:				; compatibility with CP/M.
 297:				;
 298:				
**** cpm_utility.z80 ****
  31:				                include "cpm_utility.i"
**** /home/merlin/Technical/ZARC_Z80_Box/git/software/includes//cpm_utility.i ****
   1:				; *******************************************************
   2:				; * Utility Routines for CP/M Applications              *
   3:				; * Version: V1.0                                       *
   4:				; * Merlin Skinner, 16/12/2021                          *
   5:				; *******************************************************
   6:				;
   7:				; Note that ld80 only considers the first six characters of labels significant.
   8:				;
   9:     -	0000'         	            ifndef CPMU         ; Inhibit for this module
  41:				            endif
  42:				;
  43:				;
  44:				; mtwdli (match word in a string against list of options) option bits. Each bit
  45:				; has the described effect if set.
  46:     -	        	BITDEF MTWDLI_ABBREV, 0                 ; Enable "." abbreviation
  47:     -	        	BITDEF MTWDLI_ICASE, 1                  ; Ignore case when matching
  48:     -	        	BITDEF MTWDLI_TERM, 7                   ; Terminator found (internal use only)
  49:				
**** cpm_utility.z80 ****
  32:				;
  33:				;
  34:				;
  35:				; *************
  36:				; * Externals *
  37:				; *************
  38:				;
  39:				;
  40:				; Variables
  41:				; None.
  42:				;
  43:				; Functions.
  44:				; CP/M specific.
  45:				                public cbdos    ; Call BDOS with some registers saved
  46:				                public cbios    ; Call BIOS with some registers saved
  47:				                public panic    ; Fatal application error
  48:				                public zrcdet   ; Detect ZARC
  49:				                public z80det   ; Detect Z80 (instead of 8080 / 8085)
  50:				;
  51:				; Derived from the monitor's utility.z80.
  52:				                public conwch   ; Write character to console
  53:				                public conrch   ; Read character from the console
  54:				                public const    ; Fetch console input status
  55:				                public cwnwln   ; Write new line characters to console
  56:				                public conwms   ; Print "$" terminated string to the console
  57:				                public conwmn   ; Print message <n> in a list
  58:				                public skpspc   ; Step hl past spaces
  59:				                public toupca   ; Convert character in A to upper case
  60:				                public toloca   ; Convert character in A to lower case
  61:				                public cwvich   ; Print only visible 7-bit characters
  62:				                public cwpspc   ; Print a space
  63:				                public mtwdli   ; Match word in a string against list of options
  64:				                public cwphnb   ; Print least-significant nibble in A in hexadecimal
  65:				                public cwphby   ; Print A in hexadecimal
  66:				                public cwphwd   ; Print HL in hexadecimal
  67:				                public cwpdwd   ; Print HL in decimal. Leading zeros are suppressed
  68:				                public cwpdby   ; Print A in decimal. Leading zeros are suppressed
  69:				                public cwpdwd   ; Print HL in decimal. Leading zeros are suppressed
  70:				                public cwpdlo   ; Print DEHL in decimal. Leading zeros are suppressed
  71:				                public rdhxwd   ; Read a 16-bit hexadecimal number from a string
  72:				                public rdduwd   ; Read a 16-bit unsigned decimal number from a string
  73:				                public rddulo   ; Read a 32-bit unsigned decimal number from a string
  74:				;
  75:				;
  76:				;
  77:				; ********
  78:				; * Code *
  79:				; ********
  80:				;
  81:				;
  82:				                cseg                    ; Code segment
  83:				;
  84:				; Call BDOS with IX and IY registers saved.
  85:    0+15	0000' DDE5    	cbdos           push ix
  86:   15+15	0002' FDE5    	                push iy
  87:   30+17	0004' CD0500  	                call BDOS
  88:   47+14	0007' FDE1    	                pop iy
  89:   61+14	0009' DDE1    	                pop ix
  90:   75+10	000B' C9      	                ret
  91:				;
  92:				;
  93:				; Call BIOS with some registers saved.
  94:				; Call with:
  95:				; BC - operand (depends on BIOS function called)
  96:				; DE - operand (depends on BIOS function called)
  97:				; HL - offset for the routine (e.g. BIOS_CONIN)
  98:   85+15	000C' DDE5    	cbios           push ix
  99:  100+15	000E' FDE5    	                push iy
 100:  115+17	0010' CD1800  	                call cbios_raw
 101:  132+14	0013' FDE1    	                pop iy
 102:  146+14	0015' DDE1    	                pop ix
 103:  160+10	0017' C9      	                ret
 104:				;
 105:				;
 106:				; Call BIOS, allowing for its unknown base address.
 107:				; Call with:
 108:				; BC - operand (depends on BIOS function called)
 109:				; DE - operand (depends on BIOS function called)
 110:				; HL - offset for the routine (e.g. BIOS_CONIN)
 111:  170+11	0018' D5      	cbios_raw       push de
 112:  181+4	0019' EB      	                ex de, hl
 113:  185+16	001A' 2A0100  	                ld hl, (1)              ; Find WBOOT (warm boot) address
 114:  201+11	001D' 19      	                add hl, de              ; Add offset
 115:  212+10	001E' D1      	                pop de
 116:  222+4	001F' E9      	                jp (hl)                 ; Jump to BIOS then return to caller
 117:				;
 118:				;
 119:				; Unrecoverable application error! Halt the application to prevent further
 120:				; damage. Call this routine in case of a serious error.
 121:				; Note: call is preferred (rather than jump) as it preserves the PC.
 122:  226+10	0020' 215A03  	panic           ld hl, panic_1_msg      ; "*** Software panic at PC="
 123:  236+17	0023' CDA300  	                call conwms             ; Print $-terminated string to console
 124:  253+10	0026' E1      	                pop hl                  ; Fetch PC
 125:  263+17	0027' CD0A01  	                call cwphwd             ; Print HL in hexadecimal
 126:  280+10	002A' 217603  	                ld hl, panic_2_msg      ; " ***"
 127:  290+17	002D' CDA300  	                call conwms             ; Print $-terminated string to console
 128:  307+10	0030' C30000  	                jp 0                    ; Warm boot
 129:				;
 130:				;
 131:				; Determine whether or not we are running on a ZARC system. Returns with carry
 132:				; set if ZARC BIOS not found.
 133:  317+11	0033' D5      	zrcdet          push de
 134:  328+11	0034' E5      	                push hl
 135:  339+10	0035' 116000  	                ld de, BIOS_ID          ; ID offset into BIOS jump table
 136:  349+16	0038' 2A0100  	                ld hl, (1)              ; Find WBOOT (warm boot) address
 137:  365+11	003B' 19      	                add hl, de              ; Add offset
 138:  376+7	003C' 7E      	                ld a, (hl)
 139:  383+7	003D' FE5A    	                cp "Z"
 140:  390+10	003F' C25400  	                jp nz, zd_not_zarc
 141:  400+6	0042' 23      	                inc hl
 142:  406+7	0043' 7E      	                ld a, (hl)
 143:  413+7	0044' FE52    	                cp "R"
 144:  420+10	0046' C25400  	                jp nz, zd_not_zarc
 145:  430+6	0049' 23      	                inc hl
 146:  436+7	004A' 7E      	                ld a, (hl)
 147:  443+7	004B' FE43    	                cp "C"
 148:  450+10	004D' C25400  	                jp nz, zd_not_zarc
 149:  460+4	0050' A7      	                and a               ; Flag success
 150:				;
 151:  464+10	0051' E1      	zd_exit         pop hl
 152:  474+10	0052' D1      	                pop de
 153:  484+10	0053' C9      	                ret
 154:				;
 155:				; ZARC BIOS not found.
 156:  494+4	0054' 37      	zd_not_zarc     scf
 157:  498+12	0055' 18FA    	                jr zd_exit
 158:				;
 159:				;
 160:				; Determine whether we are running on a Z80 system. Returns with carry set if
 161:				; the processor appears to be something else (8080 or 8085). Take care when
 162:				; modifying this code, as it has to support all CPU types.
 163:  510+11	0057' C5      	z80det          push bc
 164:				;
 165:  521+4	0058' AF      	                xor a
 166:  525+4	0059' A7      	                and a
 167:				; From https://ee.sharif.edu/~sakhtar3/articles/8080-8085/8085%20Instruction%20Set.pdf
 168:				; ANA r ... The CY flag is cleared and the AC is set (8085). The CY is cleared
 169:				; and the AC is set to the OR'ing of bits 3 of the operands (8080).
 170:				; The Z80 calls AC "half-carry" (H) and behaves like an 8085 in this regard.
 171:  529+11	005A' F5      	                push af
 172:  540+10	005B' C1      	                pop bc
 173:  550+4	005C' 79      	                ld a, c                 ; Flags
 174:  554+7	005D' E610    	                and 0x10                ; Isolate AC / half-carry
 175:  561+10	005F' CA6D00  	                jp z, z8d_not_z80       ; Jump if 8080
 176:				; 8085 or Z80. Using the method described at:
 177:				; https://heavydeck.net/post/i8085-rl35902-z80-run-time-detection/
 178:				; ... exploit the difference on byte 0x20 which on the i8085 translates to RIM
 179:				; (Read Interrupt Mask) opcode and on the z80 ... is a two-byte relative jump
 180:				; JR NZ n.
 181:  571+4	0062' AF      	                xor a
 182:  575+4	0063' 3C      	                inc a                   ; Reset Z flag
 183:				; The following (0x20, 0x04) is interpreted as RIM, INR B on an 8085.
 184:  579+7+5	0064' 2004    	                jr nz, z8d_z80
 185:  586+4	0066' 00      	                nop                     ; 1
 186:				; This must be an 8085.
 187:  590+10	0067' C36D00  	                jp z8d_not_z80          ; 3
 188:				;
 189:				; There must be four bytes between the jr nz / RIM instruction and this point
 190:				; for this to work.
 191:  600+4	006A' A7      	z8d_z80         and a                   ; Flag success
 192:  604+10	006B' C1      	z8d_exit        pop bc
 193:  614+10	006C' C9      	                ret
 194:				;
 195:				; Z80 not found.
 196:  624+4	006D' 37      	z8d_not_z80     scf
 197:  628+10	006E' C36B00  	                jp z8d_exit             ; No "jr" on 8080 / 8085!
 198:				;
 199:				;
 200:				; Write character to console. This "looks like" the monitor's routine of the
 201:				; same name, thereby easing the use of monitor routines copied here. 
 202:				; Call with:
 203:				; A - character to write.
 204:  638+11	0071' C5      	conwch          push bc
 205:  649+11	0072' D5      	                push de
 206:  660+11	0073' E5      	                push hl
 207:				;
 208:				; BDOS version.
 209:				;                ld e, a
 210:				;                ld c, BDOS_CON_OUT      ; Console output
 211:				;                call cbdos
 212:				;
 213:				; BIOS version.
 214:  671+4	0074' 4F      	                ld c, a
 215:  675+10	0075' 210900  	                ld hl, BIOS_CONOUT      ; Console output
 216:  685+17	0078' CD0C00  	                call cbios              ; Call BIOS
 217:				;
 218:  702+10	007B' E1      	                pop hl
 219:  712+10	007C' D1      	                pop de
 220:  722+10	007D' C1      	                pop bc
 221:  732+10	007E' C9      	                ret
 222:				;
 223:				;
 224:				; Read character from the console. This "looks like" the monitor's routine of
 225:				; the same name, thereby easing the use of monitor routines copied here. BIOS
 226:				; routines are used for console I/O as this avoids unwanted echoing of input.
 227:				; This means that the BDOS tab expansion and XON / XOFF features are not
 228:				; available.
 229:				; Returns with:
 230:				; A - character.
 231:  742+11	007F' C5      	conrch          push bc
 232:  753+11	0080' D5      	                push de
 233:  764+11	0081' E5      	                push hl
 234:				;
 235:				; BDOS version.
 236:				;                ld c, BDOS_CON_IN       ; Console input
 237:				;                call cbdos
 238:				;
 239:				; BIOS version.
 240:  775+10	0082' 210600  	                ld hl, BIOS_CONIN       ; Console input
 241:  785+17	0085' CD0C00  	                call cbios              ; Call BIOS
 242:				;
 243:  802+10	0088' E1      	                pop hl
 244:  812+10	0089' D1      	                pop de
 245:  822+10	008A' C1      	                pop bc
 246:  832+10	008B' C9      	                ret
 247:				;
 248:				;
 249:				; Write new line characters to console.
 250:  842+7	008C' 3E0D    	cwnwln          ld a, ascii_cr
 251:  849+17	008E' CD7100  	                call conwch
 252:  866+7	0091' 3E0A    	                ld a, ascii_lf
 253:  873+10	0093' C37100  	                jp conwch
 254:				;
 255:				;
 256:				; Fetch the console input status. Returns with:
 257:				; A - zero if no character is ready, 0xff if one is.
 258:  883+11	0096' C5      	const           push bc
 259:  894+11	0097' D5      	                push de
 260:  905+11	0098' E5      	                push hl
 261:				;
 262:				; BDOS version.
 263:				;                ld c, BDOS_GET_CON_STAT     ; Console status
 264:				;                call cbdos
 265:				;
 266:  916+10	0099' 210300  	                ld hl, BIOS_CONST       ; Console status
 267:  926+17	009C' CD0C00  	                call cbios
 268:				;
 269:  943+10	009F' E1      	                pop hl
 270:  953+10	00A0' D1      	                pop de
 271:  963+10	00A1' C1      	                pop bc
 272:  973+10	00A2' C9      	                ret
 273:				;
 274:				;
 275:				; Print "$" terminated string to the console. Note, this is different to the
 276:				; monitor version in that it uses the "$" CP/M terminator instead of a null. It
 277:				; also does not return with the address of the terminator in HL.
 278:				; Call with:
 279:				; HL - pointer to start of message
 280:  983+11	00A3' C5      	conwms          push bc
 281:  994+11	00A4' D5      	                push de
 282:				;
 283:				; BDOS version.
 284:				;                ex de, hl
 285:				;                ld c, BDOS_PRINT_STRING ; Print String
 286:				;                call cbdos
 287:				;
 288: 1005+7	00A5' 7E      	cwms_loop       ld a, (hl)
 289: 1012+7	00A6' FE24    	                cp "$"
 290: 1019+7+5	00A8' 2806    	                jr z, cwms_exit
 291: 1026+17	00AA' CD7100  	                call conwch             ; Write character to console
 292: 1043+6	00AD' 23      	                inc hl
 293: 1049+12	00AE' 18F5    	                jr cwms_loop
 294:				;
 295: 1061+10	00B0' D1      	cwms_exit       pop de
 296: 1071+10	00B1' C1      	                pop bc
 297: 1081+10	00B2' C9      	                ret
 298:				;
 299:				;
 300:				; Step HL past any spaces.
 301:				; Returns with:
 302:				; HL - points to the first non-space character
 303: 1091+7	00B3' 3E20    	skpspc          ld a, ' '
 304: 1098+7	00B5' BE      	sks_loop        cp (hl)
 305: 1105+5+6	00B6' C0      	                ret nz                  ; Return if non-space found
 306: 1110+6	00B7' 23      	                inc hl
 307: 1116+12	00B8' 18FB    	                jr sks_loop
 308:				;
 309:				;
 310:				; Convert character in A to upper case.
 311: 1128+7	00BA' FE61    	toupca          cp 'a'
 312: 1135+5+6	00BC' D8      	                ret c                   ; Nothing to do if < 'a'
 313: 1140+7	00BD' FE7B    	                cp 'z' + 1
 314: 1147+5+6	00BF' D0      	                ret nc                  ; Nothing to do if > 'z'
 315: 1152+7	00C0' D620    	                sub 'a' - 'A'
 316: 1159+10	00C2' C9      	                ret
 317:				;
 318:				;
 319:				; Convert character in A to lower case.
 320: 1169+7	00C3' FE41    	toloca          cp 'A'
 321: 1176+5+6	00C5' D8      	                ret c                   ; Nothing to do if < 'A'
 322: 1181+7	00C6' FE5B    	                cp 'Z' + 1
 323: 1188+5+6	00C8' D0      	                ret nc                  ; Nothing to do if > 'Z'
 324: 1193+7	00C9' C620    	                add 'a' - 'A'
 325: 1200+10	00CB' C9      	                ret
 326:				;
 327:				;
 328:				; Print a space.
 329: 1210+7	00CC' 3E20    	cwpspc          ld a, ' '
 330: 1217+10	00CE' C37100  	                jp conwch
 331:				;
 332:				;
 333:				; Print only visible 7-bit characters. Non-visible ones are substituted by the
 334:				; character in C. If C is 0xff, non-visible characters are displayed in
 335:				; hexadecimal. Call with:
 336:				; A - character to display
 337:				; C - substution character. If C is zero, non-visible characters are displayed
 338:				; in hexadecimal.
 339:				; Note that the hexadecimal feature is not included in the monitor version of
 340:				; this function. 
 341: 1227+11	00D1' C5      	cwvich          push bc
 342: 1238+4	00D2' 47      	                ld b, a                 ; Save character
 343: 1242+7	00D3' FE20    	                cp ' '
 344: 1249+7+5	00D5' 3809    	                jr c, prv_do_subs       ; < ' ' is a control character
 345: 1256+7	00D7' FE7F    	                cp ascii_del
 346: 1263+7+5	00D9' 3005    	                jr nc, prv_do_subs      ; >= DEL isn't visible either
 347:				; Character is printable.
 348: 1270+17	00DB' CD7100  	prv_dis_exit    call conwch             ; Print visible character
 349: 1287+10	00DE' C1      	prv_exit        pop bc
 350: 1297+10	00DF' C9      	                ret
 351:				;
 352:				; Use substitution character
 353: 1307+4	00E0' 79      	prv_do_subs     ld a, c
 354: 1311+4	00E1' A7      	                and a
 355: 1315+7+5	00E2' 20F7    	                jr nz, prv_dis_exit
 356:				;
 357:				; Display in hexadecimal.
 358: 1322+7	00E4' 3E7B    	                ld a, "{"
 359: 1329+17	00E6' CD7100  	                call conwch             ; Write character to console
 360: 1346+4	00E9' 78      	                ld a, b
 361: 1350+17	00EA' CDFE00  	                call cwphby             ; Print A in hexadecimal
 362: 1367+7	00ED' 3E7D    	                ld a, "}"
 363: 1374+12	00EF' 18EA    	                jr prv_dis_exit         ; Print and exit
 364:				;
 365:				;
 366:				; Print least-significant nibble in A in hexadecimal.
 367: 1386+7	00F1' E60F    	cwphnb          and 0x0f
 368: 1393+7	00F3' C630    	                add '0'
 369: 1400+7	00F5' FE3A    	                cp '9' + 1
 370: 1407+7+5	00F7' 3802    	                jr c, pn_numeric        ; Jump if <= '9'
 371: 1414+7	00F9' C607    	                add ('A' - '9') - 1     ; Convert to alpha
 372: 1421+10	00FB' C37100  	pn_numeric      jp conwch
 373:				;
 374:				;
 375:				; Print A in hexadecimal.
 376: 1431+11	00FE' F5      	cwphby          push af
 377: 1442+4	00FF' 0F      	                rrca
 378: 1446+4	0100' 0F      	                rrca
 379: 1450+4	0101' 0F      	                rrca
 380: 1454+4	0102' 0F      	                rrca
 381: 1458+17	0103' CDF100  	                call cwphnb             ; Print MSN
 382: 1475+10	0106' F1      	                pop af
 383: 1485+10	0107' C3F100  	                jp cwphnb               ; Print LSN
 384:				;
 385:				;
 386:				; Print HL in hexadecimal. Leading zeros are suppressed.
 387: 1495+4	010A' 7C      	cwphwd          ld a,h
 388: 1499+17	010B' CDFE00  	                call cwphby             ; Print MSB
 389: 1516+4	010E' 7D      	                ld a,l
 390: 1520+10	010F' C3FE00  	                jp cwphby               ; Print LSB
 391:				;
 392:				;
 393:				; Print A as a decimal unsigned number. Leading zeros are suppressed.
 394: 1530+11	0112' C5      	cwpdby          push bc
 395: 1541+11	0113' D5      	                push de
 396: 1552+11	0114' E5      	                push hl
 397: 1563+7	0115' 1E00    	                ld e, 0                 ; Leading zeros flag
 398: 1570+7	0117' 2600    	                ld h, 0                 ; Move A to HL
 399: 1577+4	0119' 6F      	                ld l, a
 400: 1581+12	011A' 1811    	                jr pdw_byte             ; Use word code, skipping MS digits
 401:				;
 402:				;
 403:				; Print HL as a decimal unsigned number. Leading zeros are suppressed.
 404:				; Derived from code at http://map.grauw.nl/sources/external/z80bits.html
 405:				; HL is saved because this allows common exit code with cwpdby.
 406: 1593+11	011C' C5      	cwpdwd          push bc
 407: 1604+11	011D' D5      	                push de
 408: 1615+11	011E' E5      	                push hl
 409: 1626+7	011F' 1E00    	                ld e, 0                 ; Leading zeros flag
 410:				; Entry point from cwpdlo (32-bit version).
 411: 1633+10	0121' 01F0D8  	                ld bc, -10000           ; 10^4
 412: 1643+17	0124' CD4201  	                call pdw_digit
 413: 1660+10	0127' 0118FC  	pdl_entry       ld bc, -1000            ; 10^3
 414: 1670+17	012A' CD4201  	                call pdw_digit
 415:				; cwpdby enters here to display a single byte.
 416: 1687+10	012D' 019CFF  	pdw_byte        ld bc, -100             ; 10^2
 417: 1697+17	0130' CD4201  	                call pdw_digit
 418: 1714+7	0133' 0EF6    	                ld c, -10               ; 10^1
 419: 1721+17	0135' CD4201  	                call pdw_digit
 420: 1738+7	0138' 1EFF    	                ld e, 0xff              ; Always print the units digit
 421: 1745+4	013A' 48      	                ld c, b
 422: 1749+17	013B' CD4201  	                call pdw_digit
 423: 1766+10	013E' E1      	                pop hl
 424: 1776+10	013F' D1      	                pop de
 425: 1786+10	0140' C1      	                pop bc
 426: 1796+10	0141' C9      	                ret
 427:				;
 428: 1806+7	0142' 3E2F    	pdw_digit       ld a, '0' - 1
 429: 1813+4	0144' 3C      	pdw_digloop     inc a
 430: 1817+11	0145' 09      	                add hl, bc
 431: 1828+7+5	0146' 38FC    	                jr c, pdw_digloop
 432: 1835+15	0148' ED42    	                sbc hl, bc
 433:				; A - ASCII digit
 434: 1850+7	014A' FE30    	                cp '0'
 435: 1857+7+5	014C' 2005    	                jr nz, pdw_prdig        ; Non-zero digit, so print it
 436: 1864+4	014E' 1C      	                inc e
 437: 1868+7+5	014F' 2802    	                jr z, pdw_prdig         ; Print anyway if e was 0xff
 438: 1875+4	0151' 1D      	                dec e                   ; Restore flag
 439: 1879+10	0152' C9      	                ret
 440: 1889+7	0153' 1EFF    	pdw_prdig       ld e, 0xff              ; Flag non-zero found
 441: 1896+17	0155' CD7100  	                call conwch             ; Write character to console
 442: 1913+10	0158' C9      	                ret
 443:				;
 444:				;
 445:				; Print DEHL as a decimal unsigned number. Leading zeros are suppressed.
 446: 1923+11	0159' C5      	cwpdlo          push bc
 447: 1934+4	015A' 44      	                ld b, h
 448: 1938+4	015B' 4D      	                ld c, l
 449:				; DEBC - value to display. Store this.
 450: 1942+10	015C' 210400  	                ld hl, pdl_reg
 451: 1952+7	015F' 71      	                ld (hl), c
 452: 1959+6	0160' 23      	                inc hl
 453: 1965+7	0161' 70      	                ld (hl), b
 454: 1972+6	0162' 23      	                inc hl
 455: 1978+7	0163' 73      	                ld (hl), e
 456: 1985+6	0164' 23      	                inc hl
 457: 1991+7	0165' 72      	                ld (hl), d
 458:				; Reset leading zeros flag
 459: 1998+7	0166' 3E00    	                ld a, 0
 460: 2005+13	0168' 320800  	                ld (pdl_lz_flag), a
 461:				; Digits
 462: 2018+10	016B' 1100CA  	                ld de, 0xca00           ; 10^9
 463: 2028+10	016E' 019A3B  	                ld bc, 0x3b9a
 464: 2038+17	0171' CDB101  	                call pdl_digit
 465: 2055+10	0174' 1100E1  	                ld de, 0xe100           ; 10^8
 466: 2065+10	0177' 01F505  	                ld bc, 0x05f5
 467: 2075+17	017A' CDB101  	                call pdl_digit
 468: 2092+10	017D' 118096  	                ld de, 0x9680           ; 10^7
 469: 2102+10	0180' 019800  	                ld bc, 0x0098
 470: 2112+17	0183' CDB101  	                call pdl_digit
 471: 2129+10	0186' 114042  	                ld de, 0x4240           ; 10^6
 472: 2139+10	0189' 010F00  	                ld bc, 0x000f
 473: 2149+17	018C' CDB101  	                call pdl_digit
 474: 2166+10	018F' 11A086  	                ld de, 0x86a0           ; 10^5
 475: 2176+10	0192' 010100  	                ld bc, 0x0001
 476: 2186+17	0195' CDB101  	                call pdl_digit
 477: 2203+10	0198' 111027  	                ld de, 0x2710           ; 10^4
 478: 2213+10	019B' 010000  	                ld bc, 0x0000
 479: 2223+17	019E' CDB101  	                call pdl_digit
 480:				; Use 16-bit version to print the remainder of the digits.
 481: 2240+11	01A1' D5      	                push de
 482: 2251+11	01A2' E5      	                push hl
 483:				; Fetch value.
 484: 2262+10	01A3' 210400  	                ld hl, pdl_reg
 485: 2272+7	01A6' 5E      	                ld e, (hl)
 486: 2279+6	01A7' 23      	                inc hl
 487: 2285+7	01A8' 56      	                ld d, (hl)
 488: 2292+4	01A9' EB      	                ex de, hl
 489: 2296+13	01AA' 3A0800  	                ld a, (pdl_lz_flag)
 490: 2309+4	01AD' 5F      	                ld e, a                 ; Set leading zeros flag
 491:				; E - leading zeros flag
 492:				; HL - value to print
 493: 2313+10	01AE' C32701  	                jp pdl_entry
 494:				;
 495:				; BCDE - significance of digit.
 496: 2323+10	01B1' 210900  	pdl_digit       ld hl, pdl_ascii
 497: 2333+10	01B4' 362F    	                ld (hl), '0' - 1
 498: 2343+11	01B6' 34      	pdl_digloop     inc (hl)                ; Update ASCII digit
 499:				; Trial subtraction.
 500: 2354+11	01B7' E5      	                push hl                 ; Save pointer to pdl_ascii
 501: 2365+10	01B8' 210400  	                ld hl, pdl_reg
 502: 2375+7	01BB' 7E      	                ld a, (hl)
 503: 2382+4	01BC' 93      	                sub e
 504: 2386+7	01BD' 77      	                ld (hl), a
 505: 2393+6	01BE' 23      	                inc hl
 506: 2399+7	01BF' 7E      	                ld a, (hl)
 507: 2406+4	01C0' 9A      	                sbc d
 508: 2410+7	01C1' 77      	                ld (hl), a
 509: 2417+6	01C2' 23      	                inc hl
 510: 2423+7	01C3' 7E      	                ld a, (hl)
 511: 2430+4	01C4' 99      	                sbc c
 512: 2434+7	01C5' 77      	                ld (hl), a
 513: 2441+6	01C6' 23      	                inc hl
 514: 2447+7	01C7' 7E      	                ld a, (hl)
 515: 2454+4	01C8' 98      	                sbc b
 516: 2458+7	01C9' 77      	                ld (hl), a
 517: 2465+10	01CA' E1      	                pop hl                  ; Restore pointer to pdl_ascii
 518: 2475+7+5	01CB' 30E9    	                jr nc, pdl_digloop      ; Keep subtracting until carry
 519:				; Reverse the last subtraction to restore the value before carry.
 520: 2482+10	01CD' 210400  	                ld hl, pdl_reg
 521: 2492+7	01D0' 7E      	                ld a, (hl)
 522: 2499+4	01D1' 83      	                add e
 523: 2503+7	01D2' 77      	                ld (hl), a
 524: 2510+6	01D3' 23      	                inc hl
 525: 2516+7	01D4' 7E      	                ld a, (hl)
 526: 2523+4	01D5' 8A      	                adc d
 527: 2527+7	01D6' 77      	                ld (hl), a
 528: 2534+6	01D7' 23      	                inc hl
 529: 2540+7	01D8' 7E      	                ld a, (hl)
 530: 2547+4	01D9' 89      	                adc c
 531: 2551+7	01DA' 77      	                ld (hl), a
 532: 2558+6	01DB' 23      	                inc hl
 533: 2564+7	01DC' 7E      	                ld a, (hl)
 534: 2571+4	01DD' 88      	                adc b
 535: 2575+7	01DE' 77      	                ld (hl), a
 536:				;
 537: 2582+10	01DF' 210800  	                ld hl, pdl_lz_flag      ; Point to leading zeros flag
 538: 2592+13	01E2' 3A0900  	                ld a, (pdl_ascii)       ; Fetch ASCII digit
 539: 2605+4	01E5' 4F      	                ld c, a
 540: 2609+7	01E6' FE30    	                cp '0'
 541: 2616+7+5	01E8' 2005    	                jr nz, pdl_prdig        ; Non-zero digit, so print it
 542: 2623+7	01EA' 7E      	                ld a, (hl)
 543: 2630+4	01EB' A7      	                and a
 544: 2634+7+5	01EC' 2001    	                jr nz, pdl_prdig        ; Print anyway if flag was set
 545:				; Skip leading zeros.
 546: 2641+10	01EE' C9      	                ret
 547:				;
 548: 2651+10	01EF' 36FF    	pdl_prdig       ld (hl), 0xff           ; Flag non-zero found
 549: 2661+4	01F1' 79      	                ld a, c
 550: 2665+17	01F2' CD7100  	                call conwch
 551: 2682+10	01F5' C9      	                ret
 552:				;
 553:				;
 554:				; Print message <n> in a null terminated list. Nothing is printed if the
 555:				; terminator is encountered before message <n> is found.
 556:				; Call with:
 557:				; A - number of message to print (first is zero)
 558:				; C - message separator
 559:				; HL - pointer to start of message
 560:				; Returns with:
 561:				; HL - points to the separator at the end of the message printed, or the
 562:				; terminator (zero).
 563:				; Carry flag is set if the message was not found (terminator encountered).
 564: 2692+11	01F6' C5      	conwmn          push bc
 565: 2703+4	01F7' 47      	                ld b, a                 ; Message number
 566: 2707+4	01F8' 78      	pmn_msg_lp      ld a, b
 567: 2711+4	01F9' A7      	                and a
 568: 2715+7+5	01FA' 280B    	                jr z, pmn_found         ; Jump if this is the one
 569:				; Skip to next message.
 570: 2722+7	01FC' 7E      	pmn_sk_lp       ld a, (hl)
 571: 2729+4	01FD' A7      	                and a
 572: 2733+7+5	01FE' 2817    	                jr z, pmn_error         ; Error if terminator
 573: 2740+6	0200' 23      	                inc hl
 574: 2746+4	0201' B9      	                cp c
 575: 2750+7+5	0202' 20F8    	                jr nz, pmn_sk_lp        ; Keep going if not separator or terminator
 576:				; Separator found
 577: 2757+4	0204' 05      	                dec b
 578: 2761+12	0205' 18F1    	                jr pmn_msg_lp
 579:				; HL now points to the requied message. Print it until the separator or
 580:				; terminator is encountered.
 581: 2773+7	0207' 7E      	pmn_found       ld a, (hl)
 582: 2780+4	0208' A7      	                and a
 583: 2784+7+5	0209' 2809    	                jr z, pmn_done          ; Exit if terminator found
 584: 2791+4	020B' B9      	                cp c
 585: 2795+7+5	020C' 2806    	                jr z, pmn_done          ; Exit if separator found
 586: 2802+17	020E' CD7100  	                call conwch             ; Write character to console
 587: 2819+6	0211' 23      	                inc hl                  ; Increment character pointer
 588: 2825+12	0212' 18F3    	                jr pmn_found            ; Transmit next character
 589:				; Successful completion.
 590: 2837+10	0214' C1      	pmn_done        pop bc
 591: 2847+4	0215' A7      	                and a
 592: 2851+10	0216' C9      	                ret                     ; Return with carry reset (no error)
 593:				; Terminator encountered before the message was found
 594: 2861+10	0217' C1      	pmn_error       pop bc                  ; Restore registers
 595: 2871+4	0218' 37      	                scf
 596: 2875+10	0219' C9      	                ret                     ; Return with carry set (error)
 597:				;
 598:				;
 599:				; Match word in a string against list of options. This is intended for matching
 600:				; a command string against a list of available commands, but it may have other
 601:				; uses. Strings to match may optionally be abbreviated by a ".", in which case
 602:				; the first option that matches up to this is returned. This is similar to the
 603:				; BBC Microcomputer method of abbreviating commands.
 604:				; Call with:
 605:				; A - Options (MTWDLI_xxx, e.g. MTWDLI_ABBREV). See cpm_utility.i
 606:				; HL - points to start of string. Matching stops at a space or end of string.
 607:				; DE - points to null terminated command list. Options are separated by spaces.
 608:				; Returns with:
 609:				; A - index number of word in list that matched, or zero if no match.
 610:				; HL - points to space or terminator in string.
 611: 2885+11	021A' C5      	mtwdli          push bc                 ; Preserve BC
 612: 2896+11	021B' E5      	                push hl                 ; Save start of word in string
 613: 2907+4	021C' 4F      	                ld c, a                 ; Save options
 614: 2911+7	021D' 0601    	                ld b, 1                 ; Word count
 615: 2918+8	021F' CBB9    	mw_char_loop    res MTWDLI_TERM_BIT, c  ; Flag no terminator found (yet)
 616:				; End of word or end of string?
 617:				; C - bit 0 is abbreviation enable, bit 1 is terminator found.
 618: 2926+7	0221' 7E      	                ld a, (hl)              ; Fetch character from string
 619: 2933+7	0222' FE20    	                cp ' '
 620: 2940+7+5	0224' 280D    	                jr z, mw_sword_end
 621: 2947+4	0226' A7      	                and a
 622: 2951+7+5	0227' 280A    	                jr z, mw_sword_end
 623:				; Check for abbreviation character if enabled.
 624: 2958+8	0229' CB41    	                bit MTWDLI_ABBREV_BIT, c    ; Abbreviations enabled?
 625: 2966+7+5	022B' 2808    	                jr z, mw_str_tm_dn
 626: 2973+7	022D' FE2E    	                cp '.'
 627: 2980+7+5	022F' 2840    	                jr z, mw_dot            ; Stop matching if "." found.
 628: 2987+12	0231' 1802    	                jr mw_str_tm_dn
 629:				; Flag end of word or end of string found
 630: 2999+8	0233' CBF9    	mw_sword_end    set MTWDLI_TERM_BIT, c  ; Flag this for later
 631:				; Repeat test for word list.
 632: 3007+7	0235' 1A      	mw_str_tm_dn    ld a, (de)              ; Fetch character from list
 633: 3014+7	0236' FE20    	                cp ' '
 634: 3021+7+5	0238' 2827    	                jr z, mw_end_lwd        ; End of word in list
 635: 3028+4	023A' A7      	                and a
 636: 3032+7+5	023B' 2824    	                jr z, mw_end_lwd        ; End of word in list
 637: 3039+8	023D' CB49    	                bit MTWDLI_ICASE_BIT, c ; Force lower case?
 638: 3047+10+7	023F' C4C300  	                call nz, toloca         ; Optionally convert to lower case
 639:				; There is at least one more character to match in the string and the current word
 640:				; in the list.
 641: 3057+11	0242' C5      	                push bc                 ; Save counter
 642: 3068+4	0243' 47      	                ld b, a
 643: 3072+7	0244' 7E      	                ld a, (hl)
 644: 3079+8	0245' CB49    	                bit MTWDLI_ICASE_BIT, c ; Force lower case?
 645: 3087+10+7	0247' C4C300  	                call nz, toloca         ; Optionally convert to lower case
 646: 3097+4	024A' B8      	                cp b
 647: 3101+10	024B' C1      	                pop bc
 648: 3111+7+5	024C' 2004    	                jr nz, mw_char_mis
 649:				; Characters matched!
 650: 3118+6	024E' 23      	                inc hl
 651: 3124+6	024F' 13      	                inc de
 652: 3130+12	0250' 18CD    	                jr mw_char_loop
 653:				; Mismatch. Try the next word in the list, if there is one.
 654: 3142+10	0252' E1      	mw_char_mis     pop hl                  ; Reset string pointer
 655: 3152+11	0253' E5      	                push hl
 656: 3163+4	0254' 04      	                inc b                   ; Keep track of word count
 657:				; Skip forward until the next item in the list, or the end of the list
 658: 3167+6	0255' 13      	mw_next_lwd     inc de
 659: 3173+7	0256' 1A      	                ld a, (de)
 660: 3180+4	0257' A7      	                and a
 661: 3184+7+5	0258' 280E    	                jr z, mw_no_match       ; Exit if end of word list encountered
 662: 3191+7	025A' FE20    	                cp ' '
 663: 3198+7+5	025C' 20F7    	                jr nz, mw_next_lwd
 664: 3205+6	025E' 13      	                inc de                  ; Point to first character of next word
 665: 3211+12	025F' 18BE    	                jr mw_char_loop         ; Try this one
 666:				;
 667:				; End of word found in list.
 668: 3223+8	0261' CB79    	mw_end_lwd      bit MTWDLI_TERM_BIT, c  ; Terminator found?
 669: 3231+7+5	0263' 2007    	                jr nz, mw_end_both
 670:				; End of word found in list, but not in the string.
 671: 3238+6	0265' 1B      	                dec de                  ; Allow for increment later
 672: 3244+12	0266' 18EA    	                jr mw_char_mis          ; Try next word in list
 673:				;
 674:				; End of the word list reached and no match.
 675: 3256+10	0268' E1      	mw_no_match     pop hl                  ; Fix stack
 676: 3266+4	0269' AF      	                xor a                   ; Flag no match
 677: 3270+10	026A' C1      	                pop bc                  ; Restore BC
 678: 3280+10	026B' C9      	                ret
 679:				;
 680:				; End of words in string and list found simultanously. We have a match!                
 681: 3290+6	026C' 33      	mw_end_both     inc sp                  ; Fix stack
 682: 3296+6	026D' 33      	                inc sp
 683: 3302+4	026E' 78      	                ld a, b                 ; Fetch word index number
 684: 3306+10	026F' C1      	                pop bc                  ; Restore BC
 685: 3316+10	0270' C9      	                ret
 686:				;
 687:				; "." found in string, so accept the current word as the match. We need to skip the
 688:				; remainder of the string.
 689: 3326+6	0271' 23      	mw_dot          inc hl                  ; Step past dot
 690: 3332+12	0272' 18F8    	                jr mw_end_both
 691:				;
 692:				;
 693:				; Read a 16-bit hexadecimal number from a string. Case is ignored for alphabetic
 694:				; characters.
 695:				; Call with:
 696:				; HL - points to the first character of the number.
 697:				; Returns with:
 698:				; HL - points to first character after number.
 699:				; DE - required number
 700:				; C flag - set on error (too many or zero valid digits)
 701: 3344+11	0274' C5      	rdhxwd          push bc
 702: 3355+10	0275' 110000  	                ld de, 0                ; Initial result
 703: 3365+7	0278' 0E00    	                ld c, 0                 ; Count characters read
 704: 3372+7	027A' 7E      	ghn_char_lp     ld a, (hl)
 705: 3379+17	027B' CDBA00  	                call toupca             ; Convert to upper case.
 706: 3396+7	027E' FE41    	                cp 'A'
 707: 3403+7+5	0280' 3808    	                jr c, ghn_not_alpha
 708: 3410+7	0282' FE47    	                cp 'F' + 1
 709: 3417+7+5	0284' 3004    	                jr nc, ghn_not_alpha
 710:				; Character is alphabetic.
 711: 3424+7	0286' D637    	                sub 'A' - 10
 712: 3431+12	0288' 1808    	                jr ghn_got_dig
 713:				; Character is not alphabetic.
 714: 3443+7	028A' D630    	ghn_not_alpha   sub '0'
 715: 3450+7+5	028C' 381E    	                jr c, ghn_done          ; End of number if < '0'
 716: 3457+7	028E' FE0A    	                cp 10
 717: 3464+7+5	0290' 301A    	                jr nc, ghn_done         ; End of number if not a digit
 718:				; Value of digit is in LSN of A. Make space for it in the result.
 719: 3471+4	0292' EB      	ghn_got_dig     ex de, hl
 720: 3475+11	0293' 29      	                add hl, hl              ; Shift left
 721: 3486+7+5	0294' 3812    	                jr c, ghn_error_ex      ; No bits should fall off the end
 722: 3493+11	0296' 29      	                add hl, hl
 723: 3504+7+5	0297' 380F    	                jr c, ghn_error_ex      ; No bits should fall off the end
 724: 3511+11	0299' 29      	                add hl, hl
 725: 3522+7+5	029A' 380C    	                jr c, ghn_error_ex      ; No bits should fall off the end
 726: 3529+11	029C' 29      	                add hl, hl
 727: 3540+7+5	029D' 3809    	                jr c, ghn_error_ex      ; No bits should fall off the end
 728: 3547+4	029F' EB      	                ex de, hl
 729:				; Insert new digit
 730: 3551+4	02A0' B3      	                or e
 731: 3555+4	02A1' 5F      	                ld e, a
 732:				; Count digits and check limit.
 733: 3559+6	02A2' 23      	                inc hl                  ; Point to next character
 734: 3565+4	02A3' 0C      	                inc c                   ; One more digit
 735: 3569+7+5	02A4' 20D4    	                jr nz, ghn_char_lp      ; Keep going unless over limit
 736: 3576+12	02A6' 1801    	                jr ghn_error
 737:				; Too many or zero digits or overflow.
 738: 3588+4	02A8' EB      	ghn_error_ex    ex de, hl
 739: 3592+10	02A9' C1      	ghn_error       pop bc
 740: 3602+4	02AA' 37      	                scf
 741: 3606+10	02AB' C9      	                ret                     ; Return with carry flag set (error)
 742:				; Non-hex character found.
 743: 3616+4	02AC' 79      	ghn_done        ld a, c
 744: 3620+4	02AD' A7      	                and a
 745: 3624+7+5	02AE' 28F9    	                jr z, ghn_error         ; Error if no digits read
 746:				; Normal completion.
 747: 3631+10	02B0' C1      	                pop bc
 748: 3641+10	02B1' C9      	                ret                     ; Return with carry flag reset (OK)
 749:				;
 750:				;
 751:				; Read a 16-bit unsigned decimal number from a string.
 752:				; Call with:
 753:				; HL - points to the first character of the number.
 754:				; Returns with:
 755:				; HL - points to first character after number.
 756:				; DE - required number
 757:				; C flag - set on error (too many or zero valid digits)
 758: 3651+11	02B2' C5      	rdduwd          push bc
 759: 3662+10	02B3' 110000  	                ld de, 0                ; Initial result
 760: 3672+7	02B6' 0E00    	                ld c, 0                 ; Count characters read
 761: 3679+7	02B8' 7E      	gdn_char_lp     ld a, (hl)
 762: 3686+7	02B9' D630    	                sub '0'
 763: 3693+7+5	02BB' 3827    	                jr c, gdn_done          ; End of number if < '0'
 764: 3700+7	02BD' FE0A    	                cp 10
 765: 3707+7+5	02BF' 3023    	                jr nc, gdn_done         ; End of number if not a digit
 766:				; Value of digit is in LSN of A. Make space for it in the result.
 767: 3714+11	02C1' C5      	                push bc                 ; Save counter
 768: 3725+4	02C2' EB      	                ex de, hl
 769: 3729+4	02C3' 44      	                ld b, h                 ; Save result x 1
 770: 3733+4	02C4' 4D      	                ld c, l
 771: 3737+11	02C5' 29      	                add hl, hl              ; Find result x 2
 772: 3748+7+5	02C6' 3817    	                jr c, gdn_error_pop     ; No bits should fall off the end
 773: 3755+11	02C8' 29      	                add hl, hl              ; Find result x 4
 774: 3766+7+5	02C9' 3814    	                jr c, gdn_error_pop
 775: 3773+11	02CB' 09      	                add hl, bc              ; Find result x 5
 776: 3784+7+5	02CC' 3811    	                jr c, gdn_error_pop                
 777: 3791+11	02CE' 29      	                add hl, hl              ; Find result x 10
 778: 3802+7+5	02CF' 380E    	                jr c, gdn_error_pop
 779:				; Insert new digit
 780: 3809+7	02D1' 0600    	                ld b, 0
 781: 3816+4	02D3' 4F      	                ld c, a
 782: 3820+11	02D4' 09      	                add hl, bc              ; Add digit
 783: 3831+7+5	02D5' 3808    	                jr c, gdn_error_pop
 784: 3838+4	02D7' EB      	                ex de, hl
 785: 3842+10	02D8' C1      	                pop bc                  ; Restore counter
 786:				; Count digits and check limit.
 787: 3852+6	02D9' 23      	                inc hl                  ; Point to next character
 788: 3858+4	02DA' 0C      	                inc c                   ; One more digit
 789: 3862+7+5	02DB' 20DB    	                jr nz, gdn_char_lp      ; Keep going unless 256 digits (unlikely)
 790: 3869+12	02DD' 1802    	                jr gdn_error
 791:				; Too many or zero digits or overflow.
 792: 3881+4	02DF' EB      	gdn_error_pop   ex de, hl               ; Move pointer back to HL
 793: 3885+10	02E0' C1      	                pop bc                  ; Clean up stack
 794: 3895+10	02E1' C1      	gdn_error       pop bc                  ; Restore original BC
 795: 3905+4	02E2' 37      	                scf
 796: 3909+10	02E3' C9      	                ret                     ; Return with carry flag set (error)
 797:				; Non-digit character found.
 798: 3919+4	02E4' 79      	gdn_done        ld a, c
 799: 3923+4	02E5' A7      	                and a
 800: 3927+7+5	02E6' 28F9    	                jr z, gdn_error         ; Error if no digits read
 801:				; Normal completion.
 802: 3934+10	02E8' C1      	                pop bc
 803: 3944+10	02E9' C9      	                ret                     ; Return with carry flag reset (OK)
 804:				;
 805:				;
 806:				; Read a 32-bit unsigned decimal number from a string.
 807:				; Call with:
 808:				; HL - points to the first character of the number.
 809:				; Returns with:
 810:				; HL - points to first character after number.
 811:				; BCDE - required number
 812:				; C flag - set on error (too many or zero valid digits)
 813: 3954+10	02EA' 010000  	rddulo          ld bc, 0                ; Initial result
 814: 3964+4	02ED' 50      	                ld d, b
 815: 3968+4	02EE' 59      	                ld e, c
 816: 3972+7	02EF' 3E00    	                ld a, 0                 ; Count characters read
 817: 3979+11	02F1' F5      	gldn_char_lp    push af                 ; Save counter
 818: 3990+7	02F2' 7E      	                ld a, (hl)
 819: 3997+7	02F3' D630    	                sub '0'
 820: 4004+7+5	02F5' 385E    	                jr c, gldn_done         ; End of number if < '0'
 821: 4011+7	02F7' FE0A    	                cp 10
 822: 4018+7+5	02F9' 305A    	                jr nc, gldn_done        ; End of number if not a digit
 823:				; Value of digit is in LSN of A. Make space for it in the result.
 824: 4025+11	02FB' E5      	                push hl                 ; Save pointer
 825: 4036+11	02FC' F5      	                push af                 ; Save digit
 826:				; Save result x 1 
 827: 4047+10	02FD' 210000  	                ld hl, gldn_x1
 828: 4057+7	0300' 73      	                ld (hl), e
 829: 4064+6	0301' 23      	                inc hl
 830: 4070+7	0302' 72      	                ld (hl), d
 831: 4077+6	0303' 23      	                inc hl
 832: 4083+7	0304' 71      	                ld (hl), c
 833: 4090+6	0305' 23      	                inc hl
 834: 4096+7	0306' 70      	                ld (hl), b
 835:				; Find result x 2
 836: 4103+8	0307' CB23    	                sla e
 837: 4111+8	0309' CB12    	                rl d
 838: 4119+8	030B' CB11    	                rl c
 839: 4127+8	030D' CB10    	                rl b
 840: 4135+7+5	030F' 3840    	                jr c, gldn_error_pop    ; No bits should fall off the end
 841:				; Find result x 4
 842: 4142+8	0311' CB23    	                sla e
 843: 4150+8	0313' CB12    	                rl d
 844: 4158+8	0315' CB11    	                rl c
 845: 4166+8	0317' CB10    	                rl b
 846: 4174+7+5	0319' 3836    	                jr c, gldn_error_pop    ; No bits should fall off the end
 847:				; Add "x 1" to obtain result x 5
 848: 4181+10	031B' 210000  	                ld hl, gldn_x1
 849: 4191+4	031E' 7B      	                ld a, e
 850: 4195+7	031F' 86      	                add (hl)
 851: 4202+4	0320' 5F      	                ld e, a
 852: 4206+6	0321' 23      	                inc hl
 853: 4212+4	0322' 7A      	                ld a, d
 854: 4216+7	0323' 8E      	                adc (hl)
 855: 4223+4	0324' 57      	                ld d, a
 856: 4227+6	0325' 23      	                inc hl
 857: 4233+4	0326' 79      	                ld a, c
 858: 4237+7	0327' 8E      	                adc (hl)
 859: 4244+4	0328' 4F      	                ld c, a
 860: 4248+6	0329' 23      	                inc hl
 861: 4254+4	032A' 78      	                ld a, b
 862: 4258+7	032B' 8E      	                adc (hl)
 863: 4265+4	032C' 47      	                ld b, a
 864: 4269+7+5	032D' 3822    	                jr c, gldn_error_pop    ; No bits should fall off the end
 865:				; Find result x 10
 866: 4276+8	032F' CB23    	                sla e
 867: 4284+8	0331' CB12    	                rl d
 868: 4292+8	0333' CB11    	                rl c
 869: 4300+8	0335' CB10    	                rl b
 870: 4308+7+5	0337' 3818    	                jr c, gldn_error_pop    ; No bits should fall off the end
 871: 4315+10	0339' F1      	                pop af                  ; Restore digit
 872:				; Insert new digit
 873: 4325+7	033A' 2E00    	                ld l, 0                 ; Cache zero
 874: 4332+4	033C' 83      	                add e
 875: 4336+4	033D' 5F      	                ld e, a
 876: 4340+4	033E' 7D      	                ld a, l
 877: 4344+4	033F' 8A      	                adc d
 878: 4348+4	0340' 57      	                ld d, a
 879: 4352+4	0341' 7D      	                ld a, l
 880: 4356+4	0342' 89      	                adc c
 881: 4360+4	0343' 4F      	                ld c, a
 882: 4364+4	0344' 7D      	                ld a, l
 883: 4368+4	0345' 88      	                adc b
 884: 4372+4	0346' 47      	                ld b, a
 885: 4376+7+5	0347' 3808    	                jr c, gldn_error_pop    ; No bits should fall off the end
 886:				; BCDE - required number
 887: 4383+10	0349' E1      	                pop hl                  ; Restore pointer
 888:				; Count digits and check limit.
 889: 4393+6	034A' 23      	                inc hl                  ; Point to next character
 890: 4399+10	034B' F1      	                pop af                  ; Restore counter
 891: 4409+4	034C' 3C      	                inc a                   ; One more digit
 892: 4413+7+5	034D' 20A2    	                jr nz, gldn_char_lp     ; Keep going unless 256 digits (unlikely)
 893: 4420+12	034F' 1802    	                jr gldn_error
 894:				; Too many or zero digits or overflow.
 895: 4432+10	0351' E1      	gldn_error_pop  pop hl                  ; Restore pointer
 896: 4442+10	0352' F1      	                pop af                  ; Discard counter
 897: 4452+4	0353' 37      	gldn_error      scf
 898: 4456+10	0354' C9      	                ret                     ; Return with carry flag set (error)
 899:				; Non-digit character found.
 900: 4466+10	0355' F1      	gldn_done       pop af                  ; Restore counter
 901: 4476+4	0356' A7      	                and a
 902: 4480+7+5	0357' 28FA    	                jr z, gldn_error        ; Error if no digits read
 903:				; Normal completion.
 904: 4487+10	0359' C9      	                ret                     ; Return with carry flag reset (OK)
 905:				;
 906:				;
 907:				;
 908:				; *************
 909:				; * Constants *
 910:				; *************
 911:				;
 912:				;
 913:     -	035A' 0D0A2A2A	panic_1_msg     byte 0x0d, 0x0a, "*** Software panic at PC=", "$"
	              2A20536F
	              66747761
	              72652070
	              616E6963
	              20617420
	              50433D24
 914:     -	0376' 202A2A2A	panic_2_msg     byte " ***", 0x0d, 0x0a, "$"
	              0D0A24
 915:     -	037D' 1B5B3F32	curv_seq_msg    byte 0x1b, "[?25$"
	              3524
 916:     -	0383' 1B5B4A24	ccls_seq_msg    byte 0x1b, "[J$"
 917:				;
 918:				;
 919:				;
 920:				; *************
 921:				; * Variables *
 922:				; *************
 923:				;
 924:				; Note: linker "-c" option is used, so no data is initialised here.
 925:				                dseg                ; Data segment
 926:				;
 927:     -	0000"         	gldn_x1         defs 4              ; Read long decimal temporary store
 928:				; cwpdlo (32-bit decimal print) variables
 929:     -	0004"         	pdl_reg         defs 4              ; Working store
 930:     -	0008"         	pdl_lz_flag     defs 1              ; Leading zero flag
 931:     -	0009"         	pdl_ascii       defs 1              ; ASCII digit
 932:				;
 933:     -	000A"         	                end



Statistics:

     4	passes
     0	jr promotions
   281	symbols
   903	bytes

    94	macro calls
  1546	macro bytes
     0	invented symbols



Symbol Table:

ASCII_BS       =08        8
ASCII_CR       =0D        13
ASCII_DEL      =7F        127
ASCII_ENQ      =05        5
ASCII_ESC      =1B        27
ASCII_FF       =0C        12
ASCII_HT       =09        9
ASCII_LF       =0A        10
ASCII_RS       =1E        30
ASCII_SUB      =1A        26
ASCII_SYN      =16        22
ASCII_VT       =0B        11
BDOS           =05        5
BDOS_CLOSE_FILE=10        16
BDOS_CON_IN    =01        1
BDOS_CON_OUT   =02        2
BDOS_DELETE_FILE=13        19
BDOS_DIRECT_CON_IO=06        6
BDOS_GET_ALLOC_ADDR=1B        27
BDOS_GET_CON_STAT=0B        11
BDOS_GET_CURR_DISK=19        25
BDOS_GET_DPB   =1F        31
BDOS_GET_FILE_SIZE=23        35
BDOS_GET_IO_BYTE=07        7
BDOS_GET_LOGIN_VEC=18        24
BDOS_GET_RO_VEC=1D        29
BDOS_GET_SET_USER=20        32
BDOS_LST_OUT   =05        5
BDOS_MAKE_FILE =16        22
BDOS_OPEN_FILE =0F        15
BDOS_PRINT_STRING=09        9
BDOS_PUN_OUT   =04        4
BDOS_RDR_IN    =03        3
BDOS_READ_CON_BUFF=0A        10
BDOS_READ_RANDOM=21        33
BDOS_READ_SEQ  =14        20
BDOS_READ_SEQ_EOF=01        1
BDOS_RENAME_FILE=17        23
BDOS_RESET_DISK_SYS=0D        13
BDOS_RESET_DRIVES=25        37
BDOS_SEARCH_FIRST=11        17
BDOS_SEARCH_NEXT=12        18
BDOS_SEL_DISK  =0E        14
BDOS_SET_DMA_ADDR=1A        26
BDOS_SET_FILE_ATTR=1E        30
BDOS_SET_IO_BYTE=08        8
BDOS_SET_RANDOM_REC=24        36
BDOS_START     =DE06      56838
BDOS_SYS_RST   =00        0
BDOS_VERSION   =0C        12
BDOS_WRITE_PROT=1C        28
BDOS_WRITE_RANDOM=22        34
BDOS_WRITE_RAN_ZFILL=28        40
BDOS_WRITE_SEQ =15        21
BIOS_AUXIST    =33        51
BIOS_AUXOST    =36        54
BIOS_CONIN     =06        6
BIOS_CONOST    =30        48
BIOS_CONOUT    =09        9
BIOS_CONST     =03        3
BIOS_CPM_START_SEC=2C        44
BIOS_DEVINI    =3C        60
BIOS_DEVTBL    =39        57
BIOS_DRVTBL    =3F        63
BIOS_FLUSH     =45        69
BIOS_GET_TIMER =7B        123
BIOS_HOME      =15        21
BIOS_ID        =60        96
BIOS_INT_DISABLE=6F        111
BIOS_INT_ENABLE=72        114
BIOS_JPTBL_NEXT=7E        126
BIOS_LISTST    =2A        42
BIOS_MAX_SIZE  =1000      4096
BIOS_MON_CALL  =69        105
BIOS_MOVE      =48        72
BIOS_MULTIO    =42        66
BIOS_OPT_DEBUG_BIT=00        0
BIOS_OPT_DEBUG_MASK=01        1
BIOS_OPT_NOINTS_BIT=01        1
BIOS_OPT_NOINTS_MASK=02        2
BIOS_OPT_RAWCON_BIT=02        2
BIOS_OPT_RAWCON_MASK=04        4
BIOS_PLIST     =0C        12
BIOS_PUNCH     =0F        15
BIOS_READ      =24        36
BIOS_READER    =12        18
BIOS_RESERV1   =5A        90
BIOS_RESERV2   =5D        93
BIOS_SECTRAN   =2D        45
BIOS_SELDSK    =18        24
BIOS_SELMEM    =4E        78
BIOS_SETBNK    =51        81
BIOS_SETDMA    =21        33
BIOS_SETSEC    =1E        30
BIOS_SETTRK    =1B        27
BIOS_SET_TIMER =78        120
BIOS_START     =EC00      60416
BIOS_STARTUP   =66        102
BIOS_SUPER     =6C        108
BIOS_TIME      =4B        75
BIOS_TIRD      =75        117
BIOS_USERF     =57        87
BIOS_VER       =63        99
BIOS_WBOOT     =00        0
BIOS_WRITE     =27        39
BIOS_XMOVE     =54        84
CCP_START      =D600      54784
CDISK          =04        4
CPMU           =01        1
CPM_BIAS       =A200      41472
CPM_DISK_SIZE  =00100000  1048576
CPM_SECTOR_SIZE=80        128
CPM_SYS_SIZE   =00100000  1048576
DEF_BUFFER     =80        128
DEF_BUFFER_SIZE=80        128
DIRE_ALLOC     =10        16
DIRE_EX        =0C        12
DIRE_NAME      =01        1
DIRE_RC        =0F        15
DIRE_S1        =0D        13
DIRE_S2        =0E        14
DIRE_SIZE      =20        32
DIRE_TYP       =09        9
DIRE_USER      =00        0
DPB_AL0        =09        9
DPB_AL1        =0A        10
DPB_BLM        =03        3
DPB_BSH        =02        2
DPB_CKS        =0B        11
DPB_DRM        =07        7
DPB_DSM        =05        5
DPB_EXM        =04        4
DPB_OFF        =0D        13
DPB_SIZE       =0F        15
DPB_SPT        =00        0
DPH_ALV        =0E        14
DPH_CSV        =0C        12
DPH_DIRBF      =08        8
DPH_DPB        =0A        10
DPH_SCRATCH0   =02        2
DPH_SCRATCH1   =04        4
DPH_SCRATCH2   =06        6
DPH_SIZE       =10        16
DPH_XLT        =00        0
FCB1           =5C        92
FCB2           =6C        108
FCB_ALLOC      =10        16
FCB_CR         =20        32
FCB_DRIVE      =00        0
FCB_EX         =0C        12
FCB_NAME       =01        1
FCB_RC         =0F        15
FCB_RECORD     =21        33
FCB_S1         =0D        13
FCB_S2         =0E        14
FCB_SIZE       =24        36
FCB_TYP        =09        9
FILEEXT_SIZE   =03        3
FILENAME_SIZE  =08        8
FILE_EOF       =1A        26
INT_VEC_TABLE  =FFE0      65504
IOBYTE         =03        3
IOB_CON_MASK   =03        3
IOB_LST_MASK   =C0        192
IOB_PUN_MASK   =30        48
IOB_RDR_MASK   =0C        12
MAX_USER       =0F        15
MMAP_CPM_PAGES =04        4
MTWDLI_ABBREV_BIT=00        0
MTWDLI_ABBREV_MASK=01        1
MTWDLI_ICASE_BIT=01        1
MTWDLI_ICASE_MASK=02        2
MTWDLI_TERM_BIT=07        7
MTWDLI_TERM_MASK=80        128
NUM_DISKS      =10        16
NUM_DISKS_MAX  =10        16
TPA_START      = 100      256
Z80_NMI_VEC    =66        102
Z80_RST00_VEC  =00        0
Z80_RST08_VEC  =08        8
Z80_RST10_VEC  =10        16
Z80_RST18_VEC  =18        24
Z80_RST20_VEC  =20        32
Z80_RST28_VEC  =28        40
Z80_RST30_VEC  =30        48
Z80_RST38_VEC  =38        56
ZKEY_CSR_DOWN  =1E        30
ZKEY_CSR_LEFT  =01        1
ZKEY_CSR_RIGHT =06        6
ZKEY_CSR_UP    =1F        31
ZKEY_DELETE    =7F        127
ZKEY_END       =04        4
ZKEY_HOME      =02        2
ZKEY_INSERT    =16        22
ZKEY_PAGE_DOWN =1C        28
ZKEY_PAGE_UP   =1D        29
cbdos           00'       0 (public)
cbios           0C'       12 (public)
cbios_raw       18'       24
ccls_seq_msg     383'     899
conrch          7F'       127 (public)
const           96'       150 (public)
conwch          71'       113 (public)
conwmn           1F6'     502 (public)
conwms          A3'       163 (public)
curv_seq_msg     37D'     893
cwms_exit       B0'       176
cwms_loop       A5'       165
cwnwln          8C'       140 (public)
cwpdby           112'     274 (public)
cwpdlo           159'     345 (public)
cwpdwd           11C'     284 (public)
cwphby          FE'       254 (public)
cwphnb          F1'       241 (public)
cwphwd           10A'     266 (public)
cwpspc          CC'       204 (public)
cwvich          D1'       209 (public)
gdn_char_lp      2B8'     696
gdn_done         2E4'     740
gdn_error        2E1'     737
gdn_error_pop    2DF'     735
ghn_char_lp      27A'     634
ghn_done         2AC'     684
ghn_error        2A9'     681
ghn_error_ex     2A8'     680
ghn_got_dig      292'     658
ghn_not_alpha    28A'     650
gldn_char_lp     2F1'     753
gldn_done        355'     853
gldn_error       353'     851
gldn_error_pop   351'     849
gldn_x1         00"       0
jptbl_addr     =7E        126
mtwdli           21A'     538 (public)
mw_char_loop     21F'     543
mw_char_mis      252'     594
mw_dot           271'     625
mw_end_both      26C'     620
mw_end_lwd       261'     609
mw_next_lwd      255'     597
mw_no_match      268'     616
mw_str_tm_dn     235'     565
mw_sword_end     233'     563
panic           20'       32 (public)
panic_1_msg      35A'     858
panic_2_msg      376'     886
pdl_ascii       09"       9
pdl_digit        1B1'     433
pdl_digloop      1B6'     438
pdl_entry        127'     295
pdl_lz_flag     08"       8
pdl_prdig        1EF'     495
pdl_reg         04"       4
pdw_byte         12D'     301
pdw_digit        142'     322
pdw_digloop      144'     324
pdw_prdig        153'     339
pmn_done         214'     532
pmn_error        217'     535
pmn_found        207'     519
pmn_msg_lp       1F8'     504
pmn_sk_lp        1FC'     508
pn_numeric      FB'       251
prv_dis_exit    DB'       219
prv_do_subs     E0'       224
prv_exit        DE'       222
rddulo           2EA'     746 (public)
rdduwd           2B2'     690 (public)
rdhxwd           274'     628 (public)
skpspc          B3'       179 (public)
sks_loop        B5'       181
str_offset     =24        36
toloca          C3'       195 (public)
toupca          BA'       186 (public)
z80det          57'       87 (public)
z8d_exit        6B'       107
z8d_not_z80     6D'       109
z8d_z80         6A'       106
zd_exit         51'       81
zd_not_zarc     54'       84
zrcdet          33'       51 (public)
