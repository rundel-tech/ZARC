   1:				; *******************************************************
   2:				; * CP/M File System Checker                            *
   3:				; * Version: V1.2                                       *
   4:				; * Merlin Skinner-Oakes, 16/2/2022                     *
   5:				; *******************************************************
   6:				;
   7:				; V1.0 - 16/2/2022, initial version.
   8:				; V1.1 - 4/11/2022, added option to skip the surface scan on request from
   9:				;        "alank2" at https://forum.vcfed.org/
  10:				; V1.2 - 18/6/2023, added support for interleaved discs by Chris Radek (cradek)
  11:				;        plus bugfixes for small disks. These resulted from Chris' tests on real
  12:				;        hardware with 8" disks.
  13:				;
  14:				;
  15:				; CP/M 2.2 file system checker. It is intended for ZARC but avoids using
  16:				; any special facilities so should run elsewhere. It reads the DPB to discover
  17:				; the organisation of the disk, so it should work for any sensible disk size or
  18:				; organisation.
  19:				;
  20:				; Each directory entry is scanned in turn, and a list (files_info) is
  21:				; constructed with one entry per file. This contains a bitmap of physical
  22:				; extents encountered, so it is possible to discover "holes" (sparse files)
  23:				; as well as duplicated extents.
  24:				;
  25:				; As files are discovered, files_info will grow by FI_SIZE each time. In
  26:				; addition, it will grow by a single byte each time more extent flags are
  27:				; required for any file.
  28:				;
  29:				; Note that there is a difference between logical and physical extents. A
  30:				; logical extent always contains 16 KB bytes of data. Each physical extent
  31:				; (directory entry) can contain one or more logical extents. (EXM + 1) is the
  32:				; number of logical extents per physical one. For ZARC (at least in its present
  33:				; form, EXM is zero so both logical and physical extents are 16 KB long. Useful
  34:				; reference:
  35:				; Ref. https://dflund.se/~pi/cpm/files/ftp.mayn.de/pub/cpm/archive/cpminfo/cpm-dir1.not.txt
  36:				;
  37:				; From this example:
  38:				; BLS = 2K so BSH = 4 and BLM = 15
  39:				; It uses 8-bit allocation numbers, so DSM < 256 and EXM = 1
  40:				;
  41:				; From: https://www.seasip.info/Cpm/format22.html
  42:				; (Physical) entry number (PEXTENT) = ((32*S2)+EX) / (EXM+1)
  43:				; There are two physical extents shown,
  44:				; S2 = 0 and EX = 1, which gives ((32*0)+1) / (2) = 0
  45:				; S2 = 0 and EX = 3, which gives ((32*0)+3) / (2) = 1
  46:				; So the above equation gives the physical extent number of a given directory
  47:				; entry. This is what we want to construct a bitmap of physical extents.
  48:				;
  49:				;
  50:				                title CP/M File System Checker
  51:				;
  52:				;
  53:				;
  54:				; ************
  55:				; * Includes *
  56:				; ************
  57:				;
  58:				;
  59:				                include "macros.i"
**** /home/merlin/Technical/ZARC_Z80_Box/git/software/includes//macros.i ****
   1:				; ***********************************
   2:				; * ZARC Macro Definitions          *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 30/7/2020         *
   5:				; ***********************************
   6:				;
   7:				;
   8:				;
   9:				; **********
  10:				; * Macros *
  11:				; **********
  12:				;
  13:				;
  14:				; Initialise enumeration.
  15:				; The absolute segment is used so the offsets are not marked as relocatable. This
  16:				; avoids "Not relocatable" errors.
  17:				ENUM_START      macro
  18:				                .aseg
  19:				enum_counter    set 0
  20:				                endm
  21:				;
  22:				; Invoke for each item.
  23:				ENUM            macro x
  24:				x               equ enum_counter
  25:				enum_counter    set enum_counter + 1
  26:				                endm
  27:				;
  28:				ENUM_END        macro x
  29:				x               set enum_counter    ; Set label to count of items
  30:				                .cseg
  31:				                endm
  32:				;
  33:				;
  34:				; Initialise a structure. This is used to generate offsets for data structures.
  35:				; The absolute segment is used so the offsets are not marked as relocatable. This
  36:				; avoids "Not relocatable" errors.
  37:				STRUCT          macro
  38:				                .aseg
  39:				str_offset      set 0
  40:				                endm
  41:				;
  42:				; Add a byte entry.
  43:				STR_BYTE        macro x
  44:				x               equ str_offset
  45:				str_offset      set str_offset + 1
  46:				                endm
  47:				;
  48:				; Add a word (16-bit) entry.
  49:				STR_WORD        macro x
  50:				x               equ str_offset
  51:				str_offset      set str_offset + 2
  52:				                endm
  53:				;
  54:				; Add a 3 byte (24-bit) entry.
  55:				STR_24BIT       macro x
  56:				x               equ str_offset
  57:				str_offset      set str_offset + 3
  58:				                endm
  59:				;
  60:				; Add a long (32-bit) entry.
  61:				STR_LONG        macro x
  62:				x               equ str_offset
  63:				str_offset      set str_offset + 4
  64:				                endm
  65:				;
  66:				; Add an arbitrary length entry.
  67:				STR_BLOCK       macro x, size   ; <name>, <size>
  68:				x               equ str_offset
  69:				str_offset      set str_offset + size
  70:				                endm
  71:				;
  72:				; End of structure (used to set size)
  73:				STR_END         macro x
  74:				x               equ str_offset
  75:				                .cseg
  76:				                endm
  77:				;
  78:				;
  79:				; Calculate offsets into jump tables.
  80:				; The absolute segment is used so the offsets are not marked as relocatable. This
  81:				; avoids "Not relocatable" errors.
  82:				JPTBL_START     macro x
  83:				                .aseg
  84:				jptbl_addr      set x               ; Set start address
  85:				                endm
  86:				;
  87:				; Invoke for each item.
  88:				JPTBL_ENTRY     macro x
  89:				x               equ jptbl_addr
  90:				jptbl_addr      set jptbl_addr + 3
  91:				                endm
  92:				;
  93:				; Invoke for a data block in the jump table
  94:				JPTBL_BLOCK     macro x, size   ; <name>, <size>
  95:				x               equ jptbl_addr
  96:				jptbl_addr      set jptbl_addr + size
  97:				                endm
  98:				;
  99:				JPTBL_END       macro x
 100:				x               set jptbl_addr      ; Set label to next address
 101:				                .cseg
 102:				                endm
 103:				;
 104:				;
 105:				; Define bits and masks. This is inspired by the Commodore Amiga BITDEF mechanism.
 106:				; Given:
 107:				; BITDEF I2C_CSR_STOP, 2
 108:				; Yields:
 109:				; I2C_CSR_STOP_BIT  EQU 2       ; Bit number
 110:				; I2C_CSR_STOP_MASK EQU 1<<2    ; Bit mask
 111:				BITDEF          macro n, b      ; <Name>, <bit>
 112:				n`_BIT          equ b
 113:				n`_MASK         equ 1 << b
 114:				                endm
 115:				;
 116:				;
 117:				; Force alignment. This asserts an appropriate number of zero bytes to achieve
 118:				; the required alignment. Note that these macros cannot work for relocatable
 119:				; files.
 120:				; 16-bit
 121:				ALIGN_WORD      macro
 122:				                if $ and 1
 123:				                    byte 0
 124:				                endif
 125:				                endm
 126:				;
 127:				; 32-bit
 128:				ALIGN_LONG      macro
 129:				                ALIGN_WORD
 130:				                if $ and 2
 131:				                    byte 0, 0
 132:				                endif
 133:				                endm
 134:				
**** fsck.z80 ****
  60:				                include "cpm.i"
**** /home/merlin/Technical/ZARC_Z80_Box/git/software/includes//cpm.i ****
   1:				; *******************************************************
   2:				; * ZARC Monitor CP/M Definitions                       *
   3:				; * Written by: Merlin Skinner                          *
   4:				; * Date Started: 26/5/2020                             *
   5:				; *******************************************************
   6:				;
   7:				; Definitions related CP/M running under the monitor programme.
   8:				;
   9:				; Note that ld80 only considers the first six characters of labels significant.
  10:				;
  11:				; The following conditionals are intended to allow the same include file to be
  12:				; used in the defining module and elsewhere as required. Some includes are used
  13:				; for other applications than the monitor, such as the CP/M BIOS. In these cases,
  14:				; the extern and public statements are not desirable.
  15:				;
  16:     -	0000'         	            ifdef monitor           ; Meaningful for monitor build only
  28:				            endif
  29:				;
  30:				;
  31:				;
  32:				; ****************
  33:				; * Memory Usage *
  34:				; ****************
  35:				;
  36:				;
  37:				; Note: memory banks are allocated by the monitor's initialisation code.
  38:     -	0004'         	MMAP_CPM_PAGES      equ 4               ; Number of 16 kB pages
  39:				;
  40:				; The MS byte of INT_VEC_TABLE comes from the Z80 I register, and the LS byte
  41:				; from the FPGA. The 0xe0 offset is chosen to allow the table to reside at the
  42:				; top of memory (0xffe0 to 0xffff).
  43:     -	FFE0'         	INT_VEC_TABLE   equ 0xffe0              ; Interrupt mode 2 vector table
  44:				;
  45:				; Copied from CP/M manual appendix A.
  46:				; MSIZE             equ 64              ; CP/M version memory size in kilobytes
  47:				;
  48:				; "BIAS" is the address offset from 0x3400 for memory systems other than 16 K.
  49:				;BIAS               equ (MSIZE-20) * 1024
  50:     -	A200'         	CPM_BIAS            equ 0xa200          ; For CompuPro64K_CPM
  51:     -	D600'         	CCP_START           equ 0x3400 + CPM_BIAS   ; Base of CCP
  52:     -	DE06'         	BDOS_START          equ CCP_START + 0x0806  ; Base of BDOS
  53:     -	EC00'         	BIOS_START          equ CCP_START + 0x1600  ; Base of BIOS
  54:     -	002C'         	BIOS_CPM_START_SEC  equ 44              ; First CP/M sector of BIOS
  55:     -	1000'         	BIOS_MAX_SIZE       equ 4096            ; 2 KB allocation for BIOS stored on MMC (ZARC)
  56:     -	0100'         	TPA_START           equ 0x0100          ; Transient Programme Area
  57:				;
  58:				; Page zero.
  59:     -	0003'         	IOBYTE              equ 0x0003          ; Intel I/O byte
  60:     -	0004'         	CDISK               equ 0x0004          ; Current disk (0="A") & user no. (in high nibble)
  61:     -	005C'         	FCB1                equ 0x005c          ; Default FCB 1
  62:     -	006C'         	FCB2                equ 0x006c          ; Default FCB 2 (overwritten if FCB 1 is opened)
  63:				; Default 128-byte disk buffer, also filled with the command line when a transient
  64:				; is loaded under the CCP.
  65:     -	0080'         	DEF_BUFFER          equ 0x80
  66:     -	0080'         	DEF_BUFFER_SIZE     equ 0x80
  67:				;
  68:				; IOBYTE bit definitions.
  69:     -	0003'         	IOB_CON_MASK        equ 0x03
  70:     -	000C'         	IOB_RDR_MASK        equ 0x0c
  71:     -	0030'         	IOB_PUN_MASK        equ 0x30
  72:     -	00C0'         	IOB_LST_MASK        equ 0xc0
  73:				;
  74:				; BIOS option bits.
  75:     -	        	BITDEF BIOS_OPT_DEBUG, 0                ; Enable BIOS debugging messages
  76:     -	        	BITDEF BIOS_OPT_NOINTS, 1               ; Disables interrupts (use basic I/O mode)
  77:     -	        	BITDEF BIOS_OPT_RAWCON, 2               ; Disables ADM-3A to VT-100 translation
  78:				;
  79:				;
  80:				;
  81:				; ***************
  82:				; * Disk System *
  83:				; ***************
  84:				;
  85:				;
  86:     -	0080'         	CPM_SECTOR_SIZE     equ 128             ; CP/M disk sector size
  87:     -	0010'         	NUM_DISKS           equ 16              ; Number of disk drives
  88:     -	0010'         	NUM_DISKS_MAX       equ 16              ; Maximum number of disk drives
  89:     -	0000'         	CPM_SYS_SIZE        equ 1024 * 1024     ; System area size (bytes)
  90:     -	0000'         	CPM_DISK_SIZE       equ 1024 * 1024     ; Disk size (bytes)
  91:     -	0008'         	FILENAME_SIZE       equ 8               ; Filename size
  92:     -	0003'         	FILEEXT_SIZE        equ 3               ; File extension size
  93:     -	001A'         	FILE_EOF            equ 0x1a            ; End of file (^Z)
  94:     -	000F'         	MAX_USER            equ 15              ; Maximum user number
  95:				;
  96:     -	0001'         	BDOS_READ_SEQ_EOF   equ 1               ; Sequential read EOF error code
  97:				;
  98:				; Disk Parameter Header (DPH) structure.
  99:     -	        	                STRUCT
 100:     -	        	                STR_WORD DPH_XLT        ; Address of sector translation table
 101:     -	        	                STR_WORD DPH_SCRATCH0   ; BDOS scratch area
 102:     -	        	                STR_WORD DPH_SCRATCH1
 103:     -	        	                STR_WORD DPH_SCRATCH2
 104:     -	        	                STR_WORD DPH_DIRBF      ; BDOS directory scratch area
 105:     -	        	                STR_WORD DPH_DPB        ; Pointer to DPB
 106:     -	        	                STR_WORD DPH_CSV        ; Pointer to the directory checksum vector
 107:     -	        	                STR_WORD DPH_ALV        ; Pointer to the allocation vector
 108:     -	        	                STR_END DPH_SIZE
 109:				;
 110:				;
 111:				; Disk Parameter Block (DPB) structure.
 112:     -	        	                STRUCT
 113:     -	        	                STR_WORD DPB_SPT        ; Number of 128-byte records per track
 114:     -	        	                STR_BYTE DPB_BSH        ; Block shift. 3 => 1k, 4 => 2k, 5 => 4k....
 115:     -	        	                STR_BYTE DPB_BLM        ; Block mask. 7 => 1k, 0Fh => 2k, 1Fh => 4k...
 116:     -	        	                STR_BYTE DPB_EXM        ; Extent mask
 117:     -	        	                STR_WORD DPB_DSM        ; Maximum block number
 118:     -	        	                STR_WORD DPB_DRM        ; Maximum directory entry number
 119:     -	        	                STR_BYTE DPB_AL0        ; Directory allocation bitmap
 120:     -	        	                STR_BYTE DPB_AL1
 121:     -	        	                STR_WORD DPB_CKS        ; Checksum vector size, 0 for a fixed disc
 122:     -	        	                STR_WORD DPB_OFF        ; Offset, number of reserved tracks
 123:     -	        	                STR_END DPB_SIZE
 124:				;
 125:				;
 126:				; Directory entry structure.
 127:     -	        	                STRUCT
 128:     -	        	                STR_BYTE DIRE_USER      ; User number. 0xe5 if entry unused
 129:     -	        	                STR_BLOCK DIRE_NAME, FILENAME_SIZE  ; Filename
 130:     -	        	                STR_BLOCK DIRE_TYP, FILEEXT_SIZE    ; File type
 131:     -	        	                STR_BYTE DIRE_EX        ; Extent counter, low byte (0-31)
 132:     -	        	                STR_BYTE DIRE_S1        ; Reserved, set to 0
 133:     -	        	                STR_BYTE DIRE_S2        ; Extent counter, high byte
 134:     -	        	                STR_BYTE DIRE_RC        ; Record count (low byte)
 135:     -	        	                STR_BLOCK DIRE_ALLOC, 16 ; Associated block numbers
 136:     -	        	                STR_END DIRE_SIZE
 137:				;
 138:				;
 139:				; File Control Block (FCB) structure.
 140:     -	        	                STRUCT
 141:     -	        	                STR_BYTE FCB_DRIVE      ; Drive. 0 for default, 1-16 for A-P
 142:     -	        	                STR_BLOCK FCB_NAME, FILENAME_SIZE   ; Filename in ASCII upper-case
 143:     -	        	                STR_BLOCK FCB_TYP, FILEEXT_SIZE     ; File type
 144:     -	        	                STR_BYTE FCB_EX         ; Current extent (*)
 145:     -	        	                STR_BYTE FCB_S1         ; Reserved (*)
 146:     -	        	                STR_BYTE FCB_S2         ; Reserved (*)
 147:     -	        	                STR_BYTE FCB_RC         ; Reserved (*)
 148:     -	        	                STR_BLOCK FCB_ALLOC, 16 ; Associated block numbers
 149:     -	        	                STR_BYTE FCB_CR         ; Current record within extent
 150:     -	        	                STR_BLOCK FCB_RECORD, 3 ; Record number (low byte first)
 151:     -	        	                STR_END FCB_SIZE
 152:				;
 153:				; * - Set this to 0 when opening a file and then leave it to CP/M. You can rewind
 154:				; a file by setting EX, RC, S2 and CR to 0.
 155:				;
 156:				;
 157:				;
 158:				; **************
 159:				; * BIOS Calls *
 160:				; **************
 161:				;
 162:				;
 163:				; Calculate offsets into jump tables. Entries here must match the jump table in
 164:				; the BIOS. The base address of the BIOS must be added to these addresses. A call
 165:				; routine might look like:
 166:				;
 167:				; Call BIOS, allowing for its unknown base address.
 168:				; Call with:
 169:				; BC - operand (depends on BIOS function called)
 170:				; DE - operand (depends on BIOS function called)
 171:				; HL - offset for the routine (e.g. BIOS_CONIN)
 172:				; call_bios       push de
 173:				;                 ex de, hl
 174:				;                 ld hl, (1)              ; Find WBOOT (warm boot) address
 175:				;                 add hl, de              ; Add offset
 176:				;                 pop de
 177:				;                 jp (hl)                 ; Jump to BIOS then return to caller
 178:				;
 179:				; The above method is a bit clumsy, but then application code shouldn't normally
 180:				; call the BIOS directly.
 181:				;
 182:     -	        	    JPTBL_START 0                   ; Generate offsets as BIOS_START isn't always known
 183:				;
 184:				; From monitor.z80
 185:				; Note - cold start routine omitted to align with use of address at (1) to find BIOS.
 186:     -	        	    JPTBL_ENTRY BIOS_WBOOT          ; Warm boot - reload command processor
 187:     -	        	    JPTBL_ENTRY BIOS_CONST          ; Console status
 188:     -	        	    JPTBL_ENTRY BIOS_CONIN          ; Console input
 189:     -	        	    JPTBL_ENTRY BIOS_CONOUT         ; Console output
 190:     -	        	    JPTBL_ENTRY BIOS_PLIST          ; Printer output
 191:     -	        	    JPTBL_ENTRY BIOS_PUNCH          ; Paper tape punch output
 192:     -	        	    JPTBL_ENTRY BIOS_READER         ; Paper tape reader input
 193:     -	        	    JPTBL_ENTRY BIOS_HOME           ; Move disc head to track 0
 194:     -	        	    JPTBL_ENTRY BIOS_SELDSK         ; Select disc drive
 195:     -	        	    JPTBL_ENTRY BIOS_SETTRK         ; Set track number
 196:     -	        	    JPTBL_ENTRY BIOS_SETSEC         ; Set sector number
 197:     -	        	    JPTBL_ENTRY BIOS_SETDMA         ; Set DMA address
 198:     -	        	    JPTBL_ENTRY BIOS_READ           ; Read a sector
 199:     -	        	    JPTBL_ENTRY BIOS_WRITE          ; Write a sector
 200:				; CP/M 2 functions.
 201:     -	        	    JPTBL_ENTRY BIOS_LISTST         ; Status of list device
 202:     -	        	    JPTBL_ENTRY BIOS_SECTRAN        ; Sector translation for skewing
 203:				; CP/M 3 functions (not supported yet). From https://www.seasip.info/Cpm/bios.html
 204:     -	        	    JPTBL_ENTRY BIOS_CONOST         ; Status of console output
 205:     -	        	    JPTBL_ENTRY BIOS_AUXIST         ; Status of auxiliary input
 206:     -	        	    JPTBL_ENTRY BIOS_AUXOST         ; Status of auxiliary output
 207:     -	        	    JPTBL_ENTRY BIOS_DEVTBL         ; Address of devices table
 208:     -	        	    JPTBL_ENTRY BIOS_DEVINI         ; Initialise a device
 209:     -	        	    JPTBL_ENTRY BIOS_DRVTBL         ; Address of discs table
 210:     -	        	    JPTBL_ENTRY BIOS_MULTIO         ; Read/write multiple sectors
 211:     -	        	    JPTBL_ENTRY BIOS_FLUSH          ; Flush host buffers
 212:     -	        	    JPTBL_ENTRY BIOS_MOVE           ; Move a block of memory
 213:     -	        	    JPTBL_ENTRY BIOS_TIME           ; Real time clock
 214:     -	        	    JPTBL_ENTRY BIOS_SELMEM         ; Select memory bank
 215:     -	        	    JPTBL_ENTRY BIOS_SETBNK         ; Select bank for DMA operation
 216:     -	        	    JPTBL_ENTRY BIOS_XMOVE          ; Preload banks for MOVE
 217:     -	        	    JPTBL_ENTRY BIOS_USERF          ; System-depedent functions
 218:     -	        	    JPTBL_ENTRY BIOS_RESERV1        ; Reserved
 219:     -	        	    JPTBL_ENTRY BIOS_RESERV2        ; Reserved
 220:				; ZARC-specific items.
 221:     -	        	    JPTBL_BLOCK BIOS_ID, 3          ; BIOS ID ("ZRC")
 222:     -	        	    JPTBL_BLOCK BIOS_VER, 3         ; Version (see below)
 223:     -	        	    JPTBL_ENTRY BIOS_STARTUP        ; CP/M startup entry point
 224:     -	        	    JPTBL_ENTRY BIOS_MON_CALL       ; Call monitor function
 225:     -	        	    JPTBL_ENTRY BIOS_SUPER          ; Set supervisor state
 226:     -	        	    JPTBL_ENTRY BIOS_INT_DISABLE    ; Disable interrupts and keep count
 227:     -	        	    JPTBL_ENTRY BIOS_INT_ENABLE     ; Enable interrupts if safe
 228:     -	        	    JPTBL_ENTRY BIOS_TIRD           ; Read time and date
 229:     -	        	    JPTBL_ENTRY BIOS_SET_TIMER      ; Set timer
 230:     -	        	    JPTBL_ENTRY BIOS_GET_TIMER      ; Get timer
 231:				;
 232:     -	        	    JPTBL_END BIOS_JPTBL_NEXT
 233:				;
 234:				; BIOS_VER is <reserved (zero)>, <major version>, <minor version>. The reserved
 235:				; byte may flag capabilities at some point.
 236:				;
 237:				;
 238:				;
 239:				; **************
 240:				; * BDOS Calls *
 241:				; **************
 242:				;
 243:				;
 244:				; From http://www.gaby.de/cpm/manuals/archive/cpm22htm/ch5.htm#Section_5.2
 245:				; In general, the function number is passed in register C with the information
 246:				; address in the double byte pair DE. Single byte values are returned in register
 247:				; A, with double byte values returned in HL. A zero value is returned when the
 248:				; function number is out of range. For reasons of compatibility, register A = L
 249:				; and register B = H upon return in all cases. Example call:
 250:				;   ld c, BDOS_CONIN    ; Read next character
 251:				;   call BDOS           ; Return character in A
 252:				;
 253:     -	0005'         	BDOS        equ 5               ; BDOS entry point
 254:				;
 255:     -	0000'         	BDOS_SYS_RST        equ 0       ; System Reset
 256:     -	0001'         	BDOS_CON_IN         equ 1       ; Console Input
 257:     -	0002'         	BDOS_CON_OUT        equ 2       ; Console Output
 258:     -	0003'         	BDOS_RDR_IN         equ 3       ; Reader Input
 259:     -	0004'         	BDOS_PUN_OUT        equ 4       ; Punch Output
 260:     -	0005'         	BDOS_LST_OUT        equ 5       ; List Output
 261:     -	0006'         	BDOS_DIRECT_CON_IO  equ 6       ; Direct Console I/O
 262:     -	0007'         	BDOS_GET_IO_BYTE    equ 7       ; Get I/O Byte
 263:     -	0008'         	BDOS_SET_IO_BYTE    equ 8       ; Set I/O Byte
 264:     -	0009'         	BDOS_PRINT_STRING   equ 9       ; Print String
 265:     -	000A'         	BDOS_READ_CON_BUFF  equ 10      ; Read Console Buffer
 266:     -	000B'         	BDOS_GET_CON_STAT   equ 11      ; Get Console Status
 267:     -	000C'         	BDOS_VERSION        equ 12      ; Return Version Number
 268:     -	000D'         	BDOS_RESET_DISK_SYS equ 13      ; Reset Disk System
 269:     -	000E'         	BDOS_SEL_DISK       equ 14      ; Select Disk
 270:     -	000F'         	BDOS_OPEN_FILE      equ 15      ; Open File
 271:     -	0010'         	BDOS_CLOSE_FILE     equ 16      ; Close File
 272:     -	0011'         	BDOS_SEARCH_FIRST   equ 17      ; Search for First
 273:     -	0012'         	BDOS_SEARCH_NEXT    equ 18      ; Search for Next
 274:     -	0013'         	BDOS_DELETE_FILE    equ 19      ; Delete File
 275:     -	0014'         	BDOS_READ_SEQ       equ 20      ; Read Sequential
 276:     -	0015'         	BDOS_WRITE_SEQ      equ 21      ; Write Sequential
 277:     -	0016'         	BDOS_MAKE_FILE      equ 22      ; Make File
 278:     -	0017'         	BDOS_RENAME_FILE    equ 23      ; Rename File
 279:     -	0018'         	BDOS_GET_LOGIN_VEC  equ 24      ; Return Login Vector
 280:     -	0019'         	BDOS_GET_CURR_DISK  equ 25      ; Return Current Disk
 281:     -	001A'         	BDOS_SET_DMA_ADDR   equ 26      ; Set DMA Address
 282:     -	001B'         	BDOS_GET_ALLOC_ADDR equ 27      ; Get Addr (Alloc)
 283:     -	001C'         	BDOS_WRITE_PROT     equ 28      ; Write Protect Disk
 284:     -	001D'         	BDOS_GET_RO_VEC     equ 29      ; Get R/O Vector
 285:     -	001E'         	BDOS_SET_FILE_ATTR  equ 30      ; Set File Attributes
 286:     -	001F'         	BDOS_GET_DPB        equ 31      ; Get Addr (Disk Parms)
 287:     -	0020'         	BDOS_GET_SET_USER   equ 32      ; Set/Get User Code
 288:     -	0021'         	BDOS_READ_RANDOM    equ 33      ; Read Random
 289:     -	0022'         	BDOS_WRITE_RANDOM   equ 34      ; Write Random
 290:     -	0023'         	BDOS_GET_FILE_SIZE  equ 35      ; Compute File Size
 291:     -	0024'         	BDOS_SET_RANDOM_REC equ 36      ; Set Random Record
 292:     -	0025'         	BDOS_RESET_DRIVES   equ 37      ; Selectively reset disc drives
 293:     -	0028'         	BDOS_WRITE_RAN_ZFILL equ 40     ; Write Random with Zero Fill
 294:				
 295:				; Functions 28 and 32 should be avoided in application programs to maintain upward
 296:				; compatibility with CP/M.
 297:				;
 298:				
**** fsck.z80 ****
  61:				                include "terminal.i"    ; Terminal constants
**** /home/merlin/Technical/ZARC_Z80_Box/git/software/includes//terminal.i ****
   1:				; ***********************************
   2:				; * ZARC Terminal Definitions       *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 16/5/2020         *
   5:				; ***********************************
   6:				;
   7:				; Definitions associated with terminals connected to an RS-232 port.
   8:				;
   9:     -	0005'         	ASCII_ENQ           equ 0x05        ; Enquiry
  10:     -	0008'         	ASCII_BS            equ 0x08        ; Backspace
  11:     -	0009'         	ASCII_HT            equ 0x09
  12:     -	000A'         	ASCII_LF            equ 0x0a        ; Line feed
  13:     -	000B'         	ASCII_VT            equ 0x0b        ; Upline (ADM-3A)
  14:     -	000C'         	ASCII_FF            equ 0x0c        ; Forward space (ADM-3A)
  15:     -	000D'         	ASCII_CR            equ 0x0d        ; Carriage return
  16:     -	0016'         	ASCII_SYN           equ 0x16        ; Synchronous idle
  17:     -	001A'         	ASCII_SUB           equ 0x1a        ; Clear screen (ADM-3A)
  18:     -	001B'         	ASCII_ESC           equ 0x1b        ; Escape
  19:     -	001E'         	ASCII_RS            equ 0x1e        ; Home cursor (ADM-3A)
  20:     -	007F'         	ASCII_DEL           equ 0x7f        ; Delete
  21:				;
  22:				; ZARC CP/M terminal input key codes. Some are copied from Amstrad PCW and
  23:				; Spectrum +3, others are unique to ZARC. Delete seems very common.
  24:     -	001F'         	ZKEY_CSR_UP         equ 0x1f        ; Cursor up
  25:     -	001E'         	ZKEY_CSR_DOWN       equ 0x1e        ; Cursor down
  26:     -	0006'         	ZKEY_CSR_RIGHT      equ 0x06        ; Cursor right
  27:     -	0001'         	ZKEY_CSR_LEFT       equ 0x01        ; Cursor left
  28:     -	0002'         	ZKEY_HOME           equ 0x02
  29:     -	0016'         	ZKEY_INSERT         equ 0x16
  30:     -	007F'         	ZKEY_DELETE         equ 0x7f
  31:     -	0004'         	ZKEY_END            equ 0x04
  32:     -	001D'         	ZKEY_PAGE_UP        equ 0x1d
  33:     -	001C'         	ZKEY_PAGE_DOWN      equ 0x1c
  34:				
**** fsck.z80 ****
  62:				                include "fsck.i"        ; Project include file
**** fsck.i ****
   1:				; *******************************************************
   2:				; * CP/M File System Checker                            *
   3:				; * Include file                                        *
   4:				; * Written by: Merlin Skinner                          *
   5:				; * Date Started: 16/2/2022                             *
   6:				; *******************************************************
   7:				;
   8:				;
   9:				;
  10:				; *************
  11:				; * Constants *
  12:				; *************
  13:				;
  14:				;
  15:				; DEBUG           equ 1                   ; Define to enable debugging mode
  16:				;
  17:     -	0040'         	STACK_SIZE      equ 64                  ; Stack space allocation
  18:     -	0003'         	BREAK_CHAR      equ 'C' - 0x40
  19:     -	03C0'         	BDIS_CHARS_MAX  equ (VT100_ROWS / 2) * VT100_COLS ; Maximum display area for block usage display
  20:				;
  21:				; Allocation counter and flags
  22:     -	        	BITDEF ALLCF_UNUSED, 7                  ; Set if any allocation is unused
  23:     -	        	BITDEF ALLCF_SPARSE, 6                  ; Set file contains a hole
  24:				; LS bits serve as a counter.
  25:     -	001F'         	ALLCF_COUNT     equ 0x1f                ; Used allocation counter
  26:				;
  27:				;
  28:				;
  29:				; **************
  30:				; * Structures *
  31:				; **************
  32:				;
  33:				;
  34:				; File information structure. User, name and type must match the directory
  35:				; entry structure (DIRE_xxx).
  36:     -	        	                STRUCT
  37:     -	        	                STR_BYTE FI_USER                    ; User number. 0xe5 if entry unused
  38:     -	        	                STR_BLOCK FI_NAME, FILENAME_SIZE    ; Filename in ASCII upper-case
  39:     -	        	                STR_BLOCK FI_TYP, FILEEXT_SIZE      ; File type
  40:     -	        	                STR_WORD FI_LAST_PEXT               ; Highest physical extent number found
  41:     -	        	                STR_BYTE FI_LAST_RC                 ; RC associated with the extent in FI_LAST_PEXT
  42:     -	        	                STR_BYTE FI_EX_FL_LEN               ; No. of extent flag bytes
  43:     -	        	                STR_BLOCK FI_EX_FLAGS, 0            ; Start of extent flags
  44:     -	        	                STR_END FI_SIZE
  45:				
**** fsck.z80 ****
  63:				                include "cpm_utility.i" ; CP/M utilities
**** /home/merlin/Technical/ZARC_Z80_Box/git/software/includes//cpm_utility.i ****
   1:				; *******************************************************
   2:				; * Utility Routines for CP/M Applications              *
   3:				; * Version: V1.0                                       *
   4:				; * Merlin Skinner, 16/12/2021                          *
   5:				; *******************************************************
   6:				;
   7:				; Note that ld80 only considers the first six characters of labels significant.
   8:				;
   9:     -	0001'         	            ifndef CPMU         ; Inhibit for this module
  10:				; CP/M specific.
  11:				                extern cbdos    ; Call BDOS with some registers saved
  12:				                extern cbios    ; Call BIOS with some registers saved
  13:				                extern panic    ; Fatal application error
  14:				                extern zrcdet   ; Detect ZARC
  15:				                extern z80det   ; Detect Z80 (instead of 8080 / 8085)
  16:				;
  17:				; Derived from the monitor's utility.z80.
  18:				                extern conwch   ; Write character to console
  19:				                extern conrch   ; Read character from the console
  20:				                extern const    ; Fetch console input status
  21:				                extern cwnwln   ; Write new line characters to console
  22:				                extern conwms   ; Print "$" terminated string to the console
  23:				                extern conwmn   ; Print message <n> in a list
  24:				                extern skpspc   ; Step hl past spaces
  25:				                extern toupca   ; Convert character in A to upper case
  26:				                extern toloca   ; Convert character in A to lower case
  27:				                extern cwvich   ; Print only visible 7-bit characters
  28:				                extern cwpspc   ; Print a space
  29:				                extern mtwdli   ; Match word in a string against list of options
  30:				                extern cwphnb   ; Print least-significant nibble in A in hexadecimal
  31:				                extern cwphby   ; Print A in hexadecimal
  32:				                extern cwphwd   ; Print HL in hexadecimal
  33:				                extern cwpdwd   ; Print HL in decimal. Leading zeros are suppressed
  34:				                extern cwpdby   ; Print A in decimal. Leading zeros are suppressed
  35:				                extern cwpdwd   ; Print HL in decimal. Leading zeros are suppressed
  36:				                extern cwpdlo   ; Print DEHL in decimal. Leading zeros are suppressed
  37:				                extern rdhxwd   ; Read a 16-bit hexadecimal number from a string
  38:				                extern rdduwd   ; Read a 16-bit unsigned decimal number from a string
  39:				                extern rddulo   ; Read a 32-bit unsigned decimal number from a string
  40:				;
  41:				            endif
  42:				;
  43:				;
  44:				; mtwdli (match word in a string against list of options) option bits. Each bit
  45:				; has the described effect if set.
  46:     -	        	BITDEF MTWDLI_ABBREV, 0                 ; Enable "." abbreviation
  47:     -	        	BITDEF MTWDLI_ICASE, 1                  ; Ignore case when matching
  48:     -	        	BITDEF MTWDLI_TERM, 7                   ; Terminator found (internal use only)
  49:				
**** fsck.z80 ****
  64:				                include "cpm_terminal.i"; Terminal control
**** /home/merlin/Technical/ZARC_Z80_Box/git/software/includes//cpm_terminal.i ****
   1:				; *******************************************************
   2:				; * Terminal Control Routines for CP/M Applications     *
   3:				; * Version: V1.0                                       *
   4:				; * Merlin Skinner, 16/12/2021                          *
   5:				; *******************************************************
   6:				;
   7:				; These routines provide more complex control over the terminal than is offered
   8:				; by the simple generic character read / write used by the monitor and CP/M.
   9:				;
  10:				; Note that ld80 only considers the first six characters of labels significant.
  11:				;
  12:				; The following conditionals are intended to allow the same include file to be
  13:				; used in the defining module and elsewhere as required. Some includes are used
  14:				; for other applications than the monitor, such as the CP/M BIOS. In these cases,
  15:				; the extern and public statements are not desirable.
  16:				;
  17:     -	0001'         	            ifndef cpm_terminal ; Inhibit for this module
  18:				                extern concap   ; Console capabilities (CONCAP_xxx)
  19:				                extern ccinit   ; Determine terminal capabilities
  20:				                extern cldcur   ; Load cursor position
  21:				                extern conuln   ; Set underline
  22:				                extern conrev   ; Set reverse video
  23:				                extern csrvis   ; Show or hide cursor
  24:				                extern ccls     ; Clear screen
  25:				                extern cscrup   ; Scroll screen up
  26:				            endif
  27:				;
  28:				;
  29:     -	0018'         	VT100_ROWS          equ 24
  30:     -	0050'         	VT100_COLS          equ 80
  31:				;
  32:				;
  33:				; The concap (determine terminal capabilities) routine returns a byte
  34:				; indicating various capabilities of the attached terminal. The bits are
  35:				; defined here.
  36:     -	        	BITDEF CONCAP_ZARC, 0           ; ZARC BIOS present
  37:     -	        	BITDEF CONCAP_ANSI, 1           ; ANSI control codes, e.g. VT100
  38:     -	        	BITDEF CONCAP_UNICODE, 2        ; Terminal is capable of Unicode characters
  39:				;
  40:				; Note that Minicom by default emulates a VT102, and is capable of Unicode. If
  41:				; this terminal is detected, both CONCAP_VT100 and CONCAP_UNICODE are set.
  42:				;
  43:				;
  44:				; ANSI graphical rendition (SGR) codes. From https://en.wikipedia.org/wiki/ANSI_escape_code
  45:     -	0000'         	ANSI_SGR_NORMAL     equ 0           ; All attributes off
  46:     -	0001'         	ANSI_SGR_BOLD       equ 1           ; Bold or increased intensity
  47:     -	0002'         	ANSI_SGR_FAINT      equ 2           ; Faint, decreased intensity, or dim
  48:     -	0004'         	ANSI_SGR_ULINE      equ 4           ; Underline
  49:     -	0005'         	ANSI_SGR_SBLINK     equ 5           ; Slow blink
  50:     -	0006'         	ANSI_SGR_RBLINK     equ 6           ; Rapid blink
  51:     -	0007'         	ANSI_SGR_REV        equ 7           ; Reverse video or invert
  52:     -	0009'         	ANSI_SGR_STRIKE     equ 9           ; Characters legible but marked as if for deletion
  53:     -	000A'         	ANSI_SGR_PRI_FONT   equ 10          ; Primary (default) font
  54:     -	000B'         	ANSI_SGR_FONT_1     equ 11          ; Alternative fonts
  55:     -	000C'         	ANSI_SGR_FONT_2     equ 12
  56:     -	000D'         	ANSI_SGR_FONT_3     equ 13
  57:     -	000E'         	ANSI_SGR_FONT_4     equ 14
  58:     -	000F'         	ANSI_SGR_FONT_5     equ 15
  59:     -	0010'         	ANSI_SGR_FONT_6     equ 16
  60:     -	0011'         	ANSI_SGR_FONT_7     equ 17
  61:     -	0012'         	ANSI_SGR_FONT_8     equ 18
  62:     -	0013'         	ANSI_SGR_FONT_9     equ 19
  63:     -	0014'         	ANSI_SGR_GOTHIC     equ 20          ; Fraktur (Gothic) (not widely supported)
  64:     -	0015'         	ANSI_SGR_DULINE     equ 21          ; Doubly underlined *or* not bold
  65:     -	0016'         	ANSI_SGR_NORM_INTEN equ 22          ; Normal intensity
  66:     -	0017'         	ANSI_SGR_ITAL_OFF   equ 23          ; Neither italic, nor blackletter
  67:     -	0018'         	ANSI_SGR_ULINE_OFF  equ 24          ; Underline off
  68:     -	0019'         	ANSI_SGR_BLINK_OFF  equ 25          ; Blinking off
  69:     -	001B'         	ANSI_SGR_REV_OFF    equ 27          ; Reverse image off
  70:     -	001C'         	ANSI_SGR_HIDE_OFF   equ 28          ; Reveal (not concealed)
  71:     -	001D'         	ANSI_SGR_STRIKE_OFF equ 29
  72:				
**** fsck.z80 ****
  65:				                include "cpm_top.i"     ; CP/M dummy top module
**** /home/merlin/Technical/ZARC_Z80_Box/git/software/includes//cpm_top.i ****
   1:				; *******************************************************
   2:				; * Dummy Module to find the Last Location in Use.      *
   3:				; * Version: V1.0                                       *
   4:				; * Merlin Skinner, 16/12/2021                          *
   5:				; *******************************************************
   6:				;
   7:				; Note that ld80 only considers the first six characters of labels significant.
   8:				;
   9:				                extern fstfre       ; First location after end of data segment
  10:				
**** fsck.z80 ****
  66:				;
  67:				;
  68:				;
  69:				; *************
  70:				; * Externals *
  71:				; *************
  72:				;
  73:				;
  74:				; Variables
  75:				;                public brkflg   ; Non-zero if break character detected
  76:				;
  77:				;
  78:				;
  79:				; *************
  80:				; * Main Code *
  81:				; *************
  82:				;
  83:				;
  84:				; The CP/M transient area start address is set in the linker invokation (see makefile).
  85:				                cseg                    ; Code segment
  86:				;
  87:				; The default stack space is very small (8 deep), which would almost certainly
  88:				; cause issues, particularly with interrupts running. The initial code should
  89:				; not assume a Z80 so we can exit cleanly if this is run on something else.
  90:    0+20	0000' ED730000	                ld (bdos_sp), sp
  91:   20+10	0004' 317100  	                ld sp, app_stack_top    ; Switch to our stack space
  92:				;
  93:				; Determine CPU type.
  94:   30+17	0007' CD0000  	                call z80det             ; Detect Z80 (instead of 8080 / 8085)
  95:   47+10	000A' D21800  	                jp nc, on_z80           ; Jump if we have a Z80
  96:				;
  97:				; 8080 / 8085 detected. Print message and exit. We can't use conwms as this
  98:				; assumes a Z80.
  99:   57+10	000D' 115C07  	                ld de, no_z80_msg       ; "Z80 CPU required"
 100:   67+7	0010' 0E09    	                ld c, BDOS_PRINT_STRING ; Print String
 101:   74+17	0012' CD0500  	                call BDOS
 102:   91+10	0015' C30000  	                jp 0                    ; Warm boot
 103:				;
 104:				; Sign on.
 105:  101+10	0018' 213207  	on_z80          ld hl, signon_msg
 106:  111+17	001B' CD0000  	                call conwms             ; Print $-terminated string to console
 107:				;
 108:				; Examine the command tail, looking for operands. This is stored in the default
 109:				; buffer. "The first byte at 0080H contains the length of the command tall, while
 110:				; the command tail itself begins at 0081H. The command tail is terminated by a
 111:				; byte containing a binary zero value." (http://www.cpm.z80.de/manuals/cpm22-m.pdf
 112:				; appendix H).
 113:  128+10	001E' 218100  	                ld hl, DEF_BUFFER + 1
 114:  138+17	0021' CD0000  	                call skpspc             ; Skip spaces
 115:  155+7	0024' 7E      	                ld a, (hl)              ; This should be a drive letter
 116:  162+6	0025' 23      	                inc hl
 117:     -	0000'         	                ifdef DEBUG
 119:				                endif
 120:  168+7	0026' D641    	                sub "A"                 ; Convert to a number
 121:				; If this carries, the byte is not a letter. It may be the zero terminator, if no
 122:				; operand were supplied.
 123:  175+7+5	0028' 3846    	                jr c, op_error
 124:  182+7	002A' FE10    	                cp NUM_DISKS_MAX
 125:  189+7+5	002C' 3042    	                jr nc, op_error
 126:				; We have a valid drive number.
 127:  196+13	002E' 320200  	                ld (drive), a           ; Save it
 128:				;
 129:				; A following colon is optional.
 130:  209+7	0031' 7E      	                ld a, (hl)
 131:  216+7	0032' FE3A    	                cp ":"
 132:  223+7+5	0034' 2001    	                jr nz, op_options
 133:  230+6	0036' 23      	                inc hl                  ; Step past colon
 134:				;
 135:				; Set default options. These may be modified as the command tail is processed.
 136:  236+4	0037' AF      	op_options      xor a
 137:  240+13	0038' 320300  	                ld (scan_enable), a     ; Disable surface scan
 138:				;
 139:				; Check for options. These may begin with "[", "/" or "$", to match all
 140:				; conventions I have found used with CP/M.
 141:  253+17	003B' CD0000  	                call skpspc             ; Skip spaces
 142:				; Options 
 143:  270+7	003E' 7E      	                ld a, (hl)
 144:  277+6	003F' 23      	                inc hl
 145:  283+4	0040' 4F      	                ld c, a                 ; Save for later
 146:  287+4	0041' A7      	                and a
 147:  291+7+5	0042' 2832    	                jr z, operands_ok       ; Jump if no options
 148:  298+7	0044' FE5B    	                cp "["
 149:  305+7+5	0046' 2808    	                jr z, op_found
 150:  312+7	0048' FE2F    	                cp "/"
 151:  319+7+5	004A' 2804    	                jr z, op_found
 152:  326+7	004C' FE24    	                cp "$"
 153:  333+7+5	004E' 2020    	                jr nz, op_error         ; Jump if not an option
 154:				; Option introducer found.
 155:				; C - option character
 156:				; HL - pointer to command tail
 157:  340+7	0050' 7E      	op_found        ld a, (hl)
 158:  347+6	0051' 23      	                inc hl
 159:  353+4	0052' A7      	                and a
 160:  357+7+5	0053' 281B    	                jr z, op_error          ; Error if option missing
 161:				; At present, there is just one option.
 162:  364+7	0055' FE53    	                cp "S"
 163:  371+7+5	0057' 2017    	                jr nz, op_error         ; C
 164:				; "S" option enables surface scan.
 165:  378+7	0059' 3EFF    	                ld a, 0xff
 166:  385+13	005B' 320300  	                ld (scan_enable), a     ; Enable surface scan
 167:				; Options processed. Check for "]" if appropriate.
 168:  398+4	005E' 79      	                ld a, c
 169:  402+7	005F' FE5B    	                cp "["
 170:  409+7+5	0061' 2006    	                jr nz, op_check_term    ; Jump if we didn't start with "["
 171:  416+7	0063' 7E      	                ld a, (hl)
 172:  423+6	0064' 23      	                inc hl
 173:  429+7	0065' FE5D    	                cp "]"
 174:  436+7+5	0067' 2007    	                jr nz, op_error         ; Jump if terminator or anything else
 175:				;
 176:				; The terminator should follow.
 177:  443+17	0069' CD0000  	op_check_term   call skpspc             ; Skip spaces
 178:  460+7	006C' 7E      	                ld a, (hl)
 179:     -	0000'         	                ifdef DEBUG
 181:				                endif
 182:  467+4	006D' A7      	                and a
 183:  471+7+5	006E' 2806    	                jr z, operands_ok
 184:				;
 185:				; Go here if we don't like the operands supplied.
 186:  478+10	0070' 216F07  	op_error        ld hl, op_err_msg
 187:  488+10	0073' C3E504  	                jp msg_exit
 188:				;
 189:				; Operand processing complete.
 190:  498+7	0076' 0E0D    	operands_ok     ld c, BDOS_RESET_DISK_SYS   ; Reset Disk System
 191:  505+17	0078' CD0000  	                call cbdos              ; Call BDOS with some registers saved
 192:				; Both the above reset and the reboot at the end of this application should
 193:				; make it safe to test any drive regardless of its logged in status.
 194:				;
 195:				; Select the drive to analyse.
 196:  522+13	007B' 3A0200  	                ld a, (drive)
 197:  535+4	007E' 4F      	                ld c, a
 198:  539+10	007F' 110000  	                ld de, 0                ; Treat disk as new to the system
 199:  549+10	0082' 211800  	                ld hl, BIOS_SELDSK      ; Select disc drive
 200:  559+17	0085' CD0000  	                call cbios              ; Call BIOS with some registers saved
 201:				;HL - pointer to Disc Parameter Header (DPH) or zero on error.
 202:  576+4	0088' 7C      	                ld a, h
 203:  580+4	0089' B5      	                or l
 204:  584+7+5	008A' 2009    	                jr nz, drive_sel_ok
 205:				; Can't select drive.
 206:  591+10	008C' 21D107  	                ld hl, sel_err_msg
 207:  601+17	008F' CD0000  	                call conwms             ; Print $-terminated string to console
 208:  618+10	0092' C3E804  	                jp exit
 209:     -	0095'         	drive_sel_ok
 210:				;
 211:				; Find address of DPB.
 212:  628+16	0095' 221900  	                ld (dph), hl            ; Save for later
 213:  644+10	0098' 110A00  	                ld de, DPH_DPB          ; Offset to pointer to DPB
 214:  654+11	009B' 19      	                add hl, de
 215:  665+7	009C' 5E      	                ld e, (hl)              ; Fetch pointer
 216:  672+6	009D' 23      	                inc hl
 217:  678+7	009E' 56      	                ld d, (hl)
 218:  685+20	009F' ED531B00	                ld (dpb), de            ; Save for later
 219:  705+11	00A3' D5      	                push de
 220:  716+14	00A4' DDE1    	                pop ix
 221:				; IX - pointer to DPB (DPB_xxx)
 222:				;
 223:				; Initialise variables.
 224:  730+10	00A6' 210000  	                ld hl, 0                ; Directory entry number
 225:  740+16	00A9' 221100  	                ld (file_count), hl     ; Reset counts
 226:  756+16	00AC' 221300  	                ld (unused_count), hl
 227:  772+16	00AF' 221500  	                ld (blocks_used), hl
 228:  788+16	00B2' 220F00  	                ld (error_count), hl
 229:				;
 230:				; Initialise buffers.
 231:				; Set start of flags to first location after this programme and its variables.
 232:  804+10	00B5' 210000  	                ld hl, fstfre           ; First location after end of data
 233:  814+16	00B8' 220400  	                ld (blk_flags), hl
 234:				;
 235:				; Calculate the number of blocks on disk. This will determine blk_flags_size,
 236:				; which requires one bit per block.
 237:  830+19	00BB' DD6E05  	                ld l, (ix + DPB_DSM)    ; Maximum block number
 238:  849+19	00BE' DD6606  	                ld h, (ix + DPB_DSM + 1)
 239:				; Number of bytes required is (DSM/8) + 1
 240:  868+7	00C1' 0603    	                ld b, 3
 241:  875+8	00C3' CB3C    	init_blk_div    srl h
 242:  883+8	00C5' CB1D    	                rr l
 243:  891+8+5	00C7' 10FA    	                djnz init_blk_div
 244:  899+6	00C9' 23      	                inc hl
 245:				; HL - number of bytes.
 246:  905+16	00CA' 220600  	                ld (blk_flags_size), hl
 247:				;
 248:				; Mark all blocks as free.
 249:  921+4	00CD' 44      	                ld b, h
 250:  925+4	00CE' 4D      	                ld c, l
 251:  929+16	00CF' 2A0400  	                ld hl, (blk_flags)
 252:  945+4	00D2' 78      	bfc_loop        ld a, b
 253:  949+4	00D3' B1      	                or c
 254:  953+7+5	00D4' 280C    	                jr z, bfc_done          ; Exit if done
 255:  960+17	00D6' CDCF05  	                call chk_mem_lim        ; Check HL is not too high
 256:  977+10	00D9' DAE204  	                jp c, out_of_memory
 257:  987+10	00DC' 3600    	                ld (hl), 0
 258:  997+6	00DE' 23      	                inc hl
 259: 1003+6	00DF' 0B      	                dec bc
 260: 1009+12	00E0' 18F0    	                jr bfc_loop
 261:				;
 262:				; Initialise file information area pointers.
 263:				; HL - first location after block flags.
 264: 1021+17	00E2' CDCF05  	bfc_done        call chk_mem_lim        ; Check HL is not too high
 265: 1038+10	00E5' DAE204  	                jp c, out_of_memory
 266: 1048+16	00E8' 220800  	                ld (files_info), hl     ; Set start address of FI structures
 267: 1064+16	00EB' 220A00  	                ld (free_start), hl     ; No files yet
 268:				; As files are discovered, files_info will grow by FI_SIZE each time. In
 269:				; addition, it will grow by a single byte each time more physical extent flags
 270:				; are required for any file.
 271:				;
 272:				; The directory starts at the beginning of the first track of the
 273:				; data area. There are DRM + 1 directory entries.
 274:				; Calculate the number of blocks used by the directory. This is given by
 275:				; the number of high bits set in DPB.AL0 and DPB.AL1. Reference:
 276:				; http://www.gaby.de/cpm/manuals/archive/cpm22htm/ch6.htm#Figure_6-5
 277: 1080+19	00EE' DD6609  	                ld h, (ix + DPB_AL0)    ; Fetch directory allocation bits
 278: 1099+19	00F1' DD6E0A  	                ld l, (ix + DPB_AL1)
 279:				; Count the "1" bits.
 280: 1118+7	00F4' 0610    	                ld b, 16                ; Bit counter
 281: 1125+7	00F6' 0E00    	                ld c, 0
 282: 1132+8	00F8' CB7C    	id_al_loop      bit 7, h                ; Test MS bit
 283: 1140+7+5	00FA' 2804    	                jr z, id_al_done        ; Exit if "0" found
 284: 1147+4	00FC' 0C      	                inc c                   ; Count 1 bits
 285: 1151+11	00FD' 29      	                add hl, hl              ; Shift left
 286: 1162+8+5	00FE' 10F8    	                djnz id_al_loop
 287:				; We end up here if either all bits are tested or a "0" bit was encountered.
 288: 1170+4	0100' 79      	id_al_done      ld a, c
 289: 1174+13	0101' 320E00  	                ld (dir_blocks), a
 290: 1187+4	0104' A7      	                and a
 291: 1191+10+7	0105' CC0000  	                call z, panic           ; Panic if directory has no blocks
 292:				;
 293:				; Mark the directory blocks as used.
 294:				; C - number of directory blocks
 295: 1201+10	0108' 210000  	                ld hl, 0                ; Directory starts at block 0
 296: 1211+4	010B' 41      	                ld b, c
 297: 1215+11	010C' E5      	id_mark_used_lp push hl
 298: 1226+17	010D' CD4E05  	                call flag_block         ; Mark block used
 299: 1243+10+7	0110' DC0000  	                call c, panic           ; Panic if already used
 300: 1253+10	0113' E1      	                pop hl
 301: 1263+6	0114' 23      	                inc hl
 302: 1269+8+5	0115' 10F5    	                djnz id_mark_used_lp
 303:				; 
 304:				; IX - pointer to DPB (DPB_xxx)
 305: 1277+10	0117' 21FFFF  	                ld hl, 0xffff
 306: 1287+16	011A' 220C00  	                ld (loaded_sector), hl  ; Set no sector loaded.
 307:				;
 308:				; Scan each entry, looking for valid-looking entries.
 309: 1303+10	011D' 210000  	                ld hl, 0                ; Start at first entry
 310: 1313+16	0120' 222100  	scan_loop       ld (dir_entry_num), hl  ; Loop counter
 311: 1329+17	0123' CDA106  	                call get_entry
 312:				; HL - points to start of entry
 313: 1346+11	0126' E5      	                push hl                 ; Move address to IY
 314: 1357+14	0127' FDE1    	                pop iy
 315: 1371+20	0129' FD221D00	                ld (dire), iy           ; Save pointer to directory entry structure
 316:				;
 317:				; *** Examine the directory entry ***
 318:				; IX - pointer to DPB (DPB_xxx)
 319:				; IY - pointer to directory entry structure (DIRE_xxx)
 320: 1391+19	012D' FD7E00  	                ld a, (iy + DIRE_USER)
 321: 1410+7	0130' FEE5    	                cp 0xe5
 322: 1417+7+5	0132' 200A    	                jr nz, sl_not_unused
 323:				; This is an unused entry.
 324: 1424+16	0134' 2A1300  	                ld hl, (unused_count)
 325: 1440+6	0137' 23      	                inc hl
 326: 1446+16	0138' 221300  	                ld (unused_count), hl
 327: 1462+10	013B' C3E802  	                jp sl_entry_done        ; Entry done
 328:				;
 329:				; Calculate physical extent. Adapted from
 330:				; https://www.seasip.info/Cpm/format22.html:
 331:				; An extent is the portion of a file controlled by one directory entry. If a
 332:				; file takes up more blocks than can be listed in one directory entry, it is
 333:				; given multiple entries, distinguished by their EX and S2 bytes.  A logical
 334:				; extent is always 16 KB long, but there can be multiple logical extents in a
 335:				; physical extent (directory entry). This is defined by DPB.EXM. The formula
 336:				; is: directory number (physical extent) = ((32 * S2) + EX) / (exm + 1) where
 337:				; EXM is the extent mask value from the Disc Parameter Block.
 338: 1472+19	013E' FD6E0E  	sl_not_unused   ld l, (iy + DIRE_S2)        ; Extent counter, high byte
 339: 1491+7	0141' 2600    	                ld h, 0
 340: 1498+11	0143' 29      	                add hl, hl
 341: 1509+11	0144' 29      	                add hl, hl
 342: 1520+11	0145' 29      	                add hl, hl
 343: 1531+11	0146' 29      	                add hl, hl
 344: 1542+11	0147' 29      	                add hl, hl
 345:				; HL is (32 * S2)
 346: 1553+19	0148' FD5E0C  	                ld e, (iy + DIRE_EX)    ; Extent counter, low byte (0-31)
 347: 1572+7	014B' 1600    	                ld d, 0
 348: 1579+11	014D' 19      	                add hl, de
 349:				; HL is (32 * S2) + EX
 350: 1590+19	014E' DD4E04  	                ld c, (ix + DPB_EXM)    ; Extent mask
 351:				; A is 0, 1, 3, 7 or 15. We need to divide by one greater than each of these.
 352: 1609+4	0151' 79      	sl_calc_ext_lp  ld a, c
 353: 1613+4	0152' A7      	                and a
 354: 1617+7+5	0153' 2808    	                jr z, sl_calc_ext_dn
 355: 1624+8	0155' CB3C    	                srl h                   ; Divide by two
 356: 1632+8	0157' CB1D    	                rr l
 357: 1640+8	0159' CB39    	                srl c                   ; Reduce mask
 358: 1648+12	015B' 18F4    	                jr sl_calc_ext_lp
 359:				; HL - physical extent
 360: 1660+16	015D' 221700  	sl_calc_ext_dn  ld (phys_extent), hl    ; Save calculated extent
 361:				;
 362:				; Check user number
 363: 1676+10	0160' 110E09  	                ld de, bad_user_msg     ; " - bad user number"
 364: 1686+19	0163' FD7E00  	                ld a, (iy + DIRE_USER)
 365: 1705+7	0166' FE10    	                cp MAX_USER + 1
 366: 1712+10+7	0168' D4F504  	                call nc, sl_err_cont    ; Report any error and continue
 367:				;
 368:				; Check name. A flag is used to avoid one error message per bad character.
 369: 1722+15	016B' FDE5    	sl_user_ok      push iy
 370: 1737+10	016D' E1      	                pop hl
 371: 1747+10	016E' 010100  	                ld bc, DIRE_NAME
 372: 1757+11	0171' 09      	                add hl, bc
 373:				; HL - start address of name.
 374: 1768+7	0172' 0608    	                ld b, FILENAME_SIZE
 375: 1775+7	0174' 0E00    	                ld c, 0                 ; Error flag
 376: 1782+7	0176' 7E      	sl_name_chk     ld a, (hl)
 377: 1789+7	0177' FE20    	                cp ' '
 378: 1796+10+7	0179' DC4B05  	                call c, set_c_reg       ; < ' ' is a control character
 379: 1806+7	017C' FE7F    	                cp ascii_del
 380: 1813+10+7	017E' D44B05  	                call nc, set_c_reg      ; >= DEL isn't visible either
 381: 1823+6	0181' 23      	                inc hl
 382: 1829+8+5	0182' 10F2    	                djnz sl_name_chk
 383:				;
 384:				; Check type.
 385: 1837+19	0184' FD7E09  	                ld a, (iy + DIRE_TYP)
 386: 1856+7	0187' E67F    	                and 0x7f                ; Ignore read-only bit
 387: 1863+7	0189' FE20    	                cp ' '
 388: 1870+10+7	018B' DC4B05  	                call c, set_c_reg       ; < ' ' is a control character
 389: 1880+7	018E' FE7F    	                cp ascii_del
 390: 1887+10+7	0190' D44B05  	                call nc, set_c_reg      ; >= DEL isn't visible either
 391:				;
 392: 1897+19	0193' FD7E0A  	                ld a, (iy + DIRE_TYP + 1)
 393: 1916+7	0196' E67F    	                and 0x7f                ; Ignore system file bit
 394: 1923+7	0198' FE20    	                cp ' '
 395: 1930+10+7	019A' DC4B05  	                call c, set_c_reg       ; < ' ' is a control character
 396: 1940+7	019D' FE7F    	                cp ascii_del
 397: 1947+10+7	019F' D44B05  	                call nc, set_c_reg      ; >= DEL isn't visible either
 398:				;
 399: 1957+19	01A2' FD7E0B  	                ld a, (iy + DIRE_TYP + 2)
 400:				; Bit 7 has no defined meaning for this character.
 401: 1976+7	01A5' FE20    	                cp ' '
 402: 1983+10+7	01A7' DC4B05  	                call c, set_c_reg       ; < ' ' is a control character
 403: 1993+7	01AA' FE7F    	                cp ascii_del
 404: 2000+10+7	01AC' D44B05  	                call nc, set_c_reg      ; >= DEL isn't visible either
 405:				;
 406:				; Report error if one or more issues were found.
 407: 2010+10	01AF' 112109  	                ld de, bad_name_msg     ; " - bad file name"
 408: 2020+4	01B2' 79      	                ld a, c
 409: 2024+4	01B3' A7      	                and a
 410: 2028+10+7	01B4' C4F504  	                call nz, sl_err_cont    ; Report any error and continue
 411:				;
 412:				; Check extent counter.
 413: 2038+10	01B7' 113209  	                ld de, bad_ex_cnt_msg   ; " - bad extent count"
 414: 2048+19	01BA' FD7E0C  	                ld a, (iy + DIRE_EX)    ; Extent counter, low byte (0-31)
 415: 2067+7	01BD' FE20    	                cp 32
 416: 2074+10+7	01BF' D4F504  	                call nc, sl_err_cont    ; Report any error and continue
 417:				;
 418:				; Check S1.
 419: 2084+10	01C2' 114609  	                ld de, bad_s1_msg       ; " - bad S1"
 420: 2094+19	01C5' FD7E0D  	                ld a, (iy + DIRE_S1)    ; Reserved, set to 0
 421: 2113+4	01C8' A7      	                and a
 422: 2117+10+7	01C9' C4F504  	                call nz, sl_err_cont    ; Report any error and continue
 423:				;
 424:				; *** Look for the file in the file information structure buffer ***
 425: 2127+20	01CC' DD2A0800	                ld ix, (files_info)     ; Start address of FI structures
 426:				; IX - address in files_info structure.
 427: 2147+20	01D0' ED5B0A00	sl_find_loop    ld de, (free_start)     ; First free location
 428: 2167+15	01D4' DDE5    	                push ix
 429: 2182+10	01D6' E1      	                pop hl
 430: 2192+4	01D7' A7      	                and a
 431: 2196+15	01D8' ED52    	                sbc hl, de
 432: 2211+10	01DA' D2F601  	                jp nc, slf_no_match     ; Jump if buffer exhausted
 433:				; There is an entry to examine.
 434: 2221+15	01DD' DDE5    	                push ix
 435: 2236+10	01DF' D1      	                pop de
 436: 2246+15	01E0' FDE5    	                push iy
 437: 2261+10	01E2' E1      	                pop hl
 438:				; DE - pointer to file information structure.
 439:				; HL - pointer to directory entry structure.
 440: 2271+17	01E3' CD7606  	                call match_files
 441:				; Carry flag set if files don't match.
 442: 2288+7+5	01E6' 3049    	                jr nc, slf_found_fi     ; Matching structure found
 443:				;
 444:				; Advance pointer by the length of this structure. We must include the length
 445:				; of the extent flags section (FI_EX_FL_LEN).
 446: 2295+19	01E8' DD5E0F  	                ld e, (ix + FI_EX_FL_LEN)
 447: 2314+7	01EB' 1600    	                ld d, 0
 448:				; DE - extent flags length.
 449: 2321+15	01ED' DD19    	                add ix, de              ; Add length to base
 450: 2336+10	01EF' 111000  	                ld de, FI_SIZE
 451: 2346+15	01F2' DD19    	                add ix, de              ; Add structure size
 452: 2361+12	01F4' 18DA    	                jr sl_find_loop
 453:				;
 454:				; File information structure buffer seach complete and no matching entry was
 455:				; found. Create a new entry.
 456: 2373+16	01F6' 2A0A00  	slf_no_match    ld hl, (free_start)     ; Insert point
 457: 2389+10	01F9' 111000  	                ld de, FI_SIZE          ; Number of bytes required
 458: 2399+17	01FC' CDDC05  	                call fi_make_room       ; Make room in the FI structures store
 459: 2416+10	01FF' DAE204  	                jp c, out_of_memory
 460:				;
 461:				; Copy the relevant fields.
 462: 2426+11	0202' E5      	                push hl
 463: 2437+14	0203' DDE1    	                pop ix
 464: 2451+15	0205' FDE5    	                push iy
 465: 2466+10	0207' D1      	                pop de
 466:				; HL & IX - pointer to file information structure (FI_xxx)
 467:				; DE & IY - pointer to directory entry structure (DIRE_xxx)
 468:				; Copy user number.
 469:     -	0001'         	                assert FI_USER = 0
 470:     -	0001'         	                assert DIRE_USER = 0
 471: 2476+7	0208' 1A      	                ld a, (de)
 472: 2483+7	0209' 77      	                ld (hl), a
 473: 2490+6	020A' 13      	                inc de
 474: 2496+6	020B' 23      	                inc hl
 475:				;
 476:				; Copy filename.
 477:     -	0001'         	                assert FI_NAME = 1
 478:     -	0001'         	                assert DIRE_NAME = 1
 479: 2502+7	020C' 0608    	                ld b, FILENAME_SIZE
 480: 2509+7	020E' 1A      	slf_name_loop   ld a, (de)
 481: 2516+7	020F' 77      	                ld (hl), a
 482: 2523+6	0210' 13      	                inc de
 483: 2529+6	0211' 23      	                inc hl
 484: 2535+8+5	0212' 10FA    	                djnz slf_name_loop
 485:				;
 486:				; Copy type. Ignore read-only and hidden flags.
 487:     -	0001'         	                assert FI_TYP = 9
 488:     -	0001'         	                assert DIRE_TYP = 9
 489: 2543+7	0214' 0603    	                ld b, FILEEXT_SIZE
 490: 2550+7	0216' 1A      	slf_typ_loop    ld a, (de)
 491: 2557+7	0217' E67F    	                and 0x7f
 492: 2564+7	0219' 77      	                ld (hl), a
 493: 2571+6	021A' 13      	                inc de
 494: 2577+6	021B' 23      	                inc hl
 495: 2583+8+5	021C' 10F8    	                djnz slf_typ_loop
 496:				;
 497: 2591+19	021E' DD360F00	                ld (ix + FI_EX_FL_LEN), 0   ; No flags initially
 498: 2610+19	0222' DD360C00	                ld (ix + FI_LAST_PEXT), 0   ; Last extent
 499: 2629+19	0226' DD360D00	                ld (ix + FI_LAST_PEXT + 1), 0   ; Last extent
 500:				;
 501:				; Count new files.
 502: 2648+16	022A' 2A1100  	                ld hl, (file_count)
 503: 2664+6	022D' 23      	                inc hl
 504: 2670+16	022E' 221100  	                ld (file_count), hl
 505:				;
 506:				; Go here after either locating an existing structure, or creating a new one.
 507:				; IX - pointer to file information structure.
 508:				; IY - pointer to directory entry structure (DIRE_xxx)
 509: 2686+20	0231' DD221F00	slf_found_fi    ld (fie), ix            ; Save pointer to file information structure
 510:				; IX - pointer to file information structure (FI_xxx)
 511:				; IY - pointer to directory entry structure (DIRE_xxx)
 512:				;
 513:				; Set the relevant physical extent flag, expanding the length of the extent
 514:				; flags if required.
 515: 2706+16	0235' 2A1700  	                ld hl, (phys_extent)    ; Fetch extent number
 516: 2722+17	0238' CD8305  	                call flag_extent        ; Mark block used
 517: 2739+10	023B' 115009  	                ld de, ext_dup_msg      ; " - duplicated physical extent"
 518: 2749+10	023E' DAFF02  	                jp c, sl_err_stop       ; Error and stop if already used
 519:				;
 520:				; Mark the blocks used. Entries may be 8 or 16-bit, depending on the number of
 521:				; blocks on the disk.
 522: 2759+20	0241' DD2A1B00	slf_ext_done    ld ix, (dpb)
 523: 2779+7	0245' 0E00    	                ld c, 0                 ; Reset flags (ALLCF_xxx) and counter
 524:				; IX - pointer to DPB (DPB_xxx)
 525:				; IY - pointer to directory entry structure (DIRE_xxx)
 526:				; C - flags and counter
 527: 2786+19	0247' DD7E06  	                ld a, (ix + DPB_DSM + 1)    ; Fetch MS byte of DSM
 528: 2805+4	024A' A7      	                and a
 529: 2809+7+5	024B' 2825    	                jr z, slf_bytes         ; Jump if < 256 blocks
 530:				;
 531:				; The maximum block number is >= 256, so the allocation list is in words.
 532: 2816+7	024D' 0608    	                ld b, 8
 533: 2823+19	024F' FD6E10  	slf_wd_alu_lp   ld l, (iy + DIRE_ALLOC) ; Fetch next allocation
 534: 2842+19	0252' FD6611  	                ld h, (iy + DIRE_ALLOC + 1)
 535: 2861+4	0255' 7C      	                ld a, h
 536: 2865+4	0256' B5      	                or l
 537: 2869+7+5	0257' 2004    	                jr nz, slf_wd_alu_used
 538:				; Unused entry.
 539: 2876+8	0259' CBF9    	                set ALLCF_UNUSED_BIT, c ; Flag unused entry found
 540: 2884+12	025B' 180D    	                jr slf_wd_alu_dn
 541:				; Used entry.
 542: 2896+4	025D' 0C      	slf_wd_alu_used inc c                   ; Keep count
 543: 2900+17	025E' CD4E05  	                call flag_block         ; Mark block used
 544: 2917+10	0261' DAFF02  	                jp c, sl_err_stop       ; Error if already used
 545: 2927+8	0264' CB79    	                bit ALLCF_UNUSED_BIT, c
 546: 2935+7+5	0266' 2802    	                jr z, slf_wd_alu_dn     ; Jump if no unused entries encountered
 547:				; This used entry is preceeded by an unused one. This means we have a holed, or
 548:				; "sparse" file.
 549: 2942+8	0268' CBF1    	                set ALLCF_SPARSE_BIT, c ; Hole detected
 550:				;
 551:				; Allocation entry done.
 552: 2950+10	026A' FD23    	slf_wd_alu_dn   inc iy
 553: 2960+10	026C' FD23    	                inc iy
 554: 2970+8+5	026E' 10DF    	                djnz slf_wd_alu_lp
 555: 2978+12	0270' 1820    	                jr slf_alu_dn
 556:				;
 557:				; The maximum block number is < 256, so the allocation list is in bytes.
 558: 2990+7	0272' 0610    	slf_bytes       ld b, 16
 559: 2997+19	0274' FD7E10  	slf_by_alu_lp   ld a, (iy + DIRE_ALLOC) ; Fetch next allocation
 560: 3016+4	0277' A7      	                and a
 561: 3020+7+5	0278' 2004    	                jr nz, slf_by_alu_used
 562:				; Unused entry.
 563: 3027+8	027A' CBF9    	                set ALLCF_UNUSED_BIT, c ; Flag unused entry found
 564: 3035+12	027C' 1810    	                jr slf_by_alu_dn
 565:				; Used entry.
 566: 3047+4	027E' 0C      	slf_by_alu_used inc c                   ; Keep count
 567: 3051+7	027F' 2600    	                ld h, 0
 568: 3058+4	0281' 6F      	                ld l, a
 569: 3062+17	0282' CD4E05  	                call flag_block         ; Mark block used
 570: 3079+10	0285' DAFF02  	                jp c, sl_err_stop       ; Error if already used
 571: 3089+8	0288' CB79    	                bit ALLCF_UNUSED_BIT, c
 572: 3097+7+5	028A' 2802    	                jr z, slf_by_alu_dn     ; Jump if no unused entries encountered
 573:				; This used entry is preceeded by an unused one. This means we have a holed, or
 574:				; "sparse" file.
 575: 3104+8	028C' CBF1    	                set ALLCF_SPARSE_BIT, c ; Hole detected
 576:				;
 577:				; Allocation entry done.
 578: 3112+10	028E' FD23    	slf_by_alu_dn   inc iy
 579: 3122+8+5	0290' 10E2    	                djnz slf_by_alu_lp
 580:				;
 581:				; Blocks flagged appropriately.
 582: 3130+20	0292' FD2A1D00	slf_alu_dn      ld iy, (dire)           ; Restore pointer to directory entry structure
 583: 3150+8	0296' CB71    	                bit ALLCF_SPARSE_BIT, c
 584:				; A sparse file (one with a hole) is not necessarily an error, as discussed in
 585:				; http://www.gaby.de/cpm/manuals/archive/cpm22htm/ch5.htm function 35 (description).
 586: 3158+10	0298' 118209  	                ld de, sparse_msg       ; " - is sparse (holed) [warning]"
 587: 3168+10+7	029B' C4F504  	                call nz, sl_err_cont    ; Error if hole detected
 588:				;
 589:				; Check for blocks with no allocations at all.
 590: 3178+4	029E' 79      	                ld a, c
 591: 3182+7	029F' E61F    	                and ALLCF_COUNT         ; Isolate count
 592: 3189+10	02A1' 11BE09  	                ld de, no_alloc_msg     ; " - no allocations in physical extent [warning]"
 593: 3199+10+7	02A4' CCF504  	                call z, sl_err_cont     ; Error if no allocations
 594:				;
 595:				; Checking record count (RC). This should be 0x80 (128 * 128 = 18 KB) for
 596:				; anything but the last extent. Note that FI_LAST_PEXT could be derived from
 597:				; the bitmap, but it is easier to store it.
 598:				; Note: the illegal case PEXT = FI_LAST_PEXT will be picked up in the extent
 599:				; flagging code.
 600: 3209+20	02A7' DD2A1F00	                ld ix, (fie)            ; Fetch pointer to file information structure
 601:				; IX - pointer to file information structure (FI_xxx)
 602:				; IY - pointer to directory entry structure (DIRE_xxx)
 603: 3229+16	02AB' 2A1700  	                ld hl, (phys_extent)
 604: 3245+19	02AE' DD5E0C  	                ld e, (ix + FI_LAST_PEXT)   ; Last extent
 605: 3264+19	02B1' DD560D  	                ld d, (ix + FI_LAST_PEXT + 1)
 606: 3283+4	02B4' A7      	                and a
 607: 3287+15	02B5' ED52    	                sbc hl, de
 608: 3302+7+5	02B7' 300D    	                jr nc, slfrc_not_last
 609:				; Not the highest extent found so far, so RC should be 0x80.
 610: 3309+19	02B9' FD7E10  	                ld a, (iy + DIRE_ALLOC)
 611: 3328+7	02BC' FE80    	                cp 0x80
 612: 3335+10	02BE' 11ED09  	                ld de, bad_rc_msg       ; " - RC not 0x80 in intermediate extent"
 613: 3345+10+7	02C1' C4F504  	                call nz, sl_err_cont
 614: 3355+12	02C4' 1822    	                jr slfrc_done
 615:				;
 616:				; This is the highest extent encountered so far or it is the first extent
 617:				; encountered (FI_LAST_PEXT = 0).
 618: 3367+19	02C6' DD7E0C  	slfrc_not_last  ld a, (ix + FI_LAST_PEXT)   ; Last extent
 619: 3386+19	02C9' DDB60D  	                or (ix + FI_LAST_PEXT + 1)
 620: 3405+7+5	02CC' 280B    	                jr z, slfrc_update
 621:				;
 622:				; This isnt the first extent, so the previous one should have RC = 0x80.
 623: 3412+19	02CE' DD7E0E  	                ld a, (ix + FI_LAST_RC)
 624: 3431+7	02D1' FE80    	                cp 0x80
 625: 3438+10	02D3' 11ED09  	                ld de, bad_rc_msg       ; " - RC not 0x80 in intermediate extent"
 626: 3448+10+7	02D6' C4F504  	                call nz, sl_err_cont
 627:				;
 628:				; RC checks complete. Update the FI_LAST_PEXT and FI_LAST_RC fields for next
 629:				; time.
 630: 3458+16	02D9' 2A1700  	slfrc_update    ld hl, (phys_extent)    ; Set FI_LAST_PEXT = PEXTENT
 631: 3474+19	02DC' DD750C  	                ld (ix + FI_LAST_PEXT), l
 632: 3493+19	02DF' DD740D  	                ld (ix + FI_LAST_PEXT + 1), h
 633: 3512+19	02E2' FD7E0F  	                ld a, (iy + DIRE_RC)    ; Set FI_LAST_RC = RC
 634: 3531+19	02E5' DD770E  	                ld (ix + FI_LAST_RC), a
 635:     -	02E8'         	slfrc_done
 636:				;
 637:				; Entry scanned.
 638: 3550+20	02E8' DD2A1B00	sl_entry_done   ld ix, (dpb)
 639:				; IX - pointer to DPB (DPB_xxx)
 640:				; IY - pointer to directory entry structure (DIRE_xxx)
 641: 3570+16	02EC' 2A2100  	                ld hl, (dir_entry_num)  ; Loop counter
 642: 3586+4	02EF' 7D      	                ld a, l
 643: 3590+19	02F0' DDBE07  	                cp (ix + DPB_DRM)       ; Is this the last entry?
 644: 3609+7+5	02F3' 2006    	                jr nz, sl_do_next
 645: 3616+4	02F5' 7C      	                ld a, h
 646: 3620+19	02F6' DDBE08  	                cp (ix + DPB_DRM + 1)
 647: 3639+7+5	02F9' 2809    	                jr z, scan_done
 648: 3646+6	02FB' 23      	sl_do_next      inc hl                  ; Next entry
 649: 3652+10	02FC' C32001  	                jp scan_loop
 650:				;
 651:				;
 652:				; Error found. Display the entry and an appropriate message, then skip any
 653:				; remaining checks. Call with:
 654:				; DE - pointer to message
 655: 3662+17	02FF' CDF504  	sl_err_stop     call sl_err_cont
 656: 3679+12	0302' 18E4    	                jr sl_entry_done
 657:				;
 658:				;
 659:				; *** Check for missing extents ***
 660:				; All directory entries scanned. Examine each file in files_info, ensuring
 661:				; there are no missing extents. This is different from the previous sparse
 662:				; check, as this looks for missing allocations within each physical extent.
 663: 3691+20	0304' FD2A0800	scan_done       ld iy, (files_info)
 664: 3711+20	0308' ED5B0A00	spck_loop       ld de, (free_start)     ; First free location
 665: 3731+15	030C' FDE5    	                push iy
 666: 3746+10	030E' E1      	                pop hl
 667: 3756+4	030F' A7      	                and a
 668: 3760+15	0310' ED52    	                sbc hl, de
 669: 3775+10	0312' D26203  	                jp nc, spck_done        ; Jump if buffer exhausted
 670:				;
 671:				; There is an entry to examine. All extries except the last one should be 0xff.
 672:				; The last should consist of zero or more "1" bits extending from the LS end
 673:				; with no gaps.
 674: 3785+15	0315' FDE5    	                push iy
 675: 3800+10	0317' E1      	                pop hl
 676: 3810+10	0318' 111000  	                ld de, FI_EX_FLAGS
 677: 3820+11	031B' 19      	                add hl, de
 678:				; HL - pointer to first extent flag byte.
 679: 3831+19	031C' FD7E0F  	                ld a, (iy + FI_EX_FL_LEN)
 680: 3850+4	031F' A7      	                and a
 681: 3854+7+5	0320' 2009    	                jr nz, spck_not_empty
 682:				;
 683: 3861+10	0322' 11130A  	                ld de, empty_msg        ; " - has no data"
 684: 3871+17	0325' CD1305  	                call spck_error         ; Error if no extents at all
 685: 3888+10	0328' C35403  	                jp spck_file_done
 686:				;
 687:				; File as at least one extent.
 688: 3898+4	032B' 4F      	spck_not_empty  ld c, a
 689: 3902+7	032C' 0600    	                ld b, 0                 ; Error flag
 690:				;
 691:				; B - sparse flag (zero if OK)
 692:				; C - length remaining
 693:				; HL - pointer to extent flag byte
 694:				; IY - pointer to files_info entry (FI_xxx)
 695: 3909+4	032E' 79      	spck_byte_loop  ld a, c
 696: 3913+7	032F' FE01    	                cp 1
 697: 3920+7+5	0331' 280B    	                jr z, spck_last_byte
 698:				; Not the last byte.
 699: 3927+7	0333' 7E      	                ld a, (hl)
 700: 3934+7	0334' FEFF    	                cp 0xff
 701: 3941+7+5	0336' 2802    	                jr z, spck_byte_ok
 702:				; We have encountered a hole.
 703: 3948+7	0338' 0601    	spck_sp_err     ld b, 1                 ; Flag sparseness
 704: 3955+6	033A' 23      	spck_byte_ok    inc hl
 705: 3961+4	033B' 0D      	                dec c
 706: 3965+12	033C' 18F0    	                jr spck_byte_loop
 707:				;
 708:				; Process the last byte. This should not be zero, as flag bytes are only
 709:				; created when required to flag an extent.
 710: 3977+7	033E' 7E      	spck_last_byte  ld a, (hl)
 711: 3984+4	033F' A7      	                and a
 712: 3988+10+7	0340' CC0000  	                call z, panic           ; Panic if flag is all zeroes
 713: 3998+4	0343' 4F      	                ld c, a
 714:				; Keep shifting until no "1" bit falls off the end.
 715: 4002+8	0344' CB39    	spck_bit_loop   srl c                   ; Shift LS bit to carry
 716: 4010+7+5	0346' 38FC    	                jr c, spck_bit_loop
 717:				; The result should be zero.
 718: 4017+7+5	0348' 2802    	                jr z, spck_last_ok
 719: 4024+7	034A' 0601    	                ld b, 1                 ; Flag sparseness
 720:				;
 721:				; File checks complete.
 722:				; B - sparse flag (zero if OK)
 723: 4031+4	034C' 78      	spck_last_ok    ld a, b
 724: 4035+4	034D' A7      	                and a
 725: 4039+10	034E' 118209  	                ld de, sparse_msg       ; " - is sparse (holed) [warning]"
 726: 4049+10+7	0351' C41305  	                call nz, spck_error     ; Error if hole detected
 727:				;
 728:				; Advance pointer by the length of this structure. We must include the length
 729:				; of the extent flags section (FI_EX_FL_LEN).
 730: 4059+19	0354' FD5E0F  	spck_file_done  ld e, (iy + FI_EX_FL_LEN)
 731: 4078+7	0357' 1600    	                ld d, 0
 732:				; DE - extent flags length.
 733: 4085+15	0359' FD19    	                add iy, de              ; Add length to base
 734: 4100+10	035B' 111000  	                ld de, FI_SIZE
 735: 4110+15	035E' FD19    	                add iy, de              ; Add structure size
 736: 4125+12	0360' 18A6    	                jr spck_loop
 737:				;
 738:				;
 739:				; All checks complete.
 740: 4137+20	0362' DD2A1B00	spck_done       ld ix, (dpb)
 741:				; IX - pointer to DPB (DPB_xxx)
 742:				;
 743: 4157+10	0366' 21F907  	                ld hl, dir_done_msg     ; "Directory checks complete"
 744: 4167+17	0369' CD0000  	                call conwms             ; Print $-terminated string to console
 745:				;
 746: 4184+10	036C' 218708  	                ld hl, errors_msg       ; "Errors and warnings: "
 747: 4194+17	036F' CD0000  	                call conwms             ; Print $-terminated string to console
 748: 4211+16	0372' 2A0F00  	                ld hl, (error_count)
 749: 4227+17	0375' CD0000  	                call cwpdwd             ; Print HL in decimal
 750: 4244+17	0378' CD0000  	                call cwnwln             ; Write new line characters to console
 751:				;
 752: 4261+10	037B' 211508  	                ld hl, files_msg        ; "Files found: "
 753: 4271+17	037E' CD0000  	                call conwms             ; Print $-terminated string to console
 754: 4288+16	0381' 2A1100  	                ld hl, (file_count)
 755: 4304+17	0384' CD0000  	                call cwpdwd             ; Print HL in decimal
 756: 4321+17	0387' CD0000  	                call cwnwln             ; Write new line characters to console
 757:				;
 758: 4338+10	038A' 212308  	                ld hl, unused_msg        ; "Unused directory entries: "
 759: 4348+17	038D' CD0000  	                call conwms             ; Print $-terminated string to console
 760: 4365+16	0390' 2A1300  	                ld hl, (unused_count)
 761: 4381+17	0393' CD0000  	                call cwpdwd             ; Print HL in decimal
 762: 4398+17	0396' CD0000  	                call cwnwln             ; Write new line characters to console
 763:				;
 764: 4415+10	0399' 213E08  	                ld hl, blocks_used_msg  ; "Blocks used: "
 765: 4425+17	039C' CD0000  	                call conwms             ; Print $-terminated string to console
 766: 4442+16	039F' 2A1500  	                ld hl, (blocks_used)
 767: 4458+17	03A2' CD0000  	                call cwpdwd             ; Print HL in decimal
 768: 4475+17	03A5' CD0000  	                call cwnwln             ; Write new line characters to console
 769:				;
 770:				;
 771:				; *** Display block usage map ***
 772:				; Blocks go from 0 to DPB.DSM. Scale this to the display. Scaling will be one
 773:				; block per character, unless this won't fit in a reasonable space. In that
 774:				; case, the scaling is progressively halved until it does fit.
 775: 4492+10	03A8' 214C08  	                ld hl, block_map_msg    ; "Block map ..."
 776: 4502+17	03AB' CD0000  	                call conwms             ; Print $-terminated string to console
 777:				;
 778: 4519+7	03AE' 0E00    	                ld c, 0                 ; Initial shift (scaling)
 779: 4526+7	03B0' 0601    	                ld b, 1                 ; Scale factor
 780:				; Scaling loop.
 781: 4533+19	03B2' DD6E05  	bdis_scale_loop ld l, (ix + DPB_DSM)    ; Maximum block number
 782: 4552+19	03B5' DD6606  	                ld h, (ix + DPB_DSM + 1)
 783: 4571+6	03B8' 23      	                inc hl
 784:				; HL - total number of blocks
 785: 4577+11	03B9' C5      	                push bc
 786: 4588+17	03BA' CD4105  	                call rshift_word        ; Shift HL >> C
 787: 4605+10	03BD' C1      	                pop bc
 788: 4615+10	03BE' 11C003  	                ld de, BDIS_CHARS_MAX
 789: 4625+4	03C1' A7      	                and a
 790: 4629+15	03C2' ED52    	                sbc hl, de
 791: 4644+7+5	03C4' 3809    	                jr c, bdis_scale_done   ; Jump if scaling OK
 792:				; Halve size
 793: 4651+4	03C6' 0C      	                inc c                   ; One more shift
 794: 4655+4	03C7' A7      	                and a
 795: 4659+8	03C8' CB10    	                rl b                    ; Double scale
 796: 4667+10+7	03CA' DC0000  	                call c, panic           ; Panic on overflow
 797: 4677+12	03CD' 18E3    	                jr bdis_scale_loop
 798:				;
 799: 4689+4	03CF' 79      	bdis_scale_done ld a, c
 800: 4693+13	03D0' 322300  	                ld (bdis_shift), a      ; Set shift (scaling)
 801: 4706+4	03D3' 78      	                ld a, b
 802: 4710+13	03D4' 322400  	                ld (bdis_scale), a      ; Set scale
 803:				;;
 804:				; Display loop.
 805: 4723+10	03D7' 210000  	                ld hl, 0                ; Start at first block
 806: 4733+4	03DA' AF      	                xor a
 807: 4737+13	03DB' 322500  	                ld (bdis_s_count), a    ; Scale counter
 808: 4750+13	03DE' 322600  	                ld (bdis_col), a        ; Display column
 809: 4763+7	03E1' 062D    	                ld b, "-"               ; Default character
 810:				; B - character
 811:				; HL - block number
 812:				; Is this a directory block?
 813: 4770+4	03E3' 7C      	bdis_loop       ld a, h
 814: 4774+4	03E4' A7      	                and a
 815: 4778+7+5	03E5' 200D    	                jr nz, bdis_not_dir     ; Not a directory block
 816: 4785+13	03E7' 3A0E00  	                ld a, (dir_blocks)      ; Number of blocks used by the directory
 817: 4798+4	03EA' 5F      	                ld e, a
 818: 4802+4	03EB' 7D      	                ld a, l
 819: 4806+4	03EC' BB      	                cp e
 820: 4810+7+5	03ED' 3005    	                jr nc, bdis_not_dir     ; Not a directory block
 821:				; This is a directory block.
 822: 4817+7	03EF' 3E44    	                ld a, "D"
 823: 4824+4	03F1' 47      	                ld b, a
 824: 4828+12	03F2' 1810    	                jr bdis_blk_done
 825:				;
 826:				; Not a directory block. Is this block allocated?
 827: 4840+11	03F4' E5      	bdis_not_dir    push hl                 ; Save block number
 828: 4851+20	03F5' ED5B0400	                ld de, (blk_flags)      ; Base address of bit map
 829: 4871+17	03F9' CD2905  	                call BitAddrMask        ; Find address and mask
 830:				; A  bit mask (one bit set)
 831:				; HL  address
 832: 4888+7	03FC' 5E      	                ld e, (hl)
 833: 4895+10	03FD' E1      	                pop hl                  ; Restore block number
 834: 4905+4	03FE' A3      	                and e
 835: 4909+7+5	03FF' 2803    	                jr z, bdis_blk_done     ; Jump if unused
 836:				;
 837:				; This is a file block
 838: 4916+7	0401' 3E46    	                ld a, "F"
 839: 4923+4	0403' 47      	                ld b, a
 840:				;
 841:				; Block processing complete. Have we reached the end of the displayed
 842:				; character?
 843: 4927+13	0404' 3A2500  	bdis_blk_done   ld a, (bdis_s_count)    ; Scale (block) counter
 844: 4940+4	0407' 3C      	                inc a
 845: 4944+4	0408' 4F      	                ld c, a
 846: 4948+13	0409' 3A2400  	                ld a, (bdis_scale)      ; Scale (n:1)
 847: 4961+4	040C' B9      	                cp c
 848: 4965+7+5	040D' 2017    	                jr nz, bdis_entry_done
 849:				;
 850:				; Display the character.
 851: 4972+4	040F' 78      	                ld a, b
 852: 4976+17	0410' CD0000  	                call conwch             ; Write character to console
 853: 4993+7	0413' 062D    	                ld b, "-"               ; Default character
 854:				;
 855:				; Update display column and start a newline if required.
 856: 5000+13	0415' 3A2600  	                ld a, (bdis_col)
 857: 5013+4	0418' 3C      	                inc a
 858: 5017+7	0419' FE50    	                cp VT100_COLS           ; Assume a VT-100 for this purpose
 859: 5024+7+5	041B' 3804    	                jr c, bdis_col_done
 860:				; We are at the end of the line.
 861: 5031+17	041D' CD0000  	                call cwnwln             ; Write new line characters to console
 862: 5048+4	0420' AF      	                xor a
 863: 5052+13	0421' 322600  	bdis_col_done   ld (bdis_col), a        ; Save updated column
 864: 5065+7	0424' 0E00    	                ld c, 0                 ; Reset scale divider
 865:				;
 866:				; C - scale (block) counter
 867:				; HL - block number
 868:				; IX - pointer to DPB (DPB_xxx)
 869: 5072+4	0426' 79      	bdis_entry_done ld a, c
 870: 5076+13	0427' 322500  	                ld (bdis_s_count), a    ; Save updated scale (block) counter
 871: 5089+6	042A' 23      	                inc hl                  ; Next block
 872: 5095+19	042B' DD5E05  	                ld e, (ix + DPB_DSM)    ; Maximum block number
 873: 5114+19	042E' DD5606  	                ld d, (ix + DPB_DSM + 1)
 874: 5133+6	0431' 13      	                inc de
 875:				; DE - total number of blocks
 876: 5139+11	0432' E5      	                push hl
 877: 5150+4	0433' A7      	                and a
 878: 5154+15	0434' ED52    	                sbc hl, de
 879: 5169+10	0436' E1      	                pop hl
 880: 5179+7+5	0437' 38AA    	                jr c, bdis_loop
 881: 5186+17	0439' CD0000  	                call cwnwln             ; Write new line characters to console
 882:				;
 883:				; Should we perform the surface scan?
 884: 5203+13	043C' 3A0300  	                ld a, (scan_enable)     ; Surface scan enable flag
 885: 5216+4	043F' A7      	                and a
 886: 5220+7+5	0440' 2006    	                jr nz, surface_scan
 887: 5227+10	0442' 219D08  	                ld hl, no_ss_msg        ; "Surface scan skipped ..."
 888: 5237+10	0445' C3E504  	                jp msg_exit
 889:				;
 890:				;
 891:				; *** Surface scan ***
 892:				; Read every block to ensure that they are readable. The reserved (system) area
 893:				; is not read, as this may have a different geometry to the files area and this
 894:				; may cause trouble. Blocks extend from 0 (the beginning of the directory) to
 895:				; DPB.DSM. Each block consists of DPB.BLM + 1 sectors. Alternatively, shifting
 896:				; the number of blocks by DPB.BSH gives the number of sectors.
 897: 5247+10	0448' 21B408  	surface_scan    ld hl, surf_scan_msg    ; "Checking all blocks are readable (surface scan)"
 898: 5257+17	044B' CD0000  	                call conwms             ; Print $-terminated string to console
 899:				; Find number of sectors in file system.
 900: 5274+19	044E' DD5E05  	                ld e, (ix + DPB_DSM)    ; Maximum block number
 901: 5293+19	0451' DD5606  	                ld d, (ix + DPB_DSM + 1)
 902: 5312+6	0454' 13      	                inc de
 903: 5318+7	0455' 0E00    	                ld c, 0                 ; Extend to 24 bits
 904:				; CDE - number of blocks
 905: 5325+19	0457' DD4602  	                ld b, (ix + DPB_BSH)    ; Block shift factor
 906:				; Valid BSH values are 3 to 7.
 907: 5344+8	045A' CB23    	ss_find_sec_lp  sla e
 908: 5352+8	045C' CB12    	                rl d
 909: 5360+8	045E' CB11    	                rl c
 910: 5368+10+7	0460' DC0000  	                call c, panic           ; Panic on overflow
 911: 5378+8+5	0463' 10F5    	                djnz ss_find_sec_lp
 912:				; CDE - number of sectors in file system area (does not include reserved
 913:				; (system) area.
 914: 5386+10	0465' 212E00  	                ld hl, total_sectors    ; Number of sectors in file system
 915: 5396+7	0468' 73      	                ld (hl), e
 916: 5403+6	0469' 23      	                inc hl
 917: 5409+7	046A' 72      	                ld (hl), d
 918: 5416+6	046B' 23      	                inc hl
 919: 5422+7	046C' 71      	                ld (hl), c
 920:				;
 921:				; All blocks are read, including the directory blocks processed earlier. It
 922:				; seems easier this way.
 923: 5429+10	046D' 21FFFF  	                ld hl, 0xffff
 924: 5439+16	0470' 222A00  	                ld (disp_track), hl     ; Force display of first track
 925: 5455+10	0473' 110000  	                ld de, 0                ; Set initial sector
 926: 5465+7	0476' 0E00    	                ld c, 0
 927: 5472+11	0478' D5      	ss_loop         push de                 ; Save sector
 928: 5483+11	0479' C5      	                push bc
 929:				; CDE - CP/M (128-byte) sector number (offset into data area)
 930: 5494+17	047A' CDE306  	                call set_sector
 931:				;
 932:				; Display the track if it has changed. This is to avoid repeatedly writing the
 933:				; same track number, as this slows the scan greatly.
 934: 5511+16	047D' 2A2800  	                ld hl, (track)
 935: 5527+20	0480' ED5B2A00	                ld de, (disp_track)
 936: 5547+4	0484' 7D      	                ld a, l
 937: 5551+4	0485' BB      	                cp e
 938: 5555+7+5	0486' 2004    	                jr nz, ss_disp_track    ; Jump on mismatch
 939: 5562+4	0488' 7C      	                ld a, h
 940: 5566+4	0489' BA      	                cp d
 941: 5570+7+5	048A' 280E    	                jr z, ss_nodisp         ; Jump match
 942: 5577+11	048C' E5      	ss_disp_track   push hl                 ; Save track
 943: 5588+10	048D' 21E808  	                ld hl, track_msg        ; "<CR>Track: "
 944: 5598+17	0490' CD0000  	                call conwms             ; Print $-terminated string to console
 945: 5615+10	0493' E1      	                pop hl
 946: 5625+16	0494' 222A00  	                ld (disp_track), hl     ; Save for next time
 947: 5641+17	0497' CD0000  	                call cwpdwd             ; Print HL in decimal
 948:				;
 949:				; Read the sector.
 950: 5658+10	049A' 212400  	ss_nodisp       ld hl, BIOS_READ        ; Read a sector
 951: 5668+17	049D' CD0000  	                call cbios              ; Call BIOS with some registers saved
 952: 5685+4	04A0' A7      	                and a
 953: 5689+7+5	04A1' 2815    	                jr z, ss_sec_done
 954:				; I/O error!
 955: 5696+10	04A3' 21F108  	                ld hl, sector_msg       ; ", sector: "
 956: 5706+17	04A6' CD0000  	                call conwms             ; Print $-terminated string to console
 957: 5723+16	04A9' 2A2C00  	                ld hl, (sector)
 958: 5739+17	04AC' CD0000  	                call cwpdwd             ; Print HL in decimal
 959:				;
 960: 5756+17	04AF' CD0000  	                call cwpspc             ; Print a space
 961: 5773+10	04B2' 21E707  	                ld hl, disk_err_msg     ; "Disk I/O error."
 962: 5783+17	04B5' CD0000  	                call conwms             ; Print $-terminated string to console
 963:				; This message ends in a CR / LF sequence, so it will remain visible.
 964:				;
 965:				; Sector done. Write a carriage return only, so the next message will overwrite
 966:				; the current one except after an error.
 967: 5800+10	04B8' C1      	ss_sec_done     pop bc
 968: 5810+10	04B9' D1      	                pop de
 969:				; Find next sector (in CDE).
 970: 5820+4	04BA' 7B      	                ld a, e
 971: 5824+7	04BB' C601    	                add 1
 972: 5831+4	04BD' 5F      	                ld e, a
 973: 5835+4	04BE' 7A      	                ld a, d
 974: 5839+7	04BF' CE00    	                adc 0                   ; Propagate carry
 975: 5846+4	04C1' 57      	                ld d, a
 976: 5850+4	04C2' 79      	                ld a, c
 977: 5854+7	04C3' CE00    	                adc 0
 978: 5861+4	04C5' 4F      	                ld c, a
 979: 5865+10+7	04C6' DC0000  	                call c, panic           ; Panic on overflow
 980:				;
 981:				; Is there more to do?
 982: 5875+10	04C9' 212E00  	                ld hl, total_sectors    ; Number of sectors in file system
 983: 5885+4	04CC' 7B      	                ld a, e
 984: 5889+7	04CD' BE      	                cp (hl)
 985: 5896+7+5	04CE' 20A8    	                jr nz, ss_loop
 986: 5903+6	04D0' 23      	                inc hl
 987: 5909+4	04D1' 7A      	                ld a, d
 988: 5913+7	04D2' BE      	                cp (hl)
 989: 5920+7+5	04D3' 20A3    	                jr nz, ss_loop
 990: 5927+6	04D5' 23      	                inc hl
 991: 5933+4	04D6' 79      	                ld a, c
 992: 5937+7	04D7' BE      	                cp (hl)
 993: 5944+7+5	04D8' 209E    	                jr nz, ss_loop
 994:				;
 995: 5951+10	04DA' 21FC08  	                ld hl, scan_done_msg    ; "Scan complete"
 996: 5961+17	04DD' CD0000  	                call conwms             ; Print $-terminated string to console
 997:				;
 998: 5978+12	04E0' 1806    	                jr exit
 999:				;
1000: 5990+10	04E2' 21BB07  	out_of_memory   ld hl, memory_msg       ; "Insufficient memory"
1001:				;
1002:				; Print message pointed to by HL, then exit.
1003: 6000+17	04E5' CD0000  	msg_exit        call conwms             ; Print $-terminated string to console
1004:				;
1005:				; Return to CP/M.
1006: 6017+10	04E8' 21A607  	exit            ld hl, exit_msg         ; "Returning to CP/M."
1007: 6027+17	04EB' CD0000  	                call conwms             ; Print $-terminated string to console
1008: 6044+20	04EE' ED7B0000	                ld sp, (bdos_sp)
1009:				; For this application a warm boot is required as we may have overwritten the
1010:				; CCP.
1011:				;                ret                     ; Return to BDOS
1012: 6064+10	04F2' C30000  	                jp 0                    ; Warm boot
1013:				;
1014:				;
1015:				;
1016:				; ***************
1017:				; * Subroutines *
1018:				; ***************
1019:				;
1020:				;
1021:				; Error found during directory scan. Display the entry and an appropriate
1022:				; message, then return to continue checking. Call with:
1023:				; DE - pointer to message
1024: 6074+11	04F5' D5      	sl_err_cont     push de
1025: 6085+11	04F6' E5      	                push hl
1026: 6096+15	04F7' FDE5    	                push iy
1027:				;
1028: 6111+20	04F9' FD2A1D00	                ld iy, (dire)           ; Pointer to directory entry structure
1029: 6131+17	04FD' CD3A06  	                call disp_file          ; Display filename etc.
1030: 6148+4	0500' EB      	                ex de, hl
1031: 6152+17	0501' CD0000  	                call conwms             ; Print $-terminated string to console
1032: 6169+17	0504' CD0000  	                call cwnwln             ; Write new line characters to console
1033:				;
1034: 6186+16	0507' 2A0F00  	                ld hl, (error_count)
1035: 6202+6	050A' 23      	                inc hl
1036: 6208+16	050B' 220F00  	                ld (error_count), hl
1037:				;
1038: 6224+14	050E' FDE1    	                pop iy
1039: 6238+10	0510' E1      	                pop hl
1040: 6248+10	0511' D1      	                pop de
1041: 6258+10	0512' C9      	                ret
1042:				;
1043:				;
1044:				; Error found during files infomation structure scan. Display the entry and an
1045:				; appropriate message, then return to continue checking. Call with:
1046:				; DE - pointer to message
1047:				; IY - pointer to files_info entry (FI_xxx)
1048: 6268+11	0513' D5      	spck_error      push de
1049: 6279+11	0514' E5      	                push hl
1050:				;
1051: 6290+17	0515' CD3A06  	                call disp_file          ; Display filename etc.
1052: 6307+4	0518' EB      	                ex de, hl
1053: 6311+17	0519' CD0000  	                call conwms             ; Print $-terminated string to console
1054: 6328+17	051C' CD0000  	                call cwnwln             ; Write new line characters to console
1055:				;
1056: 6345+16	051F' 2A0F00  	                ld hl, (error_count)
1057: 6361+6	0522' 23      	                inc hl
1058: 6367+16	0523' 220F00  	                ld (error_count), hl
1059:				;
1060: 6383+10	0526' E1      	                pop hl
1061: 6393+10	0527' D1      	                pop de
1062: 6403+10	0528' C9      	                ret
1063:				;
1064:				;
1065:				; Find address and mask in a bit mapped array. Call with:
1066:				; DE - base address
1067:				; HL  bit address
1068:				; Returns with:
1069:				; A  bit mask (one bit set)
1070:				; HL  address
1071: 6413+11	0529' C5      	BitAddrMask     push bc
1072:				;
1073:				; Find bit mask.
1074: 6424+4	052A' 7D      	                ld a, l
1075: 6428+7	052B' E607    	                and 7
1076: 6435+4	052D' 3C      	                inc a                   ; Make range 1 to 8
1077: 6439+4	052E' 47      	                ld b, a
1078: 6443+7	052F' 0E80    	                ld c, 0x80
1079: 6450+8	0531' CB01    	bam_mask_loop   rlc c
1080: 6458+8+5	0533' 10FC    	                djnz bam_mask_loop
1081:				;
1082:				; Find byte offset.
1083: 6466+7	0535' 0603    	                ld b, 3
1084: 6473+8	0537' CB3C    	bam_div_loop    srl h                   ; Divide by two
1085: 6481+8	0539' CB1D    	                rr l
1086: 6489+8+5	053B' 10FA    	                djnz bam_div_loop
1087:				;
1088:				; DE  bit address
1089:				; HL - byte offset
1090:				; C - bit mask
1091: 6497+11	053D' 19      	                add hl, de              ; Add base address
1092: 6508+4	053E' 79      	                ld a, c                 ; bit mask
1093:				;
1094: 6512+10	053F' C1      	                pop bc
1095: 6522+10	0540' C9      	                ret
1096:				;
1097:				;
1098:				; Shift a 16-bit value by a number of bits, which can be zero (Shift HL >> C).
1099:				; Call with:
1100:				; C - displacement
1101:				; HL - value
1102:				; Returns with:
1103:				; HL - displaced value
1104: 6532+4	0541' 79      	rshift_word     ld a, c
1105: 6536+4	0542' A7      	rshw_loop       and a
1106: 6540+5+6	0543' C8      	                ret z                   ; Return if complete
1107: 6545+8	0544' CB3C    	                srl h                   ; Divide by two
1108: 6553+8	0546' CB1D    	                rr l
1109: 6561+4	0548' 3D      	                dec a
1110: 6565+12	0549' 18F7    	                jr rshw_loop
1111:				;
1112:				;
1113:				; Set C to non-zero. This provides a conditional flagging mechanism for use
1114:				; when error checking. For example, "call c, set_c_reg".
1115: 6577+7	054B' 0EFF    	set_c_reg       ld c, 0xff
1116: 6584+10	054D' C9      	                ret
1117:				;
1118:				;
1119:				; Mark block as used. Call with:
1120:				; HL - block number (0 to DSM).
1121:				; IX - pointer to DPB (DPB_xxx)
1122:				; Returns with:
1123:				; Carry clear if all went well. Carry will be set if there was an error.
1124:				; DE - points to an appropriate error message if there was an error.
1125: 6594+11	054E' C5      	flag_block      push bc
1126: 6605+11	054F' D5      	                push de
1127:				;
1128:				; Check DE is within range.
1129: 6616+11	0550' E5      	                push hl
1130: 6627+19	0551' DD5E05  	                ld e, (ix + DPB_DSM)    ; Maximum block number
1131: 6646+19	0554' DD5606  	                ld d, (ix + DPB_DSM + 1)
1132: 6665+6	0557' 13      	                inc de
1133: 6671+4	0558' A7      	                and a
1134: 6675+15	0559' ED52    	                sbc hl, de
1135: 6690+10	055B' E1      	                pop hl                  ; Restore block number
1136: 6700+10	055C' 11A109  	                ld de, blk_too_big_msg  ; " - block number out of range"
1137: 6710+7+5	055F' 301D    	                jr nc, fb_error
1138:				;
1139:				; Block number is OK. Find bit mask.
1140: 6717+20	0561' ED5B0400	                ld de, (blk_flags)      ; Start of blocks used flags
1141: 6737+17	0565' CD2905  	                call BitAddrMask        ; Find address and mask
1142:				; A  bit mask (one bit set)
1143:				; HL  address
1144:				; Is the flag already set?
1145: 6754+4	0568' 4F      	                ld c, a
1146: 6758+7	0569' 7E      	                ld a, (hl)
1147: 6765+4	056A' A1      	                and c
1148: 6769+10	056B' 116E09  	                ld de, dble_blk_msg     ; " - block not unique"
1149: 6779+7+5	056E' 200E    	                jr nz, fb_error
1150:				; No duplicate found, so set the bit.
1151: 6786+7	0570' 7E      	                ld a, (hl)
1152: 6793+4	0571' B1      	                or c
1153: 6797+7	0572' 77      	                ld (hl), a
1154:				;
1155: 6804+16	0573' 2A1500  	                ld hl, (blocks_used)    ; Increment count
1156: 6820+6	0576' 23      	                inc hl
1157: 6826+16	0577' 221500  	                ld (blocks_used), hl
1158:				;
1159:				; Normal exit with carry reset.
1160: 6842+10	057A' D1      	                pop de
1161: 6852+10	057B' C1      	                pop bc
1162: 6862+4	057C' A7      	                and a
1163: 6866+10	057D' C9      	                ret
1164:				;
1165:				; Return with carry set and message pointer in DE.
1166: 6876+6	057E' 33      	fb_error        inc sp                  ; Discard DE on stack
1167: 6882+6	057F' 33      	                inc sp
1168: 6888+10	0580' C1      	                pop bc
1169: 6898+4	0581' 37      	                scf
1170: 6902+10	0582' C9      	                ret
1171:				;
1172:				;
1173:				; Mark physical extent found in FI structure. The flags space will be extended
1174:				; if required. Call with:
1175:				; HL - physical extent number (0 to 511).
1176:				; IX - pointer to file information structure (FI_xxx)
1177:				; Returns with carry set if extent flag was already set.
1178: 6912+11	0583' C5      	flag_extent     push bc
1179: 6923+11	0584' D5      	                push de
1180:				;
1181: 6934+10	0585' 110000  	                ld de, 0                ; No offset
1182: 6944+17	0588' CD2905  	                call BitAddrMask        ; Find address and mask
1183: 6961+4	058B' 4F      	                ld c, a
1184:				; HL - byte offset
1185:				; C - bit mask
1186:				; Offset should be < FI_EX_FL_LEN, or we will have to make more space.
1187: 6965+11	058C' E5      	                push hl
1188: 6976+19	058D' DD5E0F  	                ld e, (ix + FI_EX_FL_LEN)
1189: 6995+7	0590' 1600    	                ld d, 0
1190: 7002+4	0592' A7      	                and a
1191: 7006+15	0593' ED52    	                sbc hl, de
1192: 7021+7+5	0595' 3822    	                jr c, fe_have_space
1193:				;
1194:				; Make room in the FI structures store.
1195: 7028+4	0597' EB      	                ex de, hl
1196: 7032+6	0598' 13      	                inc de
1197:				; DE - number of bytes required
1198: 7038+15	0599' DDE5    	                push ix                 ; Structure base
1199: 7053+10	059B' E1      	                pop hl
1200: 7063+11	059C' C5      	                push bc                 ; Save bit mask
1201: 7074+10	059D' 011000  	                ld bc, FI_EX_FLAGS      ; Offset to flags
1202: 7084+11	05A0' 09      	                add hl, bc              ; Add byte offset
1203: 7095+19	05A1' DD4E0F  	                ld c, (ix + FI_EX_FL_LEN)
1204: 7114+7	05A4' 0600    	                ld b, 0
1205: 7121+11	05A6' 09      	                add hl, bc              ; Add length
1206:				; BC - current length.
1207:				; DE - number of bytes required.
1208:				; HL - pointer to byte after last FI_EX_FLAGS byte.
1209: 7132+11	05A7' D5      	                push de
1210: 7143+17	05A8' CDDC05  	                call fi_make_room
1211: 7160+10	05AB' DAE204  	                jp c, out_of_memory
1212:				; Adjust length by number of bytes extended.
1213: 7170+10	05AE' E1      	                pop hl
1214:				; BC - current length.
1215:				; HL - number of bytes required.
1216: 7180+11	05AF' 09      	                add hl, bc
1217: 7191+19	05B0' DD750F  	                ld (ix + FI_EX_FL_LEN), l
1218: 7210+4	05B3' 7C      	                ld a, h
1219: 7214+4	05B4' A7      	                and a
1220: 7218+10+7	05B5' C40000  	                call nz, panic          ; Panic at absurd lengths
1221: 7228+10	05B8' C1      	                pop bc                  ; Restore bit mask
1222:				;
1223:				; There is space in the buffer.
1224:				; C - bit mask
1225: 7238+10	05B9' E1      	fe_have_space   pop hl                  ; Fetch byte offset
1226: 7248+10	05BA' 111000  	                ld de, FI_EX_FLAGS      ; Offset to flags
1227: 7258+11	05BD' 19      	                add hl, de              ; Add byte offset
1228: 7269+15	05BE' DDE5    	                push ix
1229: 7284+10	05C0' D1      	                pop de
1230: 7294+11	05C1' 19      	                add hl, de              ; Add structure base
1231:				; Is the bit already set?
1232: 7305+7	05C2' 7E      	                ld a, (hl)
1233: 7312+4	05C3' A1      	                and c
1234: 7316+7+5	05C4' 2005    	                jr nz, fe_dup_err
1235:				; No duplicate found, so set the bit.
1236: 7323+7	05C6' 7E      	                ld a, (hl)
1237: 7330+4	05C7' B1      	                or c
1238: 7334+7	05C8' 77      	                ld (hl), a
1239: 7341+12	05C9' 1801    	                jr fe_exit              ; Exit with carry reset
1240:				;
1241:				; Extent flag is already set, so we have a duplicate.
1242: 7353+4	05CB' 37      	fe_dup_err      scf                     ; Flag error
1243: 7357+10	05CC' D1      	fe_exit         pop de
1244: 7367+10	05CD' C1      	                pop bc
1245: 7377+10	05CE' C9      	                ret
1246:				;
1247:				;
1248:				; Check pointer is lower than the start of BDOS so we don't overwrite CP/M.
1249:				; Call with:
1250:				; HL - address to be checked.
1251:				; Returns with:
1252:				; Carry flag set if HL >= start of BDOS.
1253:				; HL is preserved.
1254: 7387+11	05CF' E5      	chk_mem_lim     push hl
1255: 7398+11	05D0' D5      	                push de
1256: 7409+20	05D1' ED5B0600	                ld de, (BDOS + 1)       ; Fetch first unusable address
1257: 7429+4	05D5' A7      	                and a
1258: 7433+15	05D6' ED52    	                sbc hl, de              ; This should carry
1259: 7448+4	05D8' 3F      	                ccf
1260: 7452+10	05D9' D1      	                pop de
1261: 7462+10	05DA' E1      	                pop hl
1262: 7472+10	05DB' C9      	                ret
1263:				;
1264:				;
1265:				; Make room in the FI structures store. The new space is created at HL, and
1266:				; everything from this address upwards is copied by DE bytes.
1267:				; Call with:
1268:				; HL - insert point
1269:				; DE - number of bytes required
1270:				; Returns with:
1271:				; Carry flag set if out of memory.
1272:				; HL is preserved.
1273: 7482+11	05DC' C5      	fi_make_room    push bc
1274: 7493+11	05DD' D5      	                push de
1275: 7504+11	05DE' E5      	                push hl
1276:				;
1277:				; Check the insert point is within the buffer. Panic if not.
1278: 7515+11	05DF' D5      	                push de
1279: 7526+11	05E0' E5      	                push hl
1280: 7537+20	05E1' ED5B0A00	                ld de, (free_start)     ; First free location
1281: 7557+6	05E5' 13      	                inc de
1282: 7563+4	05E6' A7      	                and a
1283: 7567+15	05E7' ED52    	                sbc hl, de
1284: 7582+10+7	05E9' D40000  	                call nc, panic          ; Panic if insert > end
1285: 7592+10	05EC' E1      	                pop hl
1286:				;
1287: 7602+11	05ED' E5      	                push hl
1288: 7613+20	05EE' ED5B0800	                ld de, (files_info)     ; Start address of FI structures
1289: 7633+4	05F2' A7      	                and a
1290: 7637+15	05F3' ED52    	                sbc hl, de
1291: 7652+10+7	05F5' DC0000  	                call c, panic           ; Panic if insert < start
1292: 7662+10	05F8' E1      	                pop hl
1293: 7672+10	05F9' D1      	                pop de
1294:				;
1295:				; Find new start of free space if the allocation is successful.
1296: 7682+16	05FA' 2A0A00  	                ld hl, (free_start)     ; First free location
1297: 7698+11	05FD' 19      	                add hl, de
1298:				; HL - adjusted free_start
1299: 7709+17	05FE' CDCF05  	                call chk_mem_lim        ; Check HL < BDOS start
1300: 7726+7+5	0601' 381E    	                jr c, fimr_exit         ; Return with carry set on error
1301:				; Find out how much we have to copy (free_start - insert point)
1302: 7733+4	0603' EB      	                ex de, hl
1303:				; DE - adjusted free_start
1304: 7737+16	0604' 2A0A00  	                ld hl, (free_start)     ; First free location
1305: 7753+10	0607' C1      	                pop bc                  ; Insert point
1306: 7763+11	0608' C5      	                push bc
1307: 7774+4	0609' A7      	                and a
1308: 7778+15	060A' ED42    	                sbc hl, bc
1309: 7793+10+7	060C' DC0000  	                call c, panic
1310:				; BC - insert point
1311:				; DE - adjusted free_start
1312:				; HL - number of bytes required
1313:				; Note: there is nothing to copy if we are inserting at the end of the buffer.
1314: 7803+4	060F' 7C      	                ld a, h
1315: 7807+4	0610' B5      	                or l
1316: 7811+7+5	0611' 2820    	                jr z, fimr_no_copy
1317:				;
1318:				; We have data to move.
1319: 7818+4	0613' 44      	                ld b, h                 ; Number of bytes required
1320: 7822+4	0614' 4D      	                ld c, l
1321: 7826+16	0615' 2A0A00  	                ld hl, (free_start)     ; First free location
1322: 7842+20	0618' ED530A00	                ld (free_start), de     ; Save updated free_start
1323: 7862+6	061C' 2B      	                dec hl
1324: 7868+6	061D' 1B      	                dec de
1325:				;
1326:				; HL = FreeStart - 1 (source)
1327:				; DE = adjusted free_start - 1 (destination)
1328:				; BC = number of bytes required
1329: 7874+16+5	061E' EDB8    	                lddr
1330: 7890+4	0620' A7      	                and a                   ; Flag success
1331:				;
1332:				; Clear the newly created space.
1333: 7894+10	0621' E1      	fimr_exit       pop hl                  ; Fetch insert point and length
1334: 7904+10	0622' D1      	                pop de
1335: 7914+11	0623' D5      	                push de
1336: 7925+11	0624' E5      	                push hl
1337:				;
1338: 7936+4	0625' 7A      	fimr_clr_loop   ld a, d
1339: 7940+4	0626' B3      	                or e
1340: 7944+7+5	0627' 2806    	                jr z, fimr_clr_done
1341: 7951+10	0629' 3600    	                ld (hl), 0
1342: 7961+6	062B' 23      	                inc hl
1343: 7967+6	062C' 1B      	                dec de
1344: 7973+12	062D' 18F6    	                jr fimr_clr_loop
1345:				;
1346: 7985+10	062F' E1      	fimr_clr_done   pop hl
1347: 7995+10	0630' D1      	                pop de
1348: 8005+10	0631' C1      	                pop bc
1349: 8015+10	0632' C9      	                ret
1350:				;
1351:				; The insert point is at the end of the buffer, so there is nothing to copy.
1352: 8025+20	0633' ED530A00	fimr_no_copy    ld (free_start), de     ; Save updated free_start
1353: 8045+4	0637' A7      	                and a                   ; Flag success
1354: 8049+12	0638' 18E7    	                jr fimr_exit
1355:				;
1356:				;
1357:				; Display filename etc. from directory entry OR file information structure.
1358:				; Format is:
1359:				; U<user> <name>.<type>
1360:				; IY - pointer to directory entry structure (DIRE_xxx)
1361:				; IY is preserved.
1362: 8061+11	063A' C5      	disp_file       push bc
1363: 8072+11	063B' E5      	                push hl
1364:				;
1365:				; Ensure the offsets are the same for both structures.
1366:     -	0001'         	                assert DIRE_USER = FI_USER
1367:     -	0001'         	                assert DIRE_NAME = FI_NAME
1368:     -	0001'         	                assert DIRE_TYP = FI_TYP
1369:				;
1370:				; Display user.
1371: 8083+7	063C' 3E55    	                ld a, "U"
1372: 8090+17	063E' CD0000  	                call conwch             ; Write character to console
1373: 8107+19	0641' FD7E00  	                ld a, (iy + DIRE_USER)  ; User number
1374: 8126+17	0644' CD0000  	                call cwpdby             ; Print A in decimal
1375: 8143+17	0647' CD0000  	                call cwpspc             ; Print a space
1376:				;
1377:				; Display name.
1378: 8160+15	064A' FDE5    	                push iy
1379: 8175+10	064C' E1      	                pop hl
1380: 8185+10	064D' 010100  	                ld bc, DIRE_NAME
1381: 8195+11	0650' 09      	                add hl, bc
1382:				; HL - start address of name.
1383: 8206+7	0651' 0608    	                ld b, FILENAME_SIZE
1384: 8213+7	0653' 0E3F    	                ld c, "?"               ; Substitution character
1385: 8220+7	0655' 7E      	df_name_loop    ld a, (hl)
1386: 8227+17	0656' CD0000  	                call cwvich             ; Print only visible 7-bit characters
1387: 8244+6	0659' 23      	                inc hl
1388: 8250+8+5	065A' 10F9    	                djnz df_name_loop
1389:				;
1390:				; Display type.
1391: 8258+7	065C' 3E2E    	                ld a, "."
1392: 8265+17	065E' CD0000  	                call conwch             ; Write character to console
1393: 8282+15	0661' FDE5    	                push iy
1394: 8297+10	0663' E1      	                pop hl
1395: 8307+10	0664' 010900  	                ld bc, DIRE_TYP
1396: 8317+11	0667' 09      	                add hl, bc
1397:				; HL - start address of type.
1398: 8328+7	0668' 0603    	                ld b, FILEEXT_SIZE
1399: 8335+7	066A' 0E3F    	                ld c, "?"               ; Substitution character
1400: 8342+7	066C' 7E      	df_type_loop    ld a, (hl)
1401: 8349+17	066D' CD0000  	                call cwvich             ; Print only visible 7-bit characters
1402: 8366+6	0670' 23      	                inc hl
1403: 8372+8+5	0671' 10F9    	                djnz df_type_loop
1404:				;
1405: 8380+10	0673' E1      	                pop hl
1406: 8390+10	0674' C1      	                pop bc
1407: 8400+10	0675' C9      	                ret
1408:				;
1409:				;
1410:				; Compare file in directory entry structure with one in a file information
1411:				; structure. The comparison includes the user number, filename and extension.
1412:				; Call with:
1413:				; DE - pointer to file information structure.
1414:				; HL - pointer to directory entry structure.
1415:				; Returns with:
1416:				; Carry flag set if files don't match.
1417:				; DE and HL are preserved.
1418: 8410+11	0676' C5      	match_files     push bc
1419: 8421+11	0677' D5      	                push de
1420: 8432+11	0678' E5      	                push hl
1421:				;
1422:				; Compare user number.
1423:     -	0001'         	                assert FI_USER = 0
1424:     -	0001'         	                assert DIRE_USER = 0
1425: 8443+7	0679' 1A      	                ld a, (de)
1426: 8450+7	067A' BE      	                cp (hl)
1427: 8457+7+5	067B' 2021    	                jr nz, mf_no_match
1428: 8464+6	067D' 13      	                inc de
1429: 8470+6	067E' 23      	                inc hl
1430:				;
1431:				; Compare filename.
1432:     -	0001'         	                assert FI_NAME = 1
1433:     -	0001'         	                assert DIRE_NAME = 1
1434: 8476+7	067F' 0608    	                ld b, FILENAME_SIZE
1435: 8483+7	0681' 1A      	mf_name_loop    ld a, (de)
1436: 8490+7	0682' BE      	                cp (hl)
1437: 8497+7+5	0683' 2019    	                jr nz, mf_no_match
1438: 8504+6	0685' 13      	                inc de
1439: 8510+6	0686' 23      	                inc hl
1440: 8516+8+5	0687' 10F8    	                djnz mf_name_loop
1441:				;
1442:				; Compare type. Ignore read-only and hidden flags.
1443:     -	0001'         	                assert FI_TYP = 9
1444:     -	0001'         	                assert DIRE_TYP = 9
1445: 8524+7	0689' 0603    	                ld b, FILEEXT_SIZE
1446: 8531+7	068B' 1A      	mf_typ_loop     ld a, (de)
1447: 8538+7	068C' E67F    	                and 0x7f
1448: 8545+4	068E' 4F      	                ld c, a
1449: 8549+7	068F' 7E      	                ld a, (hl)
1450: 8556+7	0690' E67F    	                and 0x7f
1451: 8563+4	0692' B9      	                cp c
1452: 8567+7+5	0693' 2009    	                jr nz, mf_no_match
1453: 8574+6	0695' 13      	                inc de
1454: 8580+6	0696' 23      	                inc hl
1455: 8586+8+5	0697' 10F2    	                djnz mf_typ_loop
1456:				;
1457:				; Files match!
1458: 8594+4	0699' A7      	                and a
1459:				;
1460: 8598+10	069A' E1      	mf_exit         pop hl
1461: 8608+10	069B' D1      	                pop de
1462: 8618+10	069C' C1      	                pop bc
1463: 8628+10	069D' C9      	                ret
1464:				;
1465:				; Mismatch.
1466: 8638+4	069E' 37      	mf_no_match     scf
1467: 8642+12	069F' 18F9    	                jr mf_exit
1468:				;
1469:				;
1470:				; Read a directory entry from the disk and return a pointer to it.
1471:				; Call with:
1472:				; HL - required directory entry number
1473:				; IX - pointer to Disk Parameter Block (DPB)
1474:				; Returns with:
1475:				; HL - points to start of entry
1476: 8654+11	06A1' C5      	get_entry       push bc
1477: 8665+11	06A2' D5      	                push de
1478: 8676+11	06A3' E5      	                push hl                 ; Save entry number
1479:				; Divide by four to find the sector number.
1480: 8687+4	06A4' A7      	                and a
1481: 8691+8	06A5' CB1C    	                rr h
1482: 8699+8	06A7' CB1D    	                rr l
1483: 8707+4	06A9' A7      	                and a
1484: 8711+8	06AA' CB1C    	                rr h
1485: 8719+8	06AC' CB1D    	                rr l
1486:				; HL - CP/M (128-byte) sector number (offset into data area)
1487:				; Is this already in the buffer?
1488: 8727+20	06AE' ED5B0C00	                ld de, (loaded_sector)
1489: 8747+4	06B2' 7C      	                ld a, h
1490: 8751+4	06B3' BA      	                cp d
1491: 8755+7+5	06B4' 2004    	                jr nz, ge_load_reqd
1492: 8762+4	06B6' 7D      	                ld a, l
1493: 8766+4	06B7' BB      	                cp e
1494: 8770+7+5	06B8' 2816    	                jr z, ge_have_sec
1495:				;
1496:				; We need to load the sector containing the required entry.
1497: 8777+16	06BA' 220C00  	ge_load_reqd    ld (loaded_sector), hl  ; Save sector number
1498: 8793+7	06BD' 0E00    	                ld c, 0
1499: 8800+4	06BF' EB      	                ex de, hl
1500:				; CDE - CP/M (128-byte) sector number (offset into data area)
1501: 8804+17	06C0' CDE306  	                call set_sector
1502:				; Read the sector.
1503: 8821+10	06C3' 212400  	                ld hl, BIOS_READ        ; Read a sector
1504: 8831+17	06C6' CD0000  	                call cbios              ; Call BIOS with some registers saved
1505: 8848+4	06C9' A7      	                and a
1506: 8852+10	06CA' 21E707  	                ld hl, disk_err_msg     ; "Disk I/O error."
1507: 8862+10	06CD' C2E504  	                jp nz, msg_exit
1508:				;
1509:				; The required sector is loaded. Find the start address of the directory entry.
1510: 8872+10	06D0' E1      	ge_have_sec     pop hl                  ; Restore directory entry number
1511: 8882+4	06D1' 7D      	                ld a, l
1512: 8886+7	06D2' E603    	                and 0x03
1513: 8893+4	06D4' 6F      	                ld l, a
1514: 8897+7	06D5' 2600    	                ld h, 0
1515:				; HL - number of entry within sector.
1516: 8904+11	06D7' 29      	                add hl, hl              ; Multiply by 32 to find offset
1517: 8915+11	06D8' 29      	                add hl, hl
1518: 8926+11	06D9' 29      	                add hl, hl
1519: 8937+11	06DA' 29      	                add hl, hl
1520: 8948+11	06DB' 29      	                add hl, hl
1521: 8959+10	06DC' 118000  	                ld de, DEF_BUFFER
1522: 8969+11	06DF' 19      	                add hl, de              ; Add buffer start address
1523:				;
1524: 8980+10	06E0' D1      	                pop de
1525: 8990+10	06E1' C1      	                pop bc
1526: 9000+10	06E2' C9      	                ret                     ; Return with address in HL
1527:				;
1528:				;
1529:				; Set track and sector numbers for subsequent read and / or write operations.
1530:				; DMA address is set to the default area (0x80). The variables track and sector
1531:				; are set appropriately.
1532:				; Call with:
1533:				; CDE - CP/M (128-byte) sector number (offset into data area)
1534:				; IX - pointer to Disk Parameter Block (DPB)
1535: 9010+11	06E3' C5      	set_sector      push bc
1536: 9021+11	06E4' E5      	                push hl
1537:				; Find track number. For this application, the track number is likely to be small
1538:				; (normally zero). Hence this crude algorithm is sufficient.
1539: 9032+19	06E5' DD6E0D  	                ld l, (ix + DPB_OFF)    ; Start after reserved tracks
1540: 9051+19	06E8' DD660E  	                ld h, (ix + DPB_OFF + 1)
1541: 9070+11	06EB' D5      	ss_track_loop   push de                 ; Save LS 16 bits of sector number
1542:				; Perform a trial subtraction to see if we have a complete track worth of sectors.
1543: 9081+4	06EC' 7B      	                ld a, e
1544: 9085+19	06ED' DD9600  	                sub (ix + DPB_SPT)
1545: 9104+4	06F0' 5F      	                ld e, a
1546: 9108+4	06F1' 7A      	                ld a, d
1547: 9112+19	06F2' DD9E01  	                sbc (ix + DPB_SPT + 1)
1548: 9131+4	06F5' 57      	                ld d, a
1549: 9135+4	06F6' 79      	                ld a, c
1550: 9139+7	06F7' DE00    	                sbc 0
1551: 9146+4	06F9' 4F      	                ld c, a
1552: 9150+7+5	06FA' 3805    	                jr c, ss_track_done
1553:				; No carry, so we can advance to the next track.
1554: 9157+6	06FC' 23      	                inc hl
1555: 9163+6	06FD' 33      	                inc sp                  ; Discard saved sector number
1556: 9169+6	06FE' 33      	                inc sp
1557: 9175+12	06FF' 18EA    	                jr ss_track_loop
1558:				;
1559:				; There was a carry in the last subtract, so this is the track we want.
1560:				; HL - track number
1561:				; (stacked) - sector number
1562:				; Set track.
1563: 9187+4	0701' 44      	ss_track_done   ld b, h                 ; Move track number to BC
1564: 9191+4	0702' 4D      	                ld c, l
1565: 9195+20	0703' ED432800	                ld (track), bc          ; Save track for status reporting
1566: 9215+10	0707' 211B00  	                ld hl, BIOS_SETTRK      ; Set track number
1567: 9225+17	070A' CD0000  	                call cbios              ; Call BIOS with some registers saved
1568:				;
1569:				; Set sector.
1570: 9242+10	070D' C1      	                pop bc                  ; Fetch sector
1571: 9252+16	070E' 2A1900  	                ld hl, (dph)            ; put translate table pointer in DE
1572: 9268+7	0711' 5E      	                ld e, (hl)
1573: 9275+6	0712' 23      	                inc hl
1574: 9281+7	0713' 56      	                ld d, (hl)
1575: 9288+10	0714' 212D00  	                ld hl, BIOS_SECTRAN     ; ask for translation of BC (return in HL)
1576: 9298+17	0717' CD0000  	                call cbios
1577: 9315+4	071A' 44      	                ld b,h                  ; back into BC for SETSEC
1578: 9319+4	071B' 4D      	                ld c,l
1579: 9323+20	071C' ED432C00	                ld (sector), bc         ; Save sector for status reporting
1580: 9343+10	0720' 211E00  	                ld hl, BIOS_SETSEC      ; Set sector number
1581: 9353+17	0723' CD0000  	                call cbios              ; Call BIOS with some registers saved
1582:				;
1583:				; Set DMA address.
1584: 9370+10	0726' 018000  	                ld bc, DEF_BUFFER
1585: 9380+10	0729' 212100  	                ld hl, BIOS_SETDMA      ; Set DMA address
1586: 9390+17	072C' CD0000  	                call cbios              ; Call BIOS with some registers saved
1587:				;
1588: 9407+10	072F' E1      	                pop hl
1589: 9417+10	0730' C1      	                pop bc
1590: 9427+10	0731' C9      	                ret
1591:				;
1592:				;
1593:				;
1594:				; *************
1595:				; * Constants *
1596:				; *************
1597:				;
1598:				;
1599:     -	0732' 2A2A2A20	signon_msg      byte "*** CP/M File System Checker V1.2 ***", 0x0d, 0x0a, 0x0d, 0x0a, "$"
	              43502F4D
	              2046696C
	              65205379
	              7374656D
	              20436865
	              636B6572
	              2056312E
	              32202A2A
	              2A0D0A0D
	              0A24
1600:     -	075C' 5A383020	no_z80_msg      byte "Z80 CPU required", 0x0d, 0x0a, "$"
	              43505520
	              72657175
	              69726564
	              0D0A24
1601:     -	076F' 4F706572	op_err_msg      byte "Operand error. Expected format: fsck <drive>[:] [/s]", 0x0d, 0x0a, "$"
	              616E6420
	              6572726F
	              722E2045
	              78706563
	              74656420
	              666F726D
	              61743A20
	              6673636B
	              203C6472
	              6976653E
	              5B3A5D20
	              5B2F735D
	              0D0A24
1602:     -	07A6' 52657475	exit_msg        byte "Returning to CP/M.", 0x0d, 0x0a, "$"
	              726E696E
	              6720746F
	              2043502F
	              4D2E0D0A
	              24
1603:     -	07BB' 496E7375	memory_msg      byte "Insufficient memory", 0x0d, 0x0a, "$"
	              66666963
	              69656E74
	              206D656D
	              6F72790D
	              0A24
1604:     -	07D1' 43616E27	sel_err_msg     byte "Can't select drive.", 0x0d, 0x0a, "$"
	              74207365
	              6C656374
	              20647269
	              76652E0D
	              0A24
1605:     -	07E7' 4469736B	disk_err_msg    byte "Disk I/O error.", 0x0d, 0x0a, "$"
	              20492F4F
	              20657272
	              6F722E0D
	              0A24
1606:     -	07F9' 44697265	dir_done_msg    byte "Directory checks complete", 0x0d, 0x0a, "$"
	              63746F72
	              79206368
	              65636B73
	              20636F6D
	              706C6574
	              650D0A24
1607:     -	0815' 46696C65	files_msg       byte "Files found: $"
	              7320666F
	              756E643A
	              2024
1608:     -	0823' 556E7573	unused_msg      byte "Unused directory entries: $"
	              65642064
	              69726563
	              746F7279
	              20656E74
	              72696573
	              3A2024
1609:     -	083E' 426C6F63	blocks_used_msg byte "Blocks used: $"
	              6B732075
	              7365643A
	              2024
1610:     -	084C' 0D0A426C	block_map_msg   byte 0x0d, 0x0a, "Block map ('D': directory, 'F': file and '-': unused).", 0x0d, 0x0a, "$"
	              6F636B20
	              6D617020
	              28274427
	              3A206469
	              72656374
	              6F72792C
	              20274627
	              3A206669
	              6C652061
	              6E642027
	              2D273A20
	              756E7573
	              6564292E
	              0D0A24
1611:     -	0887' 4572726F	errors_msg      byte "Errors and warnings: $"
	              72732061
	              6E642077
	              61726E69
	              6E67733A
	              2024
1612:     -	089D' 53757266	no_ss_msg       byte "Surface scan skipped", 0x0d, 0x0a, "$"
	              61636520
	              7363616E
	              20736B69
	              70706564
	              0D0A24
1613:     -	08B4' 0D0A4368	surf_scan_msg   byte 0x0d, 0x0a, "Checking all blocks are readable (surface scan)", 0x0d, 0x0a, "$"
	              65636B69
	              6E672061
	              6C6C2062
	              6C6F636B
	              73206172
	              65207265
	              61646162
	              6C652028
	              73757266
	              61636520
	              7363616E
	              290D0A24
1614:     -	08E8' 0D547261	track_msg       byte 0x0d, "Track: $"
	              636B3A20
	              24
1615:     -	08F1' 2C207365	sector_msg      byte ", sector: $"
	              63746F72
	              3A2024
1616:     -	08FC' 0D0A5363	scan_done_msg   byte 0x0d, 0x0a, "Scan complete", 0x0d, 0x0a, "$"
	              616E2063
	              6F6D706C
	              6574650D
	              0A24
1617:				; Directory entry error messages
1618:     -	090E' 202D2062	bad_user_msg    byte " - bad user number$"
	              61642075
	              73657220
	              6E756D62
	              657224
1619:     -	0921' 202D2062	bad_name_msg    byte " - bad file name$"
	              61642066
	              696C6520
	              6E616D65
	              24
1620:     -	0932' 202D2062	bad_ex_cnt_msg  byte " - bad extent count$"
	              61642065
	              7874656E
	              7420636F
	              756E7424
1621:     -	0946' 202D2062	bad_s1_msg      byte " - bad S1$"
	              61642053
	              3124
1622:     -	0950' 202D2064	ext_dup_msg     byte " - duplicated physical extent$"
	              75706C69
	              63617465
	              64207068
	              79736963
	              616C2065
	              7874656E
	              7424
1623:     -	096E' 202D2062	dble_blk_msg    byte " - block not unique$"
	              6C6F636B
	              206E6F74
	              20756E69
	              71756524
1624:     -	0982' 202D2069	sparse_msg      byte " - is sparse (holed) [warning]$"
	              73207370
	              61727365
	              2028686F
	              6C656429
	              205B7761
	              726E696E
	              675D24
1625:     -	09A1' 202D2062	blk_too_big_msg byte " - block number out of range$"
	              6C6F636B
	              206E756D
	              62657220
	              6F757420
	              6F662072
	              616E6765
	              24
1626:     -	09BE' 202D206E	no_alloc_msg    byte " - no allocations in physical extent [warning]$"
	              6F20616C
	              6C6F6361
	              74696F6E
	              7320696E
	              20706879
	              73696361
	              6C206578
	              74656E74
	              205B7761
	              726E696E
	              675D24
1627:     -	09ED' 202D2052	bad_rc_msg      byte " - RC not 0x80 in intermediate extent$"
	              43206E6F
	              74203078
	              38302069
	              6E20696E
	              7465726D
	              65646961
	              74652065
	              7874656E
	              7424
1628:     -	0A13' 202D2068	empty_msg       byte " - has no data [warning]$"
	              6173206E
	              6F206461
	              7461205B
	              7761726E
	              696E675D
	              24
1629:				;
1630:				;
1631:				; *************
1632:				; * Variables *
1633:				; *************
1634:				;
1635:				;
1636:				; Note: linker "-c" option is used, so no data is initialised here.
1637:				                dseg                ; Data segment
1638:				;
1639:     -	0000"         	bdos_sp         defs 2              ; BDOS's stack pointer
1640:     -	0002"         	drive           defs 1              ; Drive number (0 to 15)
1641:     -	0003"         	scan_enable     defs 1              ; Surface scan enable flag
1642:     -	0004"         	blk_flags       defs 2              ; Pointer to start of blocks used flags
1643:     -	0006"         	blk_flags_size  defs 2              ; Size of block flags buffer
1644:     -	0008"         	files_info      defs 2              ; Start address of FI structures
1645:     -	000A"         	free_start      defs 2              ; First free location
1646:     -	000C"         	loaded_sector   defs 2              ; Currently loaded sector
1647:     -	000E"         	dir_blocks      defs 1              ; Number of blocks used by the directory
1648:     -	000F"         	error_count     defs 2              ; Error count
1649:     -	0011"         	file_count      defs 2              ; Files count
1650:     -	0013"         	unused_count    defs 2              ; Unused entry count
1651:     -	0015"         	blocks_used     defs 2              ; Number of blocks used
1652:     -	0017"         	phys_extent     defs 2              ; Calculated physical extent
1653:     -	0019"         	dph             defs 2              ; Pointer to Disk Parameter Header (DPH_xxx)
1654:     -	001B"         	dpb             defs 2              ; Pointer to Disk Parameter Block (DPB_xxx)
1655:     -	001D"         	dire            defs 2              ; Pointer to directory entry structure (DIRE_xxx)
1656:     -	001F"         	fie             defs 2              ; Pointer to file information structure (FI_xxx)
1657:     -	0021"         	dir_entry_num   defs 2              ; Directory entry number being processed
1658:     -	0023"         	bdis_shift      defs 1              ; Block display shift (scaling)
1659:     -	0024"         	bdis_scale      defs 1              ; Scale (n:1)
1660:     -	0025"         	bdis_s_count    defs 1              ; Scale (block) counter
1661:     -	0026"         	bdis_col        defs 2              ; Display column
1662:     -	0028"         	track           defs 2              ; Current track
1663:     -	002A"         	disp_track      defs 2              ; Displayed track
1664:     -	002C"         	sector          defs 2              ; Current sector
1665:     -	002E"         	total_sectors   defs 3              ; Number of sectors in file system
1666:     -	0031"         	                defs STACK_SIZE     ; Stack space
1667:     -	0071"         	app_stack_top
1668:				;
1669:     -	0071"         	                end



Statistics:

     4	passes
     0	jr promotions
   431	symbols
  2604	bytes

   108	macro calls
  1546	macro bytes
     0	invented symbols



Symbol Table:

ALLCF_COUNT    =1F        31
ALLCF_SPARSE_BIT=06        6
ALLCF_SPARSE_MASK=40        64
ALLCF_UNUSED_BIT=07        7
ALLCF_UNUSED_MASK=80        128
ANSI_SGR_BLINK_OFF=19        25
ANSI_SGR_BOLD  =01        1
ANSI_SGR_DULINE=15        21
ANSI_SGR_FAINT =02        2
ANSI_SGR_FONT_1=0B        11
ANSI_SGR_FONT_2=0C        12
ANSI_SGR_FONT_3=0D        13
ANSI_SGR_FONT_4=0E        14
ANSI_SGR_FONT_5=0F        15
ANSI_SGR_FONT_6=10        16
ANSI_SGR_FONT_7=11        17
ANSI_SGR_FONT_8=12        18
ANSI_SGR_FONT_9=13        19
ANSI_SGR_GOTHIC=14        20
ANSI_SGR_HIDE_OFF=1C        28
ANSI_SGR_ITAL_OFF=17        23
ANSI_SGR_NORMAL=00        0
ANSI_SGR_NORM_INTEN=16        22
ANSI_SGR_PRI_FONT=0A        10
ANSI_SGR_RBLINK=06        6
ANSI_SGR_REV   =07        7
ANSI_SGR_REV_OFF=1B        27
ANSI_SGR_SBLINK=05        5
ANSI_SGR_STRIKE=09        9
ANSI_SGR_STRIKE_OFF=1D        29
ANSI_SGR_ULINE =04        4
ANSI_SGR_ULINE_OFF=18        24
ASCII_BS       =08        8
ASCII_CR       =0D        13
ASCII_DEL      =7F        127
ASCII_ENQ      =05        5
ASCII_ESC      =1B        27
ASCII_FF       =0C        12
ASCII_HT       =09        9
ASCII_LF       =0A        10
ASCII_RS       =1E        30
ASCII_SUB      =1A        26
ASCII_SYN      =16        22
ASCII_VT       =0B        11
BDIS_CHARS_MAX = 3C0      960
BDOS           =05        5
BDOS_CLOSE_FILE=10        16
BDOS_CON_IN    =01        1
BDOS_CON_OUT   =02        2
BDOS_DELETE_FILE=13        19
BDOS_DIRECT_CON_IO=06        6
BDOS_GET_ALLOC_ADDR=1B        27
BDOS_GET_CON_STAT=0B        11
BDOS_GET_CURR_DISK=19        25
BDOS_GET_DPB   =1F        31
BDOS_GET_FILE_SIZE=23        35
BDOS_GET_IO_BYTE=07        7
BDOS_GET_LOGIN_VEC=18        24
BDOS_GET_RO_VEC=1D        29
BDOS_GET_SET_USER=20        32
BDOS_LST_OUT   =05        5
BDOS_MAKE_FILE =16        22
BDOS_OPEN_FILE =0F        15
BDOS_PRINT_STRING=09        9
BDOS_PUN_OUT   =04        4
BDOS_RDR_IN    =03        3
BDOS_READ_CON_BUFF=0A        10
BDOS_READ_RANDOM=21        33
BDOS_READ_SEQ  =14        20
BDOS_READ_SEQ_EOF=01        1
BDOS_RENAME_FILE=17        23
BDOS_RESET_DISK_SYS=0D        13
BDOS_RESET_DRIVES=25        37
BDOS_SEARCH_FIRST=11        17
BDOS_SEARCH_NEXT=12        18
BDOS_SEL_DISK  =0E        14
BDOS_SET_DMA_ADDR=1A        26
BDOS_SET_FILE_ATTR=1E        30
BDOS_SET_IO_BYTE=08        8
BDOS_SET_RANDOM_REC=24        36
BDOS_START     =DE06      56838
BDOS_SYS_RST   =00        0
BDOS_VERSION   =0C        12
BDOS_WRITE_PROT=1C        28
BDOS_WRITE_RANDOM=22        34
BDOS_WRITE_RAN_ZFILL=28        40
BDOS_WRITE_SEQ =15        21
BIOS_AUXIST    =33        51
BIOS_AUXOST    =36        54
BIOS_CONIN     =06        6
BIOS_CONOST    =30        48
BIOS_CONOUT    =09        9
BIOS_CONST     =03        3
BIOS_CPM_START_SEC=2C        44
BIOS_DEVINI    =3C        60
BIOS_DEVTBL    =39        57
BIOS_DRVTBL    =3F        63
BIOS_FLUSH     =45        69
BIOS_GET_TIMER =7B        123
BIOS_HOME      =15        21
BIOS_ID        =60        96
BIOS_INT_DISABLE=6F        111
BIOS_INT_ENABLE=72        114
BIOS_JPTBL_NEXT=7E        126
BIOS_LISTST    =2A        42
BIOS_MAX_SIZE  =1000      4096
BIOS_MON_CALL  =69        105
BIOS_MOVE      =48        72
BIOS_MULTIO    =42        66
BIOS_OPT_DEBUG_BIT=00        0
BIOS_OPT_DEBUG_MASK=01        1
BIOS_OPT_NOINTS_BIT=01        1
BIOS_OPT_NOINTS_MASK=02        2
BIOS_OPT_RAWCON_BIT=02        2
BIOS_OPT_RAWCON_MASK=04        4
BIOS_PLIST     =0C        12
BIOS_PUNCH     =0F        15
BIOS_READ      =24        36
BIOS_READER    =12        18
BIOS_RESERV1   =5A        90
BIOS_RESERV2   =5D        93
BIOS_SECTRAN   =2D        45
BIOS_SELDSK    =18        24
BIOS_SELMEM    =4E        78
BIOS_SETBNK    =51        81
BIOS_SETDMA    =21        33
BIOS_SETSEC    =1E        30
BIOS_SETTRK    =1B        27
BIOS_SET_TIMER =78        120
BIOS_START     =EC00      60416
BIOS_STARTUP   =66        102
BIOS_SUPER     =6C        108
BIOS_TIME      =4B        75
BIOS_TIRD      =75        117
BIOS_USERF     =57        87
BIOS_VER       =63        99
BIOS_WBOOT     =00        0
BIOS_WRITE     =27        39
BIOS_XMOVE     =54        84
BREAK_CHAR     =03        3
BitAddrMask      529'     1321
CCP_START      =D600      54784
CDISK          =04        4
CONCAP_ANSI_BIT=01        1
CONCAP_ANSI_MASK=02        2
CONCAP_UNICODE_BIT=02        2
CONCAP_UNICODE_MASK=04        4
CONCAP_ZARC_BIT=00        0
CONCAP_ZARC_MASK=01        1
CPM_BIAS       =A200      41472
CPM_DISK_SIZE  =00100000  1048576
CPM_SECTOR_SIZE=80        128
CPM_SYS_SIZE   =00100000  1048576
DEF_BUFFER     =80        128
DEF_BUFFER_SIZE=80        128
DIRE_ALLOC     =10        16
DIRE_EX        =0C        12
DIRE_NAME      =01        1
DIRE_RC        =0F        15
DIRE_S1        =0D        13
DIRE_S2        =0E        14
DIRE_SIZE      =20        32
DIRE_TYP       =09        9
DIRE_USER      =00        0
DPB_AL0        =09        9
DPB_AL1        =0A        10
DPB_BLM        =03        3
DPB_BSH        =02        2
DPB_CKS        =0B        11
DPB_DRM        =07        7
DPB_DSM        =05        5
DPB_EXM        =04        4
DPB_OFF        =0D        13
DPB_SIZE       =0F        15
DPB_SPT        =00        0
DPH_ALV        =0E        14
DPH_CSV        =0C        12
DPH_DIRBF      =08        8
DPH_DPB        =0A        10
DPH_SCRATCH0   =02        2
DPH_SCRATCH1   =04        4
DPH_SCRATCH2   =06        6
DPH_SIZE       =10        16
DPH_XLT        =00        0
FCB1           =5C        92
FCB2           =6C        108
FCB_ALLOC      =10        16
FCB_CR         =20        32
FCB_DRIVE      =00        0
FCB_EX         =0C        12
FCB_NAME       =01        1
FCB_RC         =0F        15
FCB_RECORD     =21        33
FCB_S1         =0D        13
FCB_S2         =0E        14
FCB_SIZE       =24        36
FCB_TYP        =09        9
FILEEXT_SIZE   =03        3
FILENAME_SIZE  =08        8
FILE_EOF       =1A        26
FI_EX_FLAGS    =10        16
FI_EX_FL_LEN   =0F        15
FI_LAST_PEXT   =0C        12
FI_LAST_RC     =0E        14
FI_NAME        =01        1
FI_SIZE        =10        16
FI_TYP         =09        9
FI_USER        =00        0
INT_VEC_TABLE  =FFE0      65504
IOBYTE         =03        3
IOB_CON_MASK   =03        3
IOB_LST_MASK   =C0        192
IOB_PUN_MASK   =30        48
IOB_RDR_MASK   =0C        12
MAX_USER       =0F        15
MMAP_CPM_PAGES =04        4
MTWDLI_ABBREV_BIT=00        0
MTWDLI_ABBREV_MASK=01        1
MTWDLI_ICASE_BIT=01        1
MTWDLI_ICASE_MASK=02        2
MTWDLI_TERM_BIT=07        7
MTWDLI_TERM_MASK=80        128
NUM_DISKS      =10        16
NUM_DISKS_MAX  =10        16
STACK_SIZE     =40        64
TPA_START      = 100      256
VT100_COLS     =50        80
VT100_ROWS     =18        24
ZKEY_CSR_DOWN  =1E        30
ZKEY_CSR_LEFT  =01        1
ZKEY_CSR_RIGHT =06        6
ZKEY_CSR_UP    =1F        31
ZKEY_DELETE    =7F        127
ZKEY_END       =04        4
ZKEY_HOME      =02        2
ZKEY_INSERT    =16        22
ZKEY_PAGE_DOWN =1C        28
ZKEY_PAGE_UP   =1D        29
app_stack_top   71"       113
bad_ex_cnt_msg   932'     2354
bad_name_msg     921'     2337
bad_rc_msg       9ED'     2541
bad_s1_msg       946'     2374
bad_user_msg     90E'     2318
bam_div_loop     537'     1335
bam_mask_loop    531'     1329
bdis_blk_done    404'     1028
bdis_col        26"       38
bdis_col_done    421'     1057
bdis_entry_done  426'     1062
bdis_loop        3E3'     995
bdis_not_dir     3F4'     1012
bdis_s_count    25"       37
bdis_scale      24"       36
bdis_scale_done  3CF'     975
bdis_scale_loop  3B2'     946
bdis_shift      23"       35
bdos_sp         00"       0
bfc_done        E2'       226
bfc_loop        D2'       210
blk_flags       04"       4
blk_flags_size  06"       6
blk_too_big_msg  9A1'     2465
block_map_msg    84C'     2124
blocks_used     15"       21
blocks_used_msg  83E'     2110
cbdos           00        0 (extern)
cbios           00        0 (extern)
ccinit          00        0 (extern)
ccls            00        0 (extern)
chk_mem_lim      5CF'     1487
cldcur          00        0 (extern)
concap          00        0 (extern)
conrch          00        0 (extern)
conrev          00        0 (extern)
const           00        0 (extern)
conuln          00        0 (extern)
conwch          00        0 (extern)
conwmn          00        0 (extern)
conwms          00        0 (extern)
cscrup          00        0 (extern)
csrvis          00        0 (extern)
cwnwln          00        0 (extern)
cwpdby          00        0 (extern)
cwpdlo          00        0 (extern)
cwpdwd          00        0 (extern)
cwphby          00        0 (extern)
cwphnb          00        0 (extern)
cwphwd          00        0 (extern)
cwpspc          00        0 (extern)
cwvich          00        0 (extern)
dble_blk_msg     96E'     2414
df_name_loop     655'     1621
df_type_loop     66C'     1644
dir_blocks      0E"       14
dir_done_msg     7F9'     2041
dir_entry_num   21"       33
dire            1D"       29
disk_err_msg     7E7'     2023
disp_file        63A'     1594
disp_track      2A"       42
dpb             1B"       27
dph             19"       25
drive           02"       2
drive_sel_ok    95'       149
empty_msg        A13'     2579
error_count     0F"       15
errors_msg       887'     2183
exit             4E8'     1256
exit_msg         7A6'     1958
ext_dup_msg      950'     2384
fb_error         57E'     1406
fe_dup_err       5CB'     1483
fe_exit          5CC'     1484
fe_have_space    5B9'     1465
fi_make_room     5DC'     1500
fie             1F"       31
file_count      11"       17
files_info      08"       8
files_msg        815'     2069
fimr_clr_done    62F'     1583
fimr_clr_loop    625'     1573
fimr_exit        621'     1569
fimr_no_copy     633'     1587
flag_block       54E'     1358
flag_extent      583'     1411
free_start      0A"       10
fstfre          00        0 (extern)
ge_have_sec      6D0'     1744
ge_load_reqd     6BA'     1722
get_entry        6A1'     1697
id_al_done       100'     256
id_al_loop      F8'       248
id_mark_used_lp  10C'     268
init_blk_div    C3'       195
jptbl_addr     =7E        126
loaded_sector   0C"       12
match_files      676'     1654
memory_msg       7BB'     1979
mf_exit          69A'     1690
mf_name_loop     681'     1665
mf_no_match      69E'     1694
mf_typ_loop      68B'     1675
msg_exit         4E5'     1253
mtwdli          00        0 (extern)
no_alloc_msg     9BE'     2494
no_ss_msg        89D'     2205
no_z80_msg       75C'     1884
on_z80          18'       24
op_check_term   69'       105
op_err_msg       76F'     1903
op_error        70'       112
op_found        50'       80
op_options      37'       55
operands_ok     76'       118
out_of_memory    4E2'     1250
panic           00        0 (extern)
phys_extent     17"       23
rddulo          00        0 (extern)
rdduwd          00        0 (extern)
rdhxwd          00        0 (extern)
rshift_word      541'     1345
rshw_loop        542'     1346
scan_done        304'     772
scan_done_msg    8FC'     2300
scan_enable     03"       3
scan_loop        120'     288
sector          2C"       44
sector_msg       8F1'     2289
sel_err_msg      7D1'     2001
set_c_reg        54B'     1355
set_sector       6E3'     1763
signon_msg       732'     1842
skpspc          00        0 (extern)
sl_calc_ext_dn   15D'     349
sl_calc_ext_lp   151'     337
sl_do_next       2FB'     763
sl_entry_done    2E8'     744
sl_err_cont      4F5'     1269
sl_err_stop      2FF'     767
sl_find_loop     1D0'     464
sl_name_chk      176'     374
sl_not_unused    13E'     318
sl_user_ok       16B'     363
slf_alu_dn       292'     658
slf_by_alu_dn    28E'     654
slf_by_alu_lp    274'     628
slf_by_alu_used  27E'     638
slf_bytes        272'     626
slf_ext_done     241'     577
slf_found_fi     231'     561
slf_name_loop    20E'     526
slf_no_match     1F6'     502
slf_typ_loop     216'     534
slf_wd_alu_dn    26A'     618
slf_wd_alu_lp    24F'     591
slf_wd_alu_used  25D'     605
slfrc_done       2E8'     744
slfrc_not_last   2C6'     710
slfrc_update     2D9'     729
sparse_msg       982'     2434
spck_bit_loop    344'     836
spck_byte_loop   32E'     814
spck_byte_ok     33A'     826
spck_done        362'     866
spck_error       513'     1299
spck_file_done   354'     852
spck_last_byte   33E'     830
spck_last_ok     34C'     844
spck_loop        308'     776
spck_not_empty   32B'     811
spck_sp_err      338'     824
ss_disp_track    48C'     1164
ss_find_sec_lp   45A'     1114
ss_loop          478'     1144
ss_nodisp        49A'     1178
ss_sec_done      4B8'     1208
ss_track_done    701'     1793
ss_track_loop    6EB'     1771
str_offset     =10        16
surf_scan_msg    8B4'     2228
surface_scan     448'     1096
toloca          00        0 (extern)
total_sectors   2E"       46
toupca          00        0 (extern)
track           28"       40
track_msg        8E8'     2280
unused_count    13"       19
unused_msg       823'     2083
z80det          00        0 (extern)
zrcdet          00        0 (extern)
